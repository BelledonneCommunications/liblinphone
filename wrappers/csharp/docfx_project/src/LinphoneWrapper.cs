/*
LinphoneWrapper.cs
Copyright (C) 2017 Belledonne Communications SARL

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
#if __IOS__
using ObjCRuntime;
#endif

namespace Linphone
{
#region Wrapper specifics
	/// <summary>
	/// Only contains the LIB_NAME value that represents the library in which all DllImport are made
	/// </summary>
	public class LinphoneWrapper
	{
		public const string VERSION = "4.5.0-alpha-317-g028d45e";
#if __IOS__
		public const string LIB_NAME = "linphone.framework/linphone";
#elif WINDOWS_UWP
		public const string LIB_NAME = "liblinphone"; // With this, it automatically finds liblinphone.dll
#else
		public const string LIB_NAME = "linphone"; // With this, it automatically finds liblinphone.so
#endif

#if WINDOWS_UWP
		public const string BELLE_SIP_LIB_NAME = "bellesip";
		public const string BCTOOLBOX_LIB_NAME = "bctoolbox";
#else
		public const string BELLE_SIP_LIB_NAME = LIB_NAME;
		public const string BCTOOLBOX_LIB_NAME = LIB_NAME;
#endif
/// https://docs.microsoft.com/fr-fr/xamarin/cross-platform/app-fundamentals/building-cross-platform-applications/platform-divergence-abstraction-divergent-implementation#android
#if __ANDROID__
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void setAndroidLogHandler();
#endif
#if __IOS__
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_iphone_enable_logs();
#endif

		/// <summary>
		/// Registers the native log handler in Linphone.
		/// </summary>
		public static void setNativeLogHandler()
		{
#if __ANDROID__
			setAndroidLogHandler();
#elif __IOS__
			linphone_iphone_enable_logs();
#endif
		}
	}

	/// <summary>
	/// All methods that returns a LinphoneStatus with a value != 0 as an error code in C are translated in C# by throwing a LinphoneException
	/// </summary>
#if WINDOWS_UWP
    public class LinphoneException : System.Exception
    {
        public LinphoneException() : base() { }
        public LinphoneException(string message) : base(message) { }
        public LinphoneException(string message, System.Exception inner) : base(message, inner) { }
    }
#else
    [Serializable()]
	public class LinphoneException : System.Exception
	{
		public LinphoneException() : base() { }
		public LinphoneException(string message) : base(message) { }
		public LinphoneException(string message, System.Exception inner) : base(message, inner) { }
		protected LinphoneException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
	}
#endif

	[StructLayout(LayoutKind.Sequential)]
	/// <summary>
	/// Parent class for a Linphone public objects
	/// </summary>
	public class LinphoneObject
	{
		internal IntPtr nativePtr;

		internal GCHandle handle;

		internal List<IntPtr> string_ptr_list;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLinphoneObjectDataDestroyed(IntPtr data);

		[DllImport(LinphoneWrapper.BELLE_SIP_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern int belle_sip_object_data_set(IntPtr ptr, string name, IntPtr data, IntPtr cb);
#else
		static extern int belle_sip_object_data_set(IntPtr ptr, string name, IntPtr data, OnLinphoneObjectDataDestroyed cb);
#endif

		[DllImport(LinphoneWrapper.BELLE_SIP_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr belle_sip_object_data_get(IntPtr ptr, string name);

		[DllImport(LinphoneWrapper.BELLE_SIP_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr belle_sip_object_ref(IntPtr ptr);

		[DllImport(LinphoneWrapper.BELLE_SIP_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void belle_sip_object_unref(IntPtr ptr);

		[DllImport(LinphoneWrapper.BELLE_SIP_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void belle_sip_object_data_remove(IntPtr ptr, string name);

		[DllImport(LinphoneWrapper.BCTOOLBOX_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr bctbx_list_next(IntPtr ptr);

		[DllImport(LinphoneWrapper.BCTOOLBOX_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr bctbx_list_get_data(IntPtr ptr);

		[DllImport(LinphoneWrapper.BCTOOLBOX_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr bctbx_list_append(IntPtr elem, IntPtr data);

		~LinphoneObject()
		{
			//Console.WriteLine("Destroying " + this.ToString());
			if (nativePtr != IntPtr.Zero) {
				//Console.WriteLine("Unreffing " + this.ToString());
				belle_sip_object_data_remove(nativePtr, "cs_obj");
				belle_sip_object_unref(nativePtr);
				handle.Free();
			}
		}

		internal static T fromNativePtr<T>(IntPtr ptr, bool takeRef=true) where T : LinphoneObject, new()
		{
			if (ptr == IntPtr.Zero) return null;
			IntPtr objPtr = belle_sip_object_data_get(ptr, "cs_obj");
			if (objPtr != IntPtr.Zero)
			{
				T obj = null;
				GCHandle handle = GCHandle.FromIntPtr(objPtr);
				if (handle.IsAllocated)
				{
					obj = (T)handle.Target;
				}
				if (obj == null)
				{
					//Console.WriteLine("Handle target is null " + handle.Target);
					objPtr = IntPtr.Zero;
				}
				else
				{
					//Console.WriteLine("Using existing " + obj.ToString());
					return obj;
				}
			}
			if (objPtr == IntPtr.Zero)
			{
				T obj = new T();
				//Console.WriteLine("Creating " + obj.ToString());
				if (takeRef)
				{
					ptr = belle_sip_object_ref(ptr);
					//Console.WriteLine("Reffing " + obj.ToString());
				}
				obj.nativePtr = ptr;
				obj.handle = GCHandle.Alloc(obj, GCHandleType.WeakTrackResurrection);
				objPtr = GCHandle.ToIntPtr(obj.handle);
#if WINDOWS_UWP
				belle_sip_object_data_set(ptr, "cs_obj", objPtr, IntPtr.Zero);
#else
				belle_sip_object_data_set(ptr, "cs_obj", objPtr, null);
#endif

				return obj;
			}
			return null;
		}

		internal static IEnumerable<string> MarshalStringArray(IntPtr listPtr)
		{
			if (listPtr != IntPtr.Zero)
			{
				IntPtr ptr = listPtr;
				while (ptr != IntPtr.Zero)
				{
					IntPtr dataPtr = bctbx_list_get_data(ptr);
					if (dataPtr == IntPtr.Zero)
					{
						break;
					}
					string key = Marshal.PtrToStringAnsi(dataPtr);
					yield return key;
					ptr = bctbx_list_next(ptr);
				}
			}
		}

		internal static IEnumerable<T> MarshalBctbxList<T>(IntPtr listPtr, bool takeRef=true) where T : LinphoneObject, new()
		{
			if (listPtr != IntPtr.Zero)
			{
				IntPtr ptr = listPtr;
				while (ptr != IntPtr.Zero)
				{
					IntPtr dataPtr = bctbx_list_get_data(ptr);
					if (dataPtr == IntPtr.Zero)
					{
						break;
					}
					T obj = fromNativePtr<T>(dataPtr, takeRef);
					yield return obj;
					ptr = bctbx_list_next(ptr);
				}
			}
		}

		internal protected IntPtr StringArrayToBctbxList(IEnumerable<string> stringlist)
		{
			IntPtr bctbx_list = IntPtr.Zero;
			string_ptr_list = new List<IntPtr>();
			foreach (string s in stringlist)
			{
				IntPtr string_ptr = Marshal.StringToHGlobalAnsi(s);
				bctbx_list = bctbx_list_append(bctbx_list, string_ptr);
				string_ptr_list.Add(string_ptr);
			}
			return bctbx_list;
		}

		internal protected void CleanStringArrayPtrs()
		{
			foreach (IntPtr string_ptr in string_ptr_list)
			{
				Marshal.FreeHGlobal(string_ptr);
			}
		}

		internal static IntPtr ObjectArrayToBctbxList<T>(IEnumerable<T> objlist) where T : LinphoneObject, new()
		{
			IntPtr bctbx_list = IntPtr.Zero;
			foreach (T ptr in objlist)
			{
				bctbx_list = bctbx_list_append(bctbx_list, ptr.nativePtr);
			}
			return bctbx_list;
		}
	}

	public class MediastreamerFactory
	{
		public IntPtr nativePtr;

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int ms_factory_enable_filter_from_name(IntPtr nativePtr, string name, char enabled);

		public void enableFilterFromName(string name, bool enabled)
		{
			ms_factory_enable_filter_from_name(nativePtr, name, enabled ? (char)1 : (char)0);
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void ms_devices_info_add(IntPtr devices_info, string manufacturer, string model, string platform, uint flags, int delay, int recommended_rate);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr ms_factory_get_devices_info(IntPtr factory);

		public void addDevicesInfo(string manufacturer, string model, string platform, uint flags, int delay, int recommended_rate)
		{
				ms_devices_info_add(ms_factory_get_devices_info(nativePtr), manufacturer, model, platform, flags, delay, recommended_rate);
		}
	}
#endregion

#region Enums

	/// <summary>
	/// Enum describing RTP AVPF activation modes. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AVPFMode
	{
		/// <summary>
		/// Use default value defined at upper level. 
		/// <para>
		/// </para>
		/// </summary>
		Default = -1,
		/// <summary>
		/// AVPF is disabled. 
		/// <para>
		/// </para>
		/// </summary>
		Disabled = 0,
		/// <summary>
		/// AVPF is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		Enabled = 1,
	}

	/// <summary>
	/// Enum describing activation code checking, used by the <see
	/// cref="Linphone.AccountCreator" />. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorActivationCodeStatus
	{
		/// <summary>
		/// Activation code ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Activation code too short. 
		/// <para>
		/// </para>
		/// </summary>
		TooShort = 1,
		/// <summary>
		/// Activation code too long. 
		/// <para>
		/// </para>
		/// </summary>
		TooLong = 2,
		/// <summary>
		/// Contain invalid characters. 
		/// <para>
		/// </para>
		/// </summary>
		InvalidCharacters = 3,
	}

	/// <summary>
	/// Enum describing algorithm checking, used by the <see
	/// cref="Linphone.AccountCreator" />. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorAlgoStatus
	{
		/// <summary>
		/// Algorithm ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Algorithm not supported. 
		/// <para>
		/// </para>
		/// </summary>
		NotSupported = 1,
	}

	/// <summary>
	/// Enum describing domain checking, used by the <see
	/// cref="Linphone.AccountCreator" />. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorDomainStatus
	{
		/// <summary>
		/// Domain ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Domain invalid. 
		/// <para>
		/// </para>
		/// </summary>
		Invalid = 1,
	}

	/// <summary>
	/// Enum describing email checking, used by the <see cref="Linphone.AccountCreator"
	/// />. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorEmailStatus
	{
		/// <summary>
		/// Email ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Email malformed. 
		/// <para>
		/// </para>
		/// </summary>
		Malformed = 1,
		/// <summary>
		/// Contain invalid characters. 
		/// <para>
		/// </para>
		/// </summary>
		InvalidCharacters = 2,
	}

	/// <summary>
	/// Enum describing language checking, used by the <see
	/// cref="Linphone.AccountCreator" />. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorLanguageStatus
	{
		/// <summary>
		/// Language ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
	}

	/// <summary>
	/// Enum describing password checking, used by the <see
	/// cref="Linphone.AccountCreator" />. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorPasswordStatus
	{
		/// <summary>
		/// Password ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Password too short. 
		/// <para>
		/// </para>
		/// </summary>
		TooShort = 1,
		/// <summary>
		/// Password too long. 
		/// <para>
		/// </para>
		/// </summary>
		TooLong = 2,
		/// <summary>
		/// Contain invalid characters. 
		/// <para>
		/// </para>
		/// </summary>
		InvalidCharacters = 3,
		/// <summary>
		/// Missing specific characters. 
		/// <para>
		/// </para>
		/// </summary>
		MissingCharacters = 4,
	}

	/// <summary>
	/// Enum describing phone number checking, used by the <see
	/// cref="Linphone.AccountCreator" />. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorPhoneNumberStatus
	{
		/// <summary>
		/// Phone number ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 1,
		/// <summary>
		/// Phone number too short. 
		/// <para>
		/// </para>
		/// </summary>
		TooShort = 2,
		/// <summary>
		/// Phone number too long. 
		/// <para>
		/// </para>
		/// </summary>
		TooLong = 4,
		/// <summary>
		/// Country code invalid. 
		/// <para>
		/// </para>
		/// </summary>
		InvalidCountryCode = 8,
		/// <summary>
		/// Phone number invalid. 
		/// <para>
		/// </para>
		/// </summary>
		Invalid = 16,
	}

	/// <summary>
	/// Enum describing the status of server request, used by the <see
	/// cref="Linphone.AccountCreator" />. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorStatus
	{
		/// <summary>
		/// Request status. 
		/// <para>
		/// Request passed 
		/// </para>
		/// </summary>
		RequestOk = 0,
		/// <summary>
		/// Request failed. 
		/// <para>
		/// </para>
		/// </summary>
		RequestFailed = 1,
		/// <summary>
		/// Request failed due to missing argument(s) 
		/// <para>
		/// </para>
		/// </summary>
		MissingArguments = 2,
		/// <summary>
		/// Request failed due to missing callback(s) 
		/// <para>
		/// </para>
		/// </summary>
		MissingCallbacks = 3,
		/// <summary>
		/// Account status. 
		/// <para>
		/// Account created 
		/// </para>
		/// </summary>
		AccountCreated = 4,
		/// <summary>
		/// Account not created. 
		/// <para>
		/// </para>
		/// </summary>
		AccountNotCreated = 5,
		/// <summary>
		/// Account exist. 
		/// <para>
		/// </para>
		/// </summary>
		AccountExist = 6,
		/// <summary>
		/// Account exist with alias. 
		/// <para>
		/// </para>
		/// </summary>
		AccountExistWithAlias = 7,
		/// <summary>
		/// Account not exist. 
		/// <para>
		/// </para>
		/// </summary>
		AccountNotExist = 8,
		/// <summary>
		/// Account was created with Alias. 
		/// <para>
		/// </para>
		/// </summary>
		AliasIsAccount = 9,
		/// <summary>
		/// Alias exist. 
		/// <para>
		/// </para>
		/// </summary>
		AliasExist = 10,
		/// <summary>
		/// Alias not exist. 
		/// <para>
		/// </para>
		/// </summary>
		AliasNotExist = 11,
		/// <summary>
		/// Account activated. 
		/// <para>
		/// </para>
		/// </summary>
		AccountActivated = 12,
		/// <summary>
		/// Account already activated. 
		/// <para>
		/// </para>
		/// </summary>
		AccountAlreadyActivated = 13,
		/// <summary>
		/// Account not activated. 
		/// <para>
		/// </para>
		/// </summary>
		AccountNotActivated = 14,
		/// <summary>
		/// Account linked. 
		/// <para>
		/// </para>
		/// </summary>
		AccountLinked = 15,
		/// <summary>
		/// Account not linked. 
		/// <para>
		/// </para>
		/// </summary>
		AccountNotLinked = 16,
		/// <summary>
		/// Server. 
		/// <para>
		/// Error server 
		/// </para>
		/// </summary>
		ServerError = 17,
		/// <summary>
		/// Error cannot send SMS. 
		/// <para>
		/// </para>
		/// </summary>
		PhoneNumberInvalid = 18,
		/// <summary>
		/// Error key doesn't match. 
		/// <para>
		/// </para>
		/// </summary>
		WrongActivationCode = 19,
		/// <summary>
		/// Error too many SMS sent. 
		/// <para>
		/// </para>
		/// </summary>
		PhoneNumberOverused = 20,
		/// <summary>
		/// Error algo isn't MD5 or SHA-256. 
		/// <para>
		/// </para>
		/// </summary>
		AlgoNotSupported = 21,
		/// <summary>
		/// Generic error. 
		/// <para>
		/// </para>
		/// </summary>
		UnexpectedError = 22,
	}

	/// <summary>
	/// Enum describing transport checking, used by the <see
	/// cref="Linphone.AccountCreator" />. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorTransportStatus
	{
		/// <summary>
		/// Transport ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Transport invalid. 
		/// <para>
		/// </para>
		/// </summary>
		Unsupported = 1,
	}

	/// <summary>
	/// Enum describing username checking, used by the <see
	/// cref="Linphone.AccountCreator" />. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorUsernameStatus
	{
		/// <summary>
		/// Username ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Username too short. 
		/// <para>
		/// </para>
		/// </summary>
		TooShort = 1,
		/// <summary>
		/// Username too long. 
		/// <para>
		/// </para>
		/// </summary>
		TooLong = 2,
		/// <summary>
		/// Contain invalid characters. 
		/// <para>
		/// </para>
		/// </summary>
		InvalidCharacters = 3,
		/// <summary>
		/// Invalid username. 
		/// <para>
		/// </para>
		/// </summary>
		Invalid = 4,
	}

	/// <summary>
	/// Enum describing Ip family. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AddressFamily
	{
		/// <summary>
		/// IpV4. 
		/// <para>
		/// </para>
		/// </summary>
		Inet = 0,
		/// <summary>
		/// IpV6. 
		/// <para>
		/// </para>
		/// </summary>
		Inet6 = 1,
		/// <summary>
		/// Unknown. 
		/// <para>
		/// </para>
		/// </summary>
		Unspec = 2,
	}

	/// <summary>
	/// LinphoneAudioDeviceCapabilities enum represents whether a device can record
	/// audio, play audio or both 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum AudioDeviceCapabilities
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		CapabilityRecord = 1<<0,
		/// <summary>
		/// Can record audio. 
		/// <para>
		/// </para>
		/// </summary>
		CapabilityPlay = 1<<1,
	}

	/// <summary>
	/// LinphoneAudioDeviceType enum represents the different types of an audio device. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AudioDeviceType
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 0,
		/// <summary>
		/// Unknown. 
		/// <para>
		/// </para>
		/// </summary>
		Microphone = 1,
		/// <summary>
		/// Microphone. 
		/// <para>
		/// </para>
		/// </summary>
		Earpiece = 2,
		/// <summary>
		/// Earpiece. 
		/// <para>
		/// </para>
		/// </summary>
		Speaker = 3,
		/// <summary>
		/// Speaker. 
		/// <para>
		/// </para>
		/// </summary>
		Bluetooth = 4,
		/// <summary>
		/// Bluetooth. 
		/// <para>
		/// </para>
		/// </summary>
		BluetoothA2DP = 5,
		/// <summary>
		/// Bluetooth A2DP. 
		/// <para>
		/// </para>
		/// </summary>
		Telephony = 6,
		/// <summary>
		/// Telephony. 
		/// <para>
		/// </para>
		/// </summary>
		AuxLine = 7,
		/// <summary>
		/// AuxLine. 
		/// <para>
		/// </para>
		/// </summary>
		GenericUsb = 8,
		/// <summary>
		/// GenericUsb. 
		/// <para>
		/// </para>
		/// </summary>
		Headset = 9,
		/// <summary>
		/// Headset. 
		/// <para>
		/// </para>
		/// </summary>
		Headphones = 10,
	}

	/// <summary>
	/// Enum describing the authentication methods. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AuthMethod
	{
		/// <summary>
		/// Digest authentication requested. 
		/// <para>
		/// </para>
		/// </summary>
		HttpDigest = 0,
		/// <summary>
		/// Client certificate requested. 
		/// <para>
		/// </para>
		/// </summary>
		Tls = 1,
	}

	/// <summary>
	/// Enum representing the direction of a call. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum CallDir
	{
		/// <summary>
		/// outgoing calls 
		/// <para>
		/// </para>
		/// </summary>
		Outgoing = 0,
		/// <summary>
		/// incoming calls 
		/// <para>
		/// </para>
		/// </summary>
		Incoming = 1,
	}

	/// <summary>
	/// LinphoneCallState enum represents the different states a call can reach into. 
	/// <para>
	/// The application is notified of a state change through the
	/// LinphoneCoreVTable::call_state_changed callback. 
	/// </para>
	/// </summary>
	
	public enum CallState
	{
		/// <summary>
		/// Initial state. 
		/// <para>
		/// </para>
		/// </summary>
		Idle = 0,
		/// <summary>
		/// Incoming call received. 
		/// <para>
		/// </para>
		/// </summary>
		IncomingReceived = 1,
		/// <summary>
		/// PushIncoming call received. 
		/// <para>
		/// </para>
		/// </summary>
		PushIncomingReceived = 2,
		/// <summary>
		/// Outgoing call initialized. 
		/// <para>
		/// </para>
		/// </summary>
		OutgoingInit = 3,
		/// <summary>
		/// Outgoing call in progress. 
		/// <para>
		/// </para>
		/// </summary>
		OutgoingProgress = 4,
		/// <summary>
		/// Outgoing call ringing. 
		/// <para>
		/// </para>
		/// </summary>
		OutgoingRinging = 5,
		/// <summary>
		/// Outgoing call early media. 
		/// <para>
		/// </para>
		/// </summary>
		OutgoingEarlyMedia = 6,
		/// <summary>
		/// Connected. 
		/// <para>
		/// </para>
		/// </summary>
		Connected = 7,
		/// <summary>
		/// Streams running. 
		/// <para>
		/// </para>
		/// </summary>
		StreamsRunning = 8,
		/// <summary>
		/// Pausing. 
		/// <para>
		/// </para>
		/// </summary>
		Pausing = 9,
		/// <summary>
		/// Paused. 
		/// <para>
		/// </para>
		/// </summary>
		Paused = 10,
		/// <summary>
		/// Resuming. 
		/// <para>
		/// </para>
		/// </summary>
		Resuming = 11,
		/// <summary>
		/// Referred. 
		/// <para>
		/// </para>
		/// </summary>
		Referred = 12,
		/// <summary>
		/// Error. 
		/// <para>
		/// </para>
		/// </summary>
		Error = 13,
		/// <summary>
		/// Call end. 
		/// <para>
		/// </para>
		/// </summary>
		End = 14,
		/// <summary>
		/// Paused by remote. 
		/// <para>
		/// </para>
		/// </summary>
		PausedByRemote = 15,
		/// <summary>
		/// The call's parameters are updated for example when video is asked by remote. 
		/// <para>
		/// </para>
		/// </summary>
		UpdatedByRemote = 16,
		/// <summary>
		/// We are proposing early media to an incoming call. 
		/// <para>
		/// </para>
		/// </summary>
		IncomingEarlyMedia = 17,
		/// <summary>
		/// We have initiated a call update. 
		/// <para>
		/// </para>
		/// </summary>
		Updating = 18,
		/// <summary>
		/// The call object is now released. 
		/// <para>
		/// </para>
		/// </summary>
		Released = 19,
		/// <summary>
		/// The call is updated by remote while not yet answered (SIP UPDATE in early
		/// dialog received) 
		/// <para>
		/// </para>
		/// </summary>
		EarlyUpdatedByRemote = 20,
		/// <summary>
		/// We are updating the call while not yet answered (SIP UPDATE in early dialog
		/// sent) 
		/// <para>
		/// </para>
		/// </summary>
		EarlyUpdating = 21,
	}

	/// <summary>
	/// Enum representing the status of a call. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum CallStatus
	{
		/// <summary>
		/// The call was sucessful. 
		/// <para>
		/// </para>
		/// </summary>
		Success = 0,
		/// <summary>
		/// The call was aborted (caller hanged up) 
		/// <para>
		/// </para>
		/// </summary>
		Aborted = 1,
		/// <summary>
		/// The call was missed (incoming call timed out without being answered or hanged
		/// up) 
		/// <para>
		/// </para>
		/// </summary>
		Missed = 2,
		/// <summary>
		/// The call was declined, either locally or by remote end. 
		/// <para>
		/// </para>
		/// </summary>
		Declined = 3,
		/// <summary>
		/// The call was aborted before being advertised to the application - for protocol
		/// reasons. 
		/// <para>
		/// </para>
		/// </summary>
		EarlyAborted = 4,
		/// <summary>
		/// The call was answered on another device. 
		/// <para>
		/// </para>
		/// </summary>
		AcceptedElsewhere = 5,
		/// <summary>
		/// The call was declined on another device. 
		/// <para>
		/// </para>
		/// </summary>
		DeclinedElsewhere = 6,
	}

	/// <summary>
	/// LinphoneChatMessageDirection is used to indicate if a message is outgoing or
	/// incoming. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ChatMessageDirection
	{
		/// <summary>
		/// Incoming message. 
		/// <para>
		/// </para>
		/// </summary>
		Incoming = 0,
		/// <summary>
		/// Outgoing message. 
		/// <para>
		/// </para>
		/// </summary>
		Outgoing = 1,
	}

	/// <summary>
	/// LinphoneChatMessageState is used to notify if messages have been successfully
	/// delivered or not. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ChatMessageState
	{
		/// <summary>
		/// Initial state. 
		/// <para>
		/// </para>
		/// </summary>
		Idle = 0,
		/// <summary>
		/// Delivery in progress. 
		/// <para>
		/// </para>
		/// </summary>
		InProgress = 1,
		/// <summary>
		/// Message successfully delivered and acknowledged by the server. 
		/// <para>
		/// </para>
		/// </summary>
		Delivered = 2,
		/// <summary>
		/// Message was not delivered. 
		/// <para>
		/// </para>
		/// </summary>
		NotDelivered = 3,
		/// <summary>
		/// Message was received and acknowledged but cannot get file from server. 
		/// <para>
		/// </para>
		/// </summary>
		FileTransferError = 4,
		/// <summary>
		/// File transfer has been completed successfully. 
		/// <para>
		/// </para>
		/// </summary>
		FileTransferDone = 5,
		/// <summary>
		/// Message successfully delivered an acknowledged by the remote user. 
		/// <para>
		/// </para>
		/// </summary>
		DeliveredToUser = 6,
		/// <summary>
		/// Message successfully displayed to the remote user. 
		/// <para>
		/// </para>
		/// </summary>
		Displayed = 7,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		FileTransferInProgress = 8,
	}

	/// <summary>
	/// LinphoneChatRoomBackend is used to indicate the backend implementation of a
	/// chat room. 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum ChatRoomBackend
	{
		/// <summary>
		/// Basic (client-to-client) chat room. 
		/// <para>
		/// </para>
		/// </summary>
		Basic = 1<<0,
		/// <summary>
		/// Server-based chat room. 
		/// <para>
		/// </para>
		/// </summary>
		FlexisipChat = 1<<1,
	}

	/// <summary>
	/// LinphoneChatRoomCapabilities is used to indicate the capabilities of a chat
	/// room. 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum ChatRoomCapabilities
	{
		/// <summary>
		/// No capabilities. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// No server. 
		/// <para>
		/// It's a direct communication 
		/// </para>
		/// </summary>
		Basic = 1<<0,
		/// <summary>
		/// Supports RTT. 
		/// <para>
		/// </para>
		/// </summary>
		RealTimeText = 1<<1,
		/// <summary>
		/// Use server (supports group chat) 
		/// <para>
		/// </para>
		/// </summary>
		Conference = 1<<2,
		/// <summary>
		/// Special proxy chat room flag. 
		/// <para>
		/// </para>
		/// </summary>
		Proxy = 1<<3,
		/// <summary>
		/// Chat room migratable from Basic to Conference. 
		/// <para>
		/// </para>
		/// </summary>
		Migratable = 1<<4,
		/// <summary>
		/// A communication between two participants (can be Basic or Conference) 
		/// <para>
		/// </para>
		/// </summary>
		OneToOne = 1<<5,
		/// <summary>
		/// Chat room is encrypted. 
		/// <para>
		/// </para>
		/// </summary>
		Encrypted = 1<<6,
	}

	/// <summary>
	/// LinphoneChatRoomEncryptionBackend is used to indicate the encryption engine
	/// used by a chat room. 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum ChatRoomEncryptionBackend
	{
		/// <summary>
		/// No encryption. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Lime x3dh encryption. 
		/// <para>
		/// </para>
		/// </summary>
		Lime = 1<<0,
	}

	/// <summary>
	/// TODO move to encryption engine object when available
	/// LinphoneChatRoomSecurityLevel is used to indicate the encryption security level
	/// of a chat room. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ChatRoomSecurityLevel
	{
		/// <summary>
		/// Security failure. 
		/// <para>
		/// </para>
		/// </summary>
		Unsafe = 0,
		/// <summary>
		/// No encryption. 
		/// <para>
		/// </para>
		/// </summary>
		ClearText = 1,
		/// <summary>
		/// Encrypted. 
		/// <para>
		/// </para>
		/// </summary>
		Encrypted = 2,
		/// <summary>
		/// Encrypted and verified. 
		/// <para>
		/// </para>
		/// </summary>
		Safe = 3,
	}

	/// <summary>
	/// LinphoneChatRoomState is used to indicate the current state of a chat room. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ChatRoomState
	{
		/// <summary>
		/// Initial state. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Chat room is now instantiated on local. 
		/// <para>
		/// </para>
		/// </summary>
		Instantiated = 1,
		/// <summary>
		/// One creation request was sent to the server. 
		/// <para>
		/// </para>
		/// </summary>
		CreationPending = 2,
		/// <summary>
		/// Chat room was created on the server. 
		/// <para>
		/// </para>
		/// </summary>
		Created = 3,
		/// <summary>
		/// Chat room creation failed. 
		/// <para>
		/// </para>
		/// </summary>
		CreationFailed = 4,
		/// <summary>
		/// Wait for chat room termination. 
		/// <para>
		/// </para>
		/// </summary>
		TerminationPending = 5,
		/// <summary>
		/// Chat room exists on server but not in local. 
		/// <para>
		/// </para>
		/// </summary>
		Terminated = 6,
		/// <summary>
		/// The chat room termination failed. 
		/// <para>
		/// </para>
		/// </summary>
		TerminationFailed = 7,
		/// <summary>
		/// Chat room was deleted on the server. 
		/// <para>
		/// </para>
		/// </summary>
		Deleted = 8,
	}

	/// <summary>
	/// LinphoneConferenceState is used to indicate the current state of a conference. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ConferenceState
	{
		/// <summary>
		/// Initial state. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Conference is now instantiated on local. 
		/// <para>
		/// </para>
		/// </summary>
		Instantiated = 1,
		/// <summary>
		/// One creation request was sent to the server. 
		/// <para>
		/// </para>
		/// </summary>
		CreationPending = 2,
		/// <summary>
		/// Conference was created on the server. 
		/// <para>
		/// </para>
		/// </summary>
		Created = 3,
		/// <summary>
		/// Conference creation failed. 
		/// <para>
		/// </para>
		/// </summary>
		CreationFailed = 4,
		/// <summary>
		/// Wait for conference termination. 
		/// <para>
		/// </para>
		/// </summary>
		TerminationPending = 5,
		/// <summary>
		/// Conference exists on server but not in local. 
		/// <para>
		/// </para>
		/// </summary>
		Terminated = 6,
		/// <summary>
		/// Conference termination failed. 
		/// <para>
		/// </para>
		/// </summary>
		TerminationFailed = 7,
		/// <summary>
		/// Conference was deleted on the server. 
		/// <para>
		/// </para>
		/// </summary>
		Deleted = 8,
	}

	/// <summary>
	/// Describes the state of the remote configuring process of the <see
	/// cref="Linphone.Core" /> object, 'Skipped' when the feature is disabled. 
	/// <para>
	/// It is notified via the configuring_status() callback in LinphoneCoreCbs. 
	/// </para>
	/// </summary>
	
	public enum ConfiguringState
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Successful = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Failed = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Skipped = 2,
	}

	/// <summary>
	/// Consolidated presence information: 'online' means the user is open for
	/// communication, 'busy' means the user is open for communication but involved in
	/// an other activity, 'do not disturb' means the user is not open for
	/// communication, and 'offline' means that no presence information is available. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ConsolidatedPresence
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Online = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Busy = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		DoNotDisturb = 2,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Offline = 3,
	}

	/// <summary>
	/// Used to notify if log collection upload have been succesfully delivered or not. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum CoreLogCollectionUploadState
	{
		/// <summary>
		/// Delivery in progress. 
		/// <para>
		/// </para>
		/// </summary>
		InProgress = 0,
		/// <summary>
		/// Log collection upload successfully delivered and acknowledged by remote end
		/// point. 
		/// <para>
		/// </para>
		/// </summary>
		Delivered = 1,
		/// <summary>
		/// Log collection upload was not delivered. 
		/// <para>
		/// </para>
		/// </summary>
		NotDelivered = 2,
	}

	/// <summary>
	/// Enum describing the result of the echo canceller calibration process. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum EcCalibratorStatus
	{
		/// <summary>
		/// The echo canceller calibration process is on going. 
		/// <para>
		/// </para>
		/// </summary>
		InProgress = 0,
		/// <summary>
		/// The echo canceller calibration has been performed and produced an echo delay
		/// measure. 
		/// <para>
		/// </para>
		/// </summary>
		Done = 1,
		/// <summary>
		/// The echo canceller calibration process has failed. 
		/// <para>
		/// </para>
		/// </summary>
		Failed = 2,
		/// <summary>
		/// The echo canceller calibration has been performed and no echo has been
		/// detected. 
		/// <para>
		/// </para>
		/// </summary>
		DoneNoEcho = 3,
	}

	/// <summary>
	/// LinphoneEventLogType is used to indicate the type of an event. 
	/// <para>
	/// Useful for cast. 
	/// </para>
	/// </summary>
	
	public enum EventLogType
	{
		/// <summary>
		/// No defined event. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Conference (created) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceCreated = 1,
		/// <summary>
		/// Conference (terminated) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceTerminated = 2,
		/// <summary>
		/// Conference call (start) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceCallStart = 3,
		/// <summary>
		/// Conference call (end) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceCallEnd = 4,
		/// <summary>
		/// Conference chat message event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceChatMessage = 5,
		/// <summary>
		/// Conference participant (added) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantAdded = 6,
		/// <summary>
		/// Conference participant (removed) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantRemoved = 7,
		/// <summary>
		/// Conference participant (set admin) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantSetAdmin = 8,
		/// <summary>
		/// Conference participant (unset admin) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantUnsetAdmin = 9,
		/// <summary>
		/// Conference participant device (added) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantDeviceAdded = 10,
		/// <summary>
		/// Conference participant device (removed) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantDeviceRemoved = 11,
		/// <summary>
		/// Conference subject event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceSubjectChanged = 12,
		/// <summary>
		/// Conference encryption security event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceSecurityEvent = 13,
		/// <summary>
		/// Conference ephemeral message (ephemeral message lifetime changed) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceEphemeralMessageLifetimeChanged = 14,
		/// <summary>
		/// Conference ephemeral message (ephemeral message enabled) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceEphemeralMessageEnabled = 15,
		/// <summary>
		/// Conference ephemeral message (ephemeral message disabled) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceEphemeralMessageDisabled = 16,
	}

	/// <summary>
	/// Enum describing the capabilities of a <see cref="Linphone.Friend" />, populated
	/// through presence subscribe/notify process. 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum FriendCapability
	{
		/// <summary>
		/// No capabilities populated. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// This friend can be invited in a Flexisip backend <see cref="Linphone.ChatRoom"
		/// />. 
		/// <para>
		/// </para>
		/// </summary>
		GroupChat = 1<<0,
		/// <summary>
		/// This friend can be invited in a Flexisip backend end-to-end encrypted <see
		/// cref="Linphone.ChatRoom" />. 
		/// <para>
		/// </para>
		/// </summary>
		LimeX3Dh = 1<<1,
		/// <summary>
		/// This friend is able to delete ephemeral messages once they have expired. 
		/// <para>
		/// </para>
		/// </summary>
		EphemeralMessages = 1<<2,
	}

	/// <summary>
	/// Enum describing the status of a LinphoneFriendList operation. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum FriendListStatus
	{
		/// <summary>
		/// Operation went fine. 
		/// <para>
		/// </para>
		/// </summary>
		OK = 0,
		/// <summary>
		/// <see cref="Linphone.Friend" /> wasn't found in the <see
		/// cref="Linphone.FriendList" /> 
		/// <para>
		/// </para>
		/// </summary>
		NonExistentFriend = 1,
		/// <summary>
		/// <see cref="Linphone.Friend" /> is already present in a <see
		/// cref="Linphone.FriendList" /> 
		/// <para>
		/// </para>
		/// </summary>
		InvalidFriend = 2,
	}

	/// <summary>
	/// Enum describing the status of a CardDAV synchronization. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum FriendListSyncStatus
	{
		/// <summary>
		/// Synchronization started. 
		/// <para>
		/// </para>
		/// </summary>
		Started = 0,
		/// <summary>
		/// Synchronization finished successfuly. 
		/// <para>
		/// </para>
		/// </summary>
		Successful = 1,
		/// <summary>
		/// Synchronization failed. 
		/// <para>
		/// </para>
		/// </summary>
		Failure = 2,
	}

	/// <summary>
	/// Describes the global state of the <see cref="Linphone.Core" /> object. 
	/// <para>
	/// It is notified via the global_state_changed() callback in LinphoneCoreCbs. 
	/// </para>
	/// </summary>
	
	public enum GlobalState
	{
		/// <summary>
		/// State in which we're in after <see cref="Linphone.Core.Stop()" />. 
		/// <para>
		/// Do not call any method while in this state except for <see
		/// cref="Linphone.Core.Start()" /> 
		/// </para>
		/// </summary>
		Off = 0,
		/// <summary>
		/// Transient state for when we call <see cref="Linphone.Core.Start()" /> 
		/// <para>
		/// </para>
		/// </summary>
		Startup = 1,
		/// <summary>
		/// Indicates <see cref="Linphone.Core" /> has been started and is up and running. 
		/// <para>
		/// </para>
		/// </summary>
		On = 2,
		/// <summary>
		/// Transient state for when we call <see cref="Linphone.Core.Stop()" /> 
		/// <para>
		/// </para>
		/// </summary>
		Shutdown = 3,
		/// <summary>
		/// Transient state between Startup and On if there is a remote provisionning URI
		/// configured. 
		/// <para>
		/// </para>
		/// </summary>
		Configuring = 4,
		/// <summary>
		/// <see cref="Linphone.Core" /> state after being created by
		/// linphone_factory_create_core, generally followed by a call to <see
		/// cref="Linphone.Core.Start()" /> 
		/// <para>
		/// </para>
		/// </summary>
		Ready = 5,
	}

	/// <summary>
	/// Enum describing ICE states. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum IceState
	{
		/// <summary>
		/// ICE has not been activated for this call or stream. 
		/// <para>
		/// </para>
		/// </summary>
		NotActivated = 0,
		/// <summary>
		/// ICE processing has failed. 
		/// <para>
		/// </para>
		/// </summary>
		Failed = 1,
		/// <summary>
		/// ICE process is in progress. 
		/// <para>
		/// </para>
		/// </summary>
		InProgress = 2,
		/// <summary>
		/// ICE has established a direct connection to the remote host. 
		/// <para>
		/// </para>
		/// </summary>
		HostConnection = 3,
		/// <summary>
		/// ICE has established a connection to the remote host through one or several
		/// NATs. 
		/// <para>
		/// </para>
		/// </summary>
		ReflexiveConnection = 4,
		/// <summary>
		/// ICE has established a connection through a relay. 
		/// <para>
		/// </para>
		/// </summary>
		RelayConnection = 5,
	}

	/// <summary>
	/// <para>
	/// </para>
	/// </summary>
	
	public enum LimeState
	{
		/// <summary>
		/// Lime is not used at all. 
		/// <para>
		/// </para>
		/// </summary>
		Disabled = 0,
		/// <summary>
		/// Lime is always used. 
		/// <para>
		/// </para>
		/// </summary>
		Mandatory = 1,
		/// <summary>
		/// Lime is used only if we already shared a secret with remote. 
		/// <para>
		/// </para>
		/// </summary>
		Preferred = 2,
	}

	/// <summary>
	/// Whether or not to keep a file with the logs. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum LogCollectionState
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Disabled = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Enabled = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		EnabledWithoutPreviousLogHandler = 2,
	}

	/// <summary>
	/// Verbosity levels of log messages. 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum LogLevel
	{
		/// <summary>
		/// Level for debug messages. 
		/// <para>
		/// </para>
		/// </summary>
		Debug = 1,
		/// <summary>
		/// Level for traces. 
		/// <para>
		/// </para>
		/// </summary>
		Trace = 1<<1,
		/// <summary>
		/// Level for information messages. 
		/// <para>
		/// </para>
		/// </summary>
		Message = 1<<2,
		/// <summary>
		/// Level for warning messages. 
		/// <para>
		/// </para>
		/// </summary>
		Warning = 1<<3,
		/// <summary>
		/// Level for error messages. 
		/// <para>
		/// </para>
		/// </summary>
		Error = 1<<4,
		/// <summary>
		/// Level for fatal error messages. 
		/// <para>
		/// </para>
		/// </summary>
		Fatal = 1<<5,
	}

	/// <summary>
	/// Indicates for a given media the stream direction. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum MediaDirection
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Invalid = -1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Inactive = 0,
		/// <summary>
		/// No active media not supported yet. 
		/// <para>
		/// </para>
		/// </summary>
		SendOnly = 1,
		/// <summary>
		/// Send only mode. 
		/// <para>
		/// </para>
		/// </summary>
		RecvOnly = 2,
		/// <summary>
		/// recv only mode 
		/// <para>
		/// </para>
		/// </summary>
		SendRecv = 3,
	}

	/// <summary>
	/// Enum describing type of media encryption types. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum MediaEncryption
	{
		/// <summary>
		/// No media encryption is used. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Use SRTP media encryption. 
		/// <para>
		/// </para>
		/// </summary>
		SRTP = 1,
		/// <summary>
		/// Use ZRTP media encryption. 
		/// <para>
		/// </para>
		/// </summary>
		ZRTP = 2,
		/// <summary>
		/// Use DTLS media encryption. 
		/// <para>
		/// </para>
		/// </summary>
		DTLS = 3,
	}

	/// <summary>
	/// Media resource usage. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum MediaResourceMode
	{
		/// <summary>
		/// Media resources are not shared. 
		/// <para>
		/// </para>
		/// </summary>
		ExclusiveMediaResources = 0,
		/// <summary>
		/// Media resources are shared. 
		/// <para>
		/// </para>
		/// </summary>
		SharedMediaResources = 1,
	}

	/// <summary>
	/// The state of a <see cref="Linphone.Player" />. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum PlayerState
	{
		/// <summary>
		/// No file is opened for playing. 
		/// <para>
		/// </para>
		/// </summary>
		Closed = 0,
		/// <summary>
		/// The player is paused. 
		/// <para>
		/// </para>
		/// </summary>
		Paused = 1,
		/// <summary>
		/// The player is playing. 
		/// <para>
		/// </para>
		/// </summary>
		Playing = 2,
	}

	/// <summary>
	/// Activities as defined in section 3.2 of RFC 4480. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum PresenceActivityType
	{
		/// <summary>
		/// The person has a calendar appointment, without specifying exactly of what type. 
		/// <para>
		/// This activity is indicated if more detailed information is not available or the
		/// person chooses not to reveal more information. 
		/// </para>
		/// </summary>
		Appointment = 0,
		/// <summary>
		/// The person is physically away from all interactive communication devices. 
		/// <para>
		/// </para>
		/// </summary>
		Away = 1,
		/// <summary>
		/// The person is eating the first meal of the day, usually eaten in the morning. 
		/// <para>
		/// </para>
		/// </summary>
		Breakfast = 2,
		/// <summary>
		/// The person is busy, without further details. 
		/// <para>
		/// </para>
		/// </summary>
		Busy = 3,
		/// <summary>
		/// The person is having his or her main meal of the day, eaten in the evening or
		/// at midday. 
		/// <para>
		/// </para>
		/// </summary>
		Dinner = 4,
		/// <summary>
		/// This is a scheduled national or local holiday. 
		/// <para>
		/// </para>
		/// </summary>
		Holiday = 5,
		/// <summary>
		/// The person is riding in a vehicle, such as a car, but not steering. 
		/// <para>
		/// </para>
		/// </summary>
		InTransit = 6,
		/// <summary>
		/// The person is looking for (paid) work. 
		/// <para>
		/// </para>
		/// </summary>
		LookingForWork = 7,
		/// <summary>
		/// The person is eating his or her midday meal. 
		/// <para>
		/// </para>
		/// </summary>
		Lunch = 8,
		/// <summary>
		/// The person is scheduled for a meal, without specifying whether it is breakfast,
		/// lunch, or dinner, or some other meal. 
		/// <para>
		/// </para>
		/// </summary>
		Meal = 9,
		/// <summary>
		/// The person is in an assembly or gathering of people, as for a business, social,
		/// or religious purpose. 
		/// <para>
		/// A meeting is a sub-class of an appointment. 
		/// </para>
		/// </summary>
		Meeting = 10,
		/// <summary>
		/// The person is talking on the telephone. 
		/// <para>
		/// </para>
		/// </summary>
		OnThePhone = 11,
		/// <summary>
		/// The person is engaged in an activity with no defined representation. 
		/// <para>
		/// A string describing the activity in plain text SHOULD be provided. 
		/// </para>
		/// </summary>
		Other = 12,
		/// <summary>
		/// A performance is a sub-class of an appointment and includes musical,
		/// theatrical, and cinematic performances as well as lectures. 
		/// <para>
		/// It is distinguished from a meeting by the fact that the person may either be
		/// lecturing or be in the audience, with a potentially large number of other
		/// people, making interruptions particularly noticeable. 
		/// </para>
		/// </summary>
		Performance = 13,
		/// <summary>
		/// The person will not return for the foreseeable future, e.g., because it is no
		/// longer working for the company. 
		/// <para>
		/// </para>
		/// </summary>
		PermanentAbsence = 14,
		/// <summary>
		/// The person is occupying himself or herself in amusement, sport, or other
		/// recreation. 
		/// <para>
		/// </para>
		/// </summary>
		Playing = 15,
		/// <summary>
		/// The person is giving a presentation, lecture, or participating in a formal
		/// round-table discussion. 
		/// <para>
		/// </para>
		/// </summary>
		Presentation = 16,
		/// <summary>
		/// The person is visiting stores in search of goods or services. 
		/// <para>
		/// </para>
		/// </summary>
		Shopping = 17,
		/// <summary>
		/// The person is sleeping. 
		/// <para>
		/// </para>
		/// </summary>
		Sleeping = 18,
		/// <summary>
		/// The person is observing an event, such as a sports event. 
		/// <para>
		/// </para>
		/// </summary>
		Spectator = 19,
		/// <summary>
		/// The person is controlling a vehicle, watercraft, or plane. 
		/// <para>
		/// </para>
		/// </summary>
		Steering = 20,
		/// <summary>
		/// The person is on a business or personal trip, but not necessarily in-transit. 
		/// <para>
		/// </para>
		/// </summary>
		Travel = 21,
		/// <summary>
		/// The person is watching television. 
		/// <para>
		/// </para>
		/// </summary>
		TV = 22,
		/// <summary>
		/// The activity of the person is unknown. 
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 23,
		/// <summary>
		/// A period of time devoted to pleasure, rest, or relaxation. 
		/// <para>
		/// </para>
		/// </summary>
		Vacation = 24,
		/// <summary>
		/// The person is engaged in, typically paid, labor, as part of a profession or
		/// job. 
		/// <para>
		/// </para>
		/// </summary>
		Working = 25,
		/// <summary>
		/// The person is participating in religious rites. 
		/// <para>
		/// </para>
		/// </summary>
		Worship = 26,
	}

	/// <summary>
	/// Basic status as defined in section 4.1.4 of RFC 3863. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum PresenceBasicStatus
	{
		/// <summary>
		/// This value means that the associated contact element, if any, is ready to
		/// accept communication. 
		/// <para>
		/// </para>
		/// </summary>
		Open = 0,
		/// <summary>
		/// This value means that the associated contact element, if any, is unable to
		/// accept communication. 
		/// <para>
		/// </para>
		/// </summary>
		Closed = 1,
	}

	/// <summary>
	/// Defines privacy policy to apply as described by rfc3323. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum Privacy
	{
		/// <summary>
		/// Privacy services must not perform any privacy function. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Request that privacy services provide a user-level privacy function. 
		/// <para>
		/// With this mode, "from" header is hidden, usually replaced by From: "Anonymous"
		/// <sip:anonymous@anonymous.invalid> 
		/// </para>
		/// </summary>
		User = 1,
		/// <summary>
		/// Request that privacy services modify headers that cannot be set arbitrarily by
		/// the user (Contact/Via). 
		/// <para>
		/// </para>
		/// </summary>
		Header = 2,
		/// <summary>
		/// Request that privacy services provide privacy for session media. 
		/// <para>
		/// </para>
		/// </summary>
		Session = 4,
		/// <summary>
		/// rfc3325 The presence of this privacy type in a Privacy header field indicates
		/// that the user would like the Network Asserted Identity to be kept private with
		/// respect to SIP entities outside the Trust Domain with which the user
		/// authenticated. 
		/// <para>
		/// Note that a user requesting multiple types of privacy MUST include all of the
		/// requested privacy types in its Privacy header field value 
		/// </para>
		/// </summary>
		Id = 8,
		/// <summary>
		/// Privacy service must perform the specified services or fail the request. 
		/// <para>
		/// </para>
		/// </summary>
		Critical = 16,
		/// <summary>
		/// Special keyword to use privacy as defined either globally or by proxy using
		/// <see cref="Linphone.ProxyConfig.SetPrivacy()" /> 
		/// <para>
		/// </para>
		/// </summary>
		Default = 32768,
	}

	/// <summary>
	/// Enum for publish states. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum PublishState
	{
		/// <summary>
		/// Initial state, do not use. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// An outgoing publish was created and submitted. 
		/// <para>
		/// </para>
		/// </summary>
		Progress = 1,
		/// <summary>
		/// Publish is accepted. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 2,
		/// <summary>
		/// Publish encoutered an error, <see cref="Linphone.Event.GetReason()" /> gives
		/// reason code. 
		/// <para>
		/// </para>
		/// </summary>
		Error = 3,
		/// <summary>
		/// Publish is about to expire, only sent if [sip]->refresh_generic_publish
		/// property is set to 0. 
		/// <para>
		/// </para>
		/// </summary>
		Expiring = 4,
		/// <summary>
		/// Event has been un published. 
		/// <para>
		/// </para>
		/// </summary>
		Cleared = 5,
	}

	/// <summary>
	/// Enum describing various failure reasons or contextual information for some
	/// events. 
	/// <para>
	/// </para>
	/// </summary>
	/// <remarks>See : <see cref="Linphone.Call.GetReason()" /> </remarks>
	/// 
	/// <remarks>See : <see cref="Linphone.ProxyConfig.GetError()" /> </remarks>
	/// 
	/// <remarks>See : <see cref="Linphone.ErrorInfo.GetReason()" /> </remarks>
	
	public enum Reason
	{
		/// <summary>
		/// No reason has been set by the core. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// No response received from remote. 
		/// <para>
		/// </para>
		/// </summary>
		NoResponse = 1,
		/// <summary>
		/// Authentication failed due to bad credentials or resource forbidden. 
		/// <para>
		/// </para>
		/// </summary>
		Forbidden = 2,
		/// <summary>
		/// The call has been declined. 
		/// <para>
		/// </para>
		/// </summary>
		Declined = 3,
		/// <summary>
		/// Destination of the call was not found. 
		/// <para>
		/// </para>
		/// </summary>
		NotFound = 4,
		/// <summary>
		/// The call was not answered in time (request timeout) 
		/// <para>
		/// </para>
		/// </summary>
		NotAnswered = 5,
		/// <summary>
		/// Phone line was busy. 
		/// <para>
		/// </para>
		/// </summary>
		Busy = 6,
		/// <summary>
		/// Unsupported content. 
		/// <para>
		/// </para>
		/// </summary>
		UnsupportedContent = 7,
		/// <summary>
		/// Bad event. 
		/// <para>
		/// </para>
		/// </summary>
		BadEvent = 8,
		/// <summary>
		/// Transport error: connection failures, disconnections etc... 
		/// <para>
		/// </para>
		/// </summary>
		IOError = 9,
		/// <summary>
		/// Do not disturb reason. 
		/// <para>
		/// </para>
		/// </summary>
		DoNotDisturb = 10,
		/// <summary>
		/// Operation is unauthorized because missing credential. 
		/// <para>
		/// </para>
		/// </summary>
		Unauthorized = 11,
		/// <summary>
		/// Operation is rejected due to incompatible or unsupported media parameters. 
		/// <para>
		/// </para>
		/// </summary>
		NotAcceptable = 12,
		/// <summary>
		/// Operation could not be executed by server or remote client because it didn't
		/// have any context for it. 
		/// <para>
		/// </para>
		/// </summary>
		NoMatch = 13,
		/// <summary>
		/// Resource moved permanently. 
		/// <para>
		/// </para>
		/// </summary>
		MovedPermanently = 14,
		/// <summary>
		/// Resource no longer exists. 
		/// <para>
		/// </para>
		/// </summary>
		Gone = 15,
		/// <summary>
		/// Temporarily unavailable. 
		/// <para>
		/// </para>
		/// </summary>
		TemporarilyUnavailable = 16,
		/// <summary>
		/// Address incomplete. 
		/// <para>
		/// </para>
		/// </summary>
		AddressIncomplete = 17,
		/// <summary>
		/// Not implemented. 
		/// <para>
		/// </para>
		/// </summary>
		NotImplemented = 18,
		/// <summary>
		/// Bad gateway. 
		/// <para>
		/// </para>
		/// </summary>
		BadGateway = 19,
		/// <summary>
		/// The received request contains a Session-Expires header field with a duration
		/// below the minimum timer. 
		/// <para>
		/// </para>
		/// </summary>
		SessionIntervalTooSmall = 20,
		/// <summary>
		/// Server timeout. 
		/// <para>
		/// </para>
		/// </summary>
		ServerTimeout = 21,
		/// <summary>
		/// Unknown reason. 
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 22,
	}

	/// <summary>
	/// Describes proxy registration states. 
	/// <para>
	/// It is notified via the registration_state_changed() callback in
	/// LinphoneCoreCbs. 
	/// </para>
	/// </summary>
	
	public enum RegistrationState
	{
		/// <summary>
		/// Initial state for registrations. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Registration is in progress. 
		/// <para>
		/// </para>
		/// </summary>
		Progress = 1,
		/// <summary>
		/// Registration is successful. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 2,
		/// <summary>
		/// Unregistration succeeded. 
		/// <para>
		/// </para>
		/// </summary>
		Cleared = 3,
		/// <summary>
		/// Registration failed. 
		/// <para>
		/// </para>
		/// </summary>
		Failed = 4,
	}

	/// <summary>
	/// LinphoneSecurityEventType is used to indicate the type of security event. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum SecurityEventType
	{
		/// <summary>
		/// Event is not a security event. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Chatroom security level downgraded event. 
		/// <para>
		/// </para>
		/// </summary>
		SecurityLevelDowngraded = 1,
		/// <summary>
		/// Participant has exceeded the maximum number of device event. 
		/// <para>
		/// </para>
		/// </summary>
		ParticipantMaxDeviceCountExceeded = 2,
		/// <summary>
		/// Peer device instant messaging encryption identity key has changed event. 
		/// <para>
		/// </para>
		/// </summary>
		EncryptionIdentityKeyChanged = 3,
		/// <summary>
		/// Man in the middle detected event. 
		/// <para>
		/// </para>
		/// </summary>
		ManInTheMiddleDetected = 4,
	}

	/// <summary>
	/// Session Timers refresher. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum SessionExpiresRefresher
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Unspecified = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		UAS = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		UAC = 2,
	}

	/// <summary>
	/// Enum describing the stream types. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum StreamType
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Audio = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Video = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Text = 2,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 3,
	}

	/// <summary>
	/// Enum controlling behavior for incoming subscription request. 
	/// <para>
	/// Use by <see cref="Linphone.Friend.SetIncSubscribePolicy()" /> 
	/// </para>
	/// </summary>
	
	public enum SubscribePolicy
	{
		/// <summary>
		/// Does not automatically accept an incoming subscription request. 
		/// <para>
		/// This policy implies that a decision has to be taken for each incoming
		/// subscription request notified by callback
		/// LinphoneCoreVTable.new_subscription_requested 
		/// </para>
		/// </summary>
		SPWait = 0,
		/// <summary>
		/// Rejects incoming subscription request. 
		/// <para>
		/// </para>
		/// </summary>
		SPDeny = 1,
		/// <summary>
		/// Automatically accepts a subscription request. 
		/// <para>
		/// </para>
		/// </summary>
		SPAccept = 2,
	}

	/// <summary>
	/// Enum for subscription direction (incoming or outgoing). 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum SubscriptionDir
	{
		/// <summary>
		/// Incoming subscription. 
		/// <para>
		/// </para>
		/// </summary>
		Incoming = 0,
		/// <summary>
		/// Outgoing subscription. 
		/// <para>
		/// </para>
		/// </summary>
		Outgoing = 1,
		/// <summary>
		/// Invalid subscription direction. 
		/// <para>
		/// </para>
		/// </summary>
		InvalidDir = 2,
	}

	/// <summary>
	/// Enum for subscription states. 
	/// <para>
	/// LinphoneSubscriptionTerminated and LinphoneSubscriptionError are final states. 
	/// </para>
	/// </summary>
	
	public enum SubscriptionState
	{
		/// <summary>
		/// Initial state, should not be used. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// An outgoing subcription was sent. 
		/// <para>
		/// </para>
		/// </summary>
		OutgoingProgress = 1,
		/// <summary>
		/// An incoming subcription is received. 
		/// <para>
		/// </para>
		/// </summary>
		IncomingReceived = 2,
		/// <summary>
		/// Subscription is pending, waiting for user approval. 
		/// <para>
		/// </para>
		/// </summary>
		Pending = 3,
		/// <summary>
		/// Subscription is accepted. 
		/// <para>
		/// </para>
		/// </summary>
		Active = 4,
		/// <summary>
		/// Subscription is terminated normally. 
		/// <para>
		/// </para>
		/// </summary>
		Terminated = 5,
		/// <summary>
		/// Subscription was terminated by an error, indicated by <see
		/// cref="Linphone.Event.GetReason()" /> 
		/// <para>
		/// </para>
		/// </summary>
		Error = 6,
		/// <summary>
		/// Subscription is about to expire, only sent if [sip]->refresh_generic_subscribe
		/// property is set to 0. 
		/// <para>
		/// </para>
		/// </summary>
		Expiring = 7,
	}

	/// <summary>
	/// Enum listing frequent telephony tones. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ToneID
	{
		/// <summary>
		/// Not a tone. 
		/// <para>
		/// </para>
		/// </summary>
		Undefined = 0,
		/// <summary>
		/// Busy tone. 
		/// <para>
		/// </para>
		/// </summary>
		Busy = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		CallWaiting = 2,
		/// <summary>
		/// Call waiting tone. 
		/// <para>
		/// </para>
		/// </summary>
		CallOnHold = 3,
		/// <summary>
		/// Call on hold tone. 
		/// <para>
		/// Tone played when call is abruptly disconnected (media lost) 
		/// </para>
		/// </summary>
		CallLost = 4,
	}

	/// <summary>
	/// Enum describing transport type for LinphoneAddress. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum TransportType
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Udp = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Tcp = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Tls = 2,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Dtls = 3,
	}

	/// <summary>
	/// Enum describing the tunnel modes. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum TunnelMode
	{
		/// <summary>
		/// The tunnel is disabled. 
		/// <para>
		/// </para>
		/// </summary>
		Disable = 0,
		/// <summary>
		/// The tunnel is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		Enable = 1,
		/// <summary>
		/// The tunnel is enabled automatically if it is required. 
		/// <para>
		/// </para>
		/// </summary>
		Auto = 2,
	}

	/// <summary>
	/// Enum describing uPnP states. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum UpnpState
	{
		/// <summary>
		/// uPnP is not activate 
		/// <para>
		/// </para>
		/// </summary>
		Idle = 0,
		/// <summary>
		/// uPnP process is in progress 
		/// <para>
		/// </para>
		/// </summary>
		Pending = 1,
		/// <summary>
		/// Internal use: Only used by port binding. 
		/// <para>
		/// </para>
		/// </summary>
		Adding = 2,
		/// <summary>
		/// Internal use: Only used by port binding. 
		/// <para>
		/// </para>
		/// </summary>
		Removing = 3,
		/// <summary>
		/// uPnP is not available 
		/// <para>
		/// </para>
		/// </summary>
		NotAvailable = 4,
		/// <summary>
		/// uPnP is enabled 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 5,
		/// <summary>
		/// uPnP processing has failed 
		/// <para>
		/// </para>
		/// </summary>
		Ko = 6,
		/// <summary>
		/// IGD router is blacklisted. 
		/// <para>
		/// </para>
		/// </summary>
		Blacklisted = 7,
	}

	/// <summary>
	/// Enum describing the result of a version update check. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum VersionUpdateCheckResult
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		UpToDate = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		NewVersionAvailable = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Error = 2,
	}

	/// <summary>
	/// Enum describing the types of argument for LinphoneXmlRpcRequest. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum XmlRpcArgType
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Int = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		String = 2,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		StringStruct = 3,
	}

	/// <summary>
	/// Enum describing the status of a LinphoneXmlRpcRequest. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum XmlRpcStatus
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Pending = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Ok = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Failed = 2,
	}

	/// <summary>
	/// Enum describing the ZRTP SAS validation status of a peer URI. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ZrtpPeerStatus
	{
		/// <summary>
		/// Peer URI unkown or never validated/invalidated the SAS. 
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 0,
		/// <summary>
		/// Peer URI SAS rejected in database. 
		/// <para>
		/// </para>
		/// </summary>
		Invalid = 1,
		/// <summary>
		/// Peer URI SAS validated in database. 
		/// <para>
		/// </para>
		/// </summary>
		Valid = 2,
	}

#endregion

#region Listeners
	/// <summary>
	/// An object to handle the responses callbacks for handling the
	/// LinphoneAccountCreator operations. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class AccountCreatorListener : LinphoneObject
	{
        ~AccountCreatorListener()
        {
            unregister();
        }

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern void linphone_account_creator_cbs_set_user_data(IntPtr thiz, IntPtr listener);

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr linphone_account_creator_cbs_get_user_data(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_account_creator_cbs_set_activate_account(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_activate_account(IntPtr thiz, OnActivateAccountDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnActivateAccountDelegatePrivate(IntPtr creator, int status, string response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator">LinphoneAccountCreator object   </param>
		/// <param name="status">The status of the LinphoneAccountCreator test existence
		/// operation that has just finished </param>
		/// <param name="response">The response has a string   </param>
		/// 
		public delegate void OnActivateAccountDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnActivateAccountDelegatePrivate on_activate_account_private;
		private OnActivateAccountDelegate on_activate_account_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnActivateAccountDelegatePrivate))]
#endif
		private static void on_activate_account(IntPtr creator, int status, string response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);
			AccountCreatorListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_activate_account_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, response);
			}
		}

		public OnActivateAccountDelegate OnActivateAccount
		{
			get
			{
				return on_activate_account_public;
			}
			set
			{
				on_activate_account_public = value;
#if WINDOWS_UWP
				on_activate_account_private = on_activate_account;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_activate_account_private);
				linphone_account_creator_cbs_set_activate_account(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_activate_account(nativePtr, on_activate_account);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_account_creator_cbs_set_activate_alias(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_activate_alias(IntPtr thiz, OnActivateAliasDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnActivateAliasDelegatePrivate(IntPtr creator, int status, string response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator">LinphoneAccountCreator object   </param>
		/// <param name="status">The status of the LinphoneAccountCreator test existence
		/// operation that has just finished </param>
		/// <param name="response">The response has a string   </param>
		/// 
		public delegate void OnActivateAliasDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnActivateAliasDelegatePrivate on_activate_alias_private;
		private OnActivateAliasDelegate on_activate_alias_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnActivateAliasDelegatePrivate))]
#endif
		private static void on_activate_alias(IntPtr creator, int status, string response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);
			AccountCreatorListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_activate_alias_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, response);
			}
		}

		public OnActivateAliasDelegate OnActivateAlias
		{
			get
			{
				return on_activate_alias_public;
			}
			set
			{
				on_activate_alias_public = value;
#if WINDOWS_UWP
				on_activate_alias_private = on_activate_alias;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_activate_alias_private);
				linphone_account_creator_cbs_set_activate_alias(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_activate_alias(nativePtr, on_activate_alias);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_account_creator_cbs_set_is_account_linked(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_is_account_linked(IntPtr thiz, OnIsAccountLinkedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsAccountLinkedDelegatePrivate(IntPtr creator, int status, string response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator">LinphoneAccountCreator object   </param>
		/// <param name="status">The status of the LinphoneAccountCreator test existence
		/// operation that has just finished </param>
		/// <param name="response">The response has a string   </param>
		/// 
		public delegate void OnIsAccountLinkedDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnIsAccountLinkedDelegatePrivate on_is_account_linked_private;
		private OnIsAccountLinkedDelegate on_is_account_linked_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsAccountLinkedDelegatePrivate))]
#endif
		private static void on_is_account_linked(IntPtr creator, int status, string response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);
			AccountCreatorListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_is_account_linked_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, response);
			}
		}

		public OnIsAccountLinkedDelegate OnIsAccountLinked
		{
			get
			{
				return on_is_account_linked_public;
			}
			set
			{
				on_is_account_linked_public = value;
#if WINDOWS_UWP
				on_is_account_linked_private = on_is_account_linked;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_account_linked_private);
				linphone_account_creator_cbs_set_is_account_linked(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_is_account_linked(nativePtr, on_is_account_linked);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_account_creator_cbs_set_link_account(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_link_account(IntPtr thiz, OnLinkAccountDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLinkAccountDelegatePrivate(IntPtr creator, int status, string response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator">LinphoneAccountCreator object   </param>
		/// <param name="status">The status of the LinphoneAccountCreator test existence
		/// operation that has just finished </param>
		/// <param name="response">The response has a string   </param>
		/// 
		public delegate void OnLinkAccountDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnLinkAccountDelegatePrivate on_link_account_private;
		private OnLinkAccountDelegate on_link_account_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLinkAccountDelegatePrivate))]
#endif
		private static void on_link_account(IntPtr creator, int status, string response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);
			AccountCreatorListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_link_account_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, response);
			}
		}

		public OnLinkAccountDelegate OnLinkAccount
		{
			get
			{
				return on_link_account_public;
			}
			set
			{
				on_link_account_public = value;
#if WINDOWS_UWP
				on_link_account_private = on_link_account;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_link_account_private);
				linphone_account_creator_cbs_set_link_account(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_link_account(nativePtr, on_link_account);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_account_creator_cbs_set_is_alias_used(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_is_alias_used(IntPtr thiz, OnIsAliasUsedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsAliasUsedDelegatePrivate(IntPtr creator, int status, string response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator">LinphoneAccountCreator object   </param>
		/// <param name="status">The status of the LinphoneAccountCreator test existence
		/// operation that has just finished </param>
		/// <param name="response">The response has a string   </param>
		/// 
		public delegate void OnIsAliasUsedDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnIsAliasUsedDelegatePrivate on_is_alias_used_private;
		private OnIsAliasUsedDelegate on_is_alias_used_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsAliasUsedDelegatePrivate))]
#endif
		private static void on_is_alias_used(IntPtr creator, int status, string response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);
			AccountCreatorListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_is_alias_used_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, response);
			}
		}

		public OnIsAliasUsedDelegate OnIsAliasUsed
		{
			get
			{
				return on_is_alias_used_public;
			}
			set
			{
				on_is_alias_used_public = value;
#if WINDOWS_UWP
				on_is_alias_used_private = on_is_alias_used;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_alias_used_private);
				linphone_account_creator_cbs_set_is_alias_used(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_is_alias_used(nativePtr, on_is_alias_used);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_account_creator_cbs_set_is_account_activated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_is_account_activated(IntPtr thiz, OnIsAccountActivatedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsAccountActivatedDelegatePrivate(IntPtr creator, int status, string response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator">LinphoneAccountCreator object   </param>
		/// <param name="status">The status of the LinphoneAccountCreator test existence
		/// operation that has just finished </param>
		/// <param name="response">The response has a string   </param>
		/// 
		public delegate void OnIsAccountActivatedDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnIsAccountActivatedDelegatePrivate on_is_account_activated_private;
		private OnIsAccountActivatedDelegate on_is_account_activated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsAccountActivatedDelegatePrivate))]
#endif
		private static void on_is_account_activated(IntPtr creator, int status, string response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);
			AccountCreatorListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_is_account_activated_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, response);
			}
		}

		public OnIsAccountActivatedDelegate OnIsAccountActivated
		{
			get
			{
				return on_is_account_activated_public;
			}
			set
			{
				on_is_account_activated_public = value;
#if WINDOWS_UWP
				on_is_account_activated_private = on_is_account_activated;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_account_activated_private);
				linphone_account_creator_cbs_set_is_account_activated(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_is_account_activated(nativePtr, on_is_account_activated);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_account_creator_cbs_set_login_linphone_account(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_login_linphone_account(IntPtr thiz, OnLoginLinphoneAccountDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLoginLinphoneAccountDelegatePrivate(IntPtr creator, int status, string response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator">LinphoneAccountCreator object   </param>
		/// <param name="status">The status of the LinphoneAccountCreator test existence
		/// operation that has just finished </param>
		/// <param name="response">The response has a string   </param>
		/// 
		public delegate void OnLoginLinphoneAccountDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnLoginLinphoneAccountDelegatePrivate on_login_linphone_account_private;
		private OnLoginLinphoneAccountDelegate on_login_linphone_account_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLoginLinphoneAccountDelegatePrivate))]
#endif
		private static void on_login_linphone_account(IntPtr creator, int status, string response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);
			AccountCreatorListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_login_linphone_account_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, response);
			}
		}

		public OnLoginLinphoneAccountDelegate OnLoginLinphoneAccount
		{
			get
			{
				return on_login_linphone_account_public;
			}
			set
			{
				on_login_linphone_account_public = value;
#if WINDOWS_UWP
				on_login_linphone_account_private = on_login_linphone_account;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_login_linphone_account_private);
				linphone_account_creator_cbs_set_login_linphone_account(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_login_linphone_account(nativePtr, on_login_linphone_account);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_account_creator_cbs_set_is_account_exist(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_is_account_exist(IntPtr thiz, OnIsAccountExistDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsAccountExistDelegatePrivate(IntPtr creator, int status, string response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator">LinphoneAccountCreator object   </param>
		/// <param name="status">The status of the LinphoneAccountCreator test existence
		/// operation that has just finished </param>
		/// <param name="response">The response has a string   </param>
		/// 
		public delegate void OnIsAccountExistDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnIsAccountExistDelegatePrivate on_is_account_exist_private;
		private OnIsAccountExistDelegate on_is_account_exist_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsAccountExistDelegatePrivate))]
#endif
		private static void on_is_account_exist(IntPtr creator, int status, string response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);
			AccountCreatorListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_is_account_exist_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, response);
			}
		}

		public OnIsAccountExistDelegate OnIsAccountExist
		{
			get
			{
				return on_is_account_exist_public;
			}
			set
			{
				on_is_account_exist_public = value;
#if WINDOWS_UWP
				on_is_account_exist_private = on_is_account_exist;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_account_exist_private);
				linphone_account_creator_cbs_set_is_account_exist(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_is_account_exist(nativePtr, on_is_account_exist);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_account_creator_cbs_set_update_account(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_update_account(IntPtr thiz, OnUpdateAccountDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnUpdateAccountDelegatePrivate(IntPtr creator, int status, string response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator">LinphoneAccountCreator object   </param>
		/// <param name="status">The status of the LinphoneAccountCreator test existence
		/// operation that has just finished </param>
		/// <param name="response">The response has a string   </param>
		/// 
		public delegate void OnUpdateAccountDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnUpdateAccountDelegatePrivate on_update_account_private;
		private OnUpdateAccountDelegate on_update_account_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnUpdateAccountDelegatePrivate))]
#endif
		private static void on_update_account(IntPtr creator, int status, string response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);
			AccountCreatorListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_update_account_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, response);
			}
		}

		public OnUpdateAccountDelegate OnUpdateAccount
		{
			get
			{
				return on_update_account_public;
			}
			set
			{
				on_update_account_public = value;
#if WINDOWS_UWP
				on_update_account_private = on_update_account;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_update_account_private);
				linphone_account_creator_cbs_set_update_account(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_update_account(nativePtr, on_update_account);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_account_creator_cbs_set_recover_account(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_recover_account(IntPtr thiz, OnRecoverAccountDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnRecoverAccountDelegatePrivate(IntPtr creator, int status, string response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator">LinphoneAccountCreator object   </param>
		/// <param name="status">The status of the LinphoneAccountCreator test existence
		/// operation that has just finished </param>
		/// <param name="response">The response has a string   </param>
		/// 
		public delegate void OnRecoverAccountDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnRecoverAccountDelegatePrivate on_recover_account_private;
		private OnRecoverAccountDelegate on_recover_account_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnRecoverAccountDelegatePrivate))]
#endif
		private static void on_recover_account(IntPtr creator, int status, string response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);
			AccountCreatorListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_recover_account_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, response);
			}
		}

		public OnRecoverAccountDelegate OnRecoverAccount
		{
			get
			{
				return on_recover_account_public;
			}
			set
			{
				on_recover_account_public = value;
#if WINDOWS_UWP
				on_recover_account_private = on_recover_account;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_recover_account_private);
				linphone_account_creator_cbs_set_recover_account(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_recover_account(nativePtr, on_recover_account);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_account_creator_cbs_set_create_account(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_create_account(IntPtr thiz, OnCreateAccountDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCreateAccountDelegatePrivate(IntPtr creator, int status, string response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator">LinphoneAccountCreator object   </param>
		/// <param name="status">The status of the LinphoneAccountCreator test existence
		/// operation that has just finished </param>
		/// <param name="response">The response has a string   </param>
		/// 
		public delegate void OnCreateAccountDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnCreateAccountDelegatePrivate on_create_account_private;
		private OnCreateAccountDelegate on_create_account_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCreateAccountDelegatePrivate))]
#endif
		private static void on_create_account(IntPtr creator, int status, string response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);
			AccountCreatorListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_create_account_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, response);
			}
		}

		public OnCreateAccountDelegate OnCreateAccount
		{
			get
			{
				return on_create_account_public;
			}
			set
			{
				on_create_account_public = value;
#if WINDOWS_UWP
				on_create_account_private = on_create_account;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_create_account_private);
				linphone_account_creator_cbs_set_create_account(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_create_account(nativePtr, on_create_account);
#endif
			}
		}

		internal void register() {
			IntPtr listener = linphone_account_creator_cbs_get_user_data(nativePtr);
			if (listener == IntPtr.Zero)
			{
				GCHandle _handle = GCHandle.Alloc(this, GCHandleType.Normal);
				listener = GCHandle.ToIntPtr(_handle);
			} else
			{
				GCHandle _handle = GCHandle.FromIntPtr(listener);
				if (_handle.Target == this)
				{
					return;
				} else
				{
					_handle.Free();
					_handle = GCHandle.Alloc(this, GCHandleType.Normal);
					listener = GCHandle.ToIntPtr(_handle);
				}
			}
			linphone_account_creator_cbs_set_user_data(nativePtr, listener);
		}

		internal void unregister() {
			IntPtr listener = linphone_account_creator_cbs_get_user_data(nativePtr);
			linphone_account_creator_cbs_set_user_data(nativePtr, IntPtr.Zero);
			if (listener != IntPtr.Zero)
			{
				GCHandle.FromIntPtr(listener).Free();
			}
		}
	}

	/// <summary>
	/// That class holds all the callbacks which are called by LinphoneCall objects. 
	/// <para>
	/// Use linphone_factory_create_call_cbs to create an instance. Then, call the
	/// callback setters on the events you need to monitor and pass the object to a
	/// LinphoneCall instance through linphone_call_add_callbacks. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class CallListener : LinphoneObject
	{
        ~CallListener()
        {
            unregister();
        }

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern void linphone_call_cbs_set_user_data(IntPtr thiz, IntPtr listener);

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr linphone_call_cbs_get_user_data(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_call_cbs_set_camera_not_working(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_camera_not_working(IntPtr thiz, OnCameraNotWorkingDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCameraNotWorkingDelegatePrivate(IntPtr call, string cameraName);

		/// <summary>
		/// Callback to notify that the camera is not working and has been changed to "No
		/// Webcam". 
		/// <para>
		/// A camera is detected as mis-functionning as soon as it outputs no frames at all
		/// during a period of 5 seconds. This check is only performed on desktop
		/// platforms, in the purpose of notifying camera failures, for example if when a
		/// usb cable gets disconnected.
		/// 
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall for which the next video frame has been decoded
		///   </param>
		/// <param name="cameraName">the name of the non-working camera   </param>
		/// 
		public delegate void OnCameraNotWorkingDelegate(Linphone.Call call, string cameraName);
		private OnCameraNotWorkingDelegatePrivate on_camera_not_working_private;
		private OnCameraNotWorkingDelegate on_camera_not_working_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCameraNotWorkingDelegatePrivate))]
#endif
		private static void on_camera_not_working(IntPtr call, string cameraName)
		{
			Call thiz = fromNativePtr<Call>(call);
			CallListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_camera_not_working_public?.Invoke(thiz, cameraName);
			}
		}

		public OnCameraNotWorkingDelegate OnCameraNotWorking
		{
			get
			{
				return on_camera_not_working_public;
			}
			set
			{
				on_camera_not_working_public = value;
#if WINDOWS_UWP
				on_camera_not_working_private = on_camera_not_working;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_camera_not_working_private);
				linphone_call_cbs_set_camera_not_working(nativePtr, cb);
#else
				linphone_call_cbs_set_camera_not_working(nativePtr, on_camera_not_working);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_call_cbs_set_snapshot_taken(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_snapshot_taken(IntPtr thiz, OnSnapshotTakenDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSnapshotTakenDelegatePrivate(IntPtr call, string filePath);

		/// <summary>
		/// Callback for notifying a snapshot taken. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall for which the snapshot was taken   </param>
		/// <param name="filePath">the name of the saved file   </param>
		/// 
		public delegate void OnSnapshotTakenDelegate(Linphone.Call call, string filePath);
		private OnSnapshotTakenDelegatePrivate on_snapshot_taken_private;
		private OnSnapshotTakenDelegate on_snapshot_taken_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSnapshotTakenDelegatePrivate))]
#endif
		private static void on_snapshot_taken(IntPtr call, string filePath)
		{
			Call thiz = fromNativePtr<Call>(call);
			CallListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_snapshot_taken_public?.Invoke(thiz, filePath);
			}
		}

		public OnSnapshotTakenDelegate OnSnapshotTaken
		{
			get
			{
				return on_snapshot_taken_public;
			}
			set
			{
				on_snapshot_taken_public = value;
#if WINDOWS_UWP
				on_snapshot_taken_private = on_snapshot_taken;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_snapshot_taken_private);
				linphone_call_cbs_set_snapshot_taken(nativePtr, cb);
#else
				linphone_call_cbs_set_snapshot_taken(nativePtr, on_snapshot_taken);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_call_cbs_set_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_state_changed(IntPtr thiz, OnStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnStateChangedDelegatePrivate(IntPtr call, int state, string message);

		/// <summary>
		/// Call state notification callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall whose state is changed.   </param>
		/// <param name="state">The new LinphoneCallState of the call </param>
		/// <param name="message">An informational message about the state.   </param>
		/// 
		public delegate void OnStateChangedDelegate(Linphone.Call call, Linphone.CallState state, string message);
		private OnStateChangedDelegatePrivate on_state_changed_private;
		private OnStateChangedDelegate on_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnStateChangedDelegatePrivate))]
#endif
		private static void on_state_changed(IntPtr call, int state, string message)
		{
			Call thiz = fromNativePtr<Call>(call);
			CallListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_state_changed_public?.Invoke(thiz, (Linphone.CallState)state, message);
			}
		}

		public OnStateChangedDelegate OnStateChanged
		{
			get
			{
				return on_state_changed_public;
			}
			set
			{
				on_state_changed_public = value;
#if WINDOWS_UWP
				on_state_changed_private = on_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_state_changed_private);
				linphone_call_cbs_set_state_changed(nativePtr, cb);
#else
				linphone_call_cbs_set_state_changed(nativePtr, on_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_call_cbs_set_transfer_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_transfer_state_changed(IntPtr thiz, OnTransferStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnTransferStateChangedDelegatePrivate(IntPtr call, int state);

		/// <summary>
		/// Callback for notifying progresses of transfers. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall that was transfered   </param>
		/// <param name="state">The LinphoneCallState of the call to transfer target at the
		/// far end. </param>
		/// 
		public delegate void OnTransferStateChangedDelegate(Linphone.Call call, Linphone.CallState state);
		private OnTransferStateChangedDelegatePrivate on_transfer_state_changed_private;
		private OnTransferStateChangedDelegate on_transfer_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnTransferStateChangedDelegatePrivate))]
#endif
		private static void on_transfer_state_changed(IntPtr call, int state)
		{
			Call thiz = fromNativePtr<Call>(call);
			CallListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_transfer_state_changed_public?.Invoke(thiz, (Linphone.CallState)state);
			}
		}

		public OnTransferStateChangedDelegate OnTransferStateChanged
		{
			get
			{
				return on_transfer_state_changed_public;
			}
			set
			{
				on_transfer_state_changed_public = value;
#if WINDOWS_UWP
				on_transfer_state_changed_private = on_transfer_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_transfer_state_changed_private);
				linphone_call_cbs_set_transfer_state_changed(nativePtr, cb);
#else
				linphone_call_cbs_set_transfer_state_changed(nativePtr, on_transfer_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_call_cbs_set_tmmbr_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_tmmbr_received(IntPtr thiz, OnTmmbrReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnTmmbrReceivedDelegatePrivate(IntPtr call, int streamIndex, int tmmbr);

		/// <summary>
		/// Callback for notifying a received TMMBR. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall for which the TMMBR has changed   </param>
		/// <param name="streamIndex">the index of the current stream </param>
		/// <param name="tmmbr">the value of the received TMMBR </param>
		/// 
		public delegate void OnTmmbrReceivedDelegate(Linphone.Call call, int streamIndex, int tmmbr);
		private OnTmmbrReceivedDelegatePrivate on_tmmbr_received_private;
		private OnTmmbrReceivedDelegate on_tmmbr_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnTmmbrReceivedDelegatePrivate))]
#endif
		private static void on_tmmbr_received(IntPtr call, int streamIndex, int tmmbr)
		{
			Call thiz = fromNativePtr<Call>(call);
			CallListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_tmmbr_received_public?.Invoke(thiz, streamIndex, tmmbr);
			}
		}

		public OnTmmbrReceivedDelegate OnTmmbrReceived
		{
			get
			{
				return on_tmmbr_received_public;
			}
			set
			{
				on_tmmbr_received_public = value;
#if WINDOWS_UWP
				on_tmmbr_received_private = on_tmmbr_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_tmmbr_received_private);
				linphone_call_cbs_set_tmmbr_received(nativePtr, cb);
#else
				linphone_call_cbs_set_tmmbr_received(nativePtr, on_tmmbr_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_call_cbs_set_info_message_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_info_message_received(IntPtr thiz, OnInfoMessageReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnInfoMessageReceivedDelegatePrivate(IntPtr call, IntPtr message);

		/// <summary>
		/// Callback for receiving info messages. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall whose info message belongs to.   </param>
		/// <param name="message">LinphoneInfoMessage object.   </param>
		/// 
		public delegate void OnInfoMessageReceivedDelegate(Linphone.Call call, Linphone.InfoMessage message);
		private OnInfoMessageReceivedDelegatePrivate on_info_message_received_private;
		private OnInfoMessageReceivedDelegate on_info_message_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnInfoMessageReceivedDelegatePrivate))]
#endif
		private static void on_info_message_received(IntPtr call, IntPtr message)
		{
			Call thiz = fromNativePtr<Call>(call);
			CallListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_info_message_received_public?.Invoke(thiz, fromNativePtr<Linphone.InfoMessage>(message));
			}
		}

		public OnInfoMessageReceivedDelegate OnInfoMessageReceived
		{
			get
			{
				return on_info_message_received_public;
			}
			set
			{
				on_info_message_received_public = value;
#if WINDOWS_UWP
				on_info_message_received_private = on_info_message_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_info_message_received_private);
				linphone_call_cbs_set_info_message_received(nativePtr, cb);
#else
				linphone_call_cbs_set_info_message_received(nativePtr, on_info_message_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_call_cbs_set_encryption_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_encryption_changed(IntPtr thiz, OnEncryptionChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEncryptionChangedDelegatePrivate(IntPtr call, char on, string authenticationToken);

		/// <summary>
		/// Call encryption changed callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall object whose encryption is changed.   </param>
		/// <param name="on">Whether encryption is activated. </param>
		/// <param name="authenticationToken">An authentication_token, currently set for
		/// ZRTP kind of encryption only.   </param>
		/// 
		public delegate void OnEncryptionChangedDelegate(Linphone.Call call, bool on, string authenticationToken);
		private OnEncryptionChangedDelegatePrivate on_encryption_changed_private;
		private OnEncryptionChangedDelegate on_encryption_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEncryptionChangedDelegatePrivate))]
#endif
		private static void on_encryption_changed(IntPtr call, char on, string authenticationToken)
		{
			Call thiz = fromNativePtr<Call>(call);
			CallListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_encryption_changed_public?.Invoke(thiz, on == 0, authenticationToken);
			}
		}

		public OnEncryptionChangedDelegate OnEncryptionChanged
		{
			get
			{
				return on_encryption_changed_public;
			}
			set
			{
				on_encryption_changed_public = value;
#if WINDOWS_UWP
				on_encryption_changed_private = on_encryption_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_encryption_changed_private);
				linphone_call_cbs_set_encryption_changed(nativePtr, cb);
#else
				linphone_call_cbs_set_encryption_changed(nativePtr, on_encryption_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_call_cbs_set_ack_processing(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_ack_processing(IntPtr thiz, OnAckProcessingDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAckProcessingDelegatePrivate(IntPtr call, IntPtr ack, char isReceived);

		/// <summary>
		/// Callback for notifying the processing SIP ACK messages. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall for which an ACK is being received or sent  
		/// </param>
		/// <param name="ack">the ACK LinphoneHeaders   </param>
		/// <param name="isReceived">if true this ACK is an incoming one, otherwise it is
		/// an ACK about to be sent. </param>
		/// 
		public delegate void OnAckProcessingDelegate(Linphone.Call call, Linphone.Headers ack, bool isReceived);
		private OnAckProcessingDelegatePrivate on_ack_processing_private;
		private OnAckProcessingDelegate on_ack_processing_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAckProcessingDelegatePrivate))]
#endif
		private static void on_ack_processing(IntPtr call, IntPtr ack, char isReceived)
		{
			Call thiz = fromNativePtr<Call>(call);
			CallListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_ack_processing_public?.Invoke(thiz, fromNativePtr<Linphone.Headers>(ack), isReceived == 0);
			}
		}

		public OnAckProcessingDelegate OnAckProcessing
		{
			get
			{
				return on_ack_processing_public;
			}
			set
			{
				on_ack_processing_public = value;
#if WINDOWS_UWP
				on_ack_processing_private = on_ack_processing;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ack_processing_private);
				linphone_call_cbs_set_ack_processing(nativePtr, cb);
#else
				linphone_call_cbs_set_ack_processing(nativePtr, on_ack_processing);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_call_cbs_set_dtmf_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_dtmf_received(IntPtr thiz, OnDtmfReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnDtmfReceivedDelegatePrivate(IntPtr call, int dtmf);

		/// <summary>
		/// Callback for being notified of received DTMFs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall object that received the dtmf   </param>
		/// <param name="dtmf">The ascii code of the dtmf </param>
		/// 
		public delegate void OnDtmfReceivedDelegate(Linphone.Call call, int dtmf);
		private OnDtmfReceivedDelegatePrivate on_dtmf_received_private;
		private OnDtmfReceivedDelegate on_dtmf_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnDtmfReceivedDelegatePrivate))]
#endif
		private static void on_dtmf_received(IntPtr call, int dtmf)
		{
			Call thiz = fromNativePtr<Call>(call);
			CallListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_dtmf_received_public?.Invoke(thiz, dtmf);
			}
		}

		public OnDtmfReceivedDelegate OnDtmfReceived
		{
			get
			{
				return on_dtmf_received_public;
			}
			set
			{
				on_dtmf_received_public = value;
#if WINDOWS_UWP
				on_dtmf_received_private = on_dtmf_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_dtmf_received_private);
				linphone_call_cbs_set_dtmf_received(nativePtr, cb);
#else
				linphone_call_cbs_set_dtmf_received(nativePtr, on_dtmf_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_call_cbs_set_next_video_frame_decoded(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_next_video_frame_decoded(IntPtr thiz, OnNextVideoFrameDecodedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNextVideoFrameDecodedDelegatePrivate(IntPtr call);

		/// <summary>
		/// Callback to notify a next video frame has been decoded. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall for which the next video frame has been decoded
		///   </param>
		/// 
		public delegate void OnNextVideoFrameDecodedDelegate(Linphone.Call call);
		private OnNextVideoFrameDecodedDelegatePrivate on_next_video_frame_decoded_private;
		private OnNextVideoFrameDecodedDelegate on_next_video_frame_decoded_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNextVideoFrameDecodedDelegatePrivate))]
#endif
		private static void on_next_video_frame_decoded(IntPtr call)
		{
			Call thiz = fromNativePtr<Call>(call);
			CallListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_next_video_frame_decoded_public?.Invoke(thiz);
			}
		}

		public OnNextVideoFrameDecodedDelegate OnNextVideoFrameDecoded
		{
			get
			{
				return on_next_video_frame_decoded_public;
			}
			set
			{
				on_next_video_frame_decoded_public = value;
#if WINDOWS_UWP
				on_next_video_frame_decoded_private = on_next_video_frame_decoded;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_next_video_frame_decoded_private);
				linphone_call_cbs_set_next_video_frame_decoded(nativePtr, cb);
#else
				linphone_call_cbs_set_next_video_frame_decoded(nativePtr, on_next_video_frame_decoded);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_call_cbs_set_stats_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_stats_updated(IntPtr thiz, OnStatsUpdatedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnStatsUpdatedDelegatePrivate(IntPtr call, IntPtr stats);

		/// <summary>
		/// Callback for receiving quality statistics for calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall object whose statistics are notified   </param>
		/// <param name="stats">LinphoneCallStats object   </param>
		/// 
		public delegate void OnStatsUpdatedDelegate(Linphone.Call call, Linphone.CallStats stats);
		private OnStatsUpdatedDelegatePrivate on_stats_updated_private;
		private OnStatsUpdatedDelegate on_stats_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnStatsUpdatedDelegatePrivate))]
#endif
		private static void on_stats_updated(IntPtr call, IntPtr stats)
		{
			Call thiz = fromNativePtr<Call>(call);
			CallListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_stats_updated_public?.Invoke(thiz, fromNativePtr<Linphone.CallStats>(stats));
			}
		}

		public OnStatsUpdatedDelegate OnStatsUpdated
		{
			get
			{
				return on_stats_updated_public;
			}
			set
			{
				on_stats_updated_public = value;
#if WINDOWS_UWP
				on_stats_updated_private = on_stats_updated;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_stats_updated_private);
				linphone_call_cbs_set_stats_updated(nativePtr, cb);
#else
				linphone_call_cbs_set_stats_updated(nativePtr, on_stats_updated);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_call_cbs_set_audio_device_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_audio_device_changed(IntPtr thiz, OnAudioDeviceChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAudioDeviceChangedDelegatePrivate(IntPtr call, IntPtr audioDevice);

		/// <summary>
		/// Callback to notify that the audio device has been changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall for which the audio device has changed  
		/// </param>
		/// <param name="audioDevice">the new audio device used for this call   </param>
		/// 
		public delegate void OnAudioDeviceChangedDelegate(Linphone.Call call, Linphone.AudioDevice audioDevice);
		private OnAudioDeviceChangedDelegatePrivate on_audio_device_changed_private;
		private OnAudioDeviceChangedDelegate on_audio_device_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAudioDeviceChangedDelegatePrivate))]
#endif
		private static void on_audio_device_changed(IntPtr call, IntPtr audioDevice)
		{
			Call thiz = fromNativePtr<Call>(call);
			CallListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_audio_device_changed_public?.Invoke(thiz, fromNativePtr<Linphone.AudioDevice>(audioDevice));
			}
		}

		public OnAudioDeviceChangedDelegate OnAudioDeviceChanged
		{
			get
			{
				return on_audio_device_changed_public;
			}
			set
			{
				on_audio_device_changed_public = value;
#if WINDOWS_UWP
				on_audio_device_changed_private = on_audio_device_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_audio_device_changed_private);
				linphone_call_cbs_set_audio_device_changed(nativePtr, cb);
#else
				linphone_call_cbs_set_audio_device_changed(nativePtr, on_audio_device_changed);
#endif
			}
		}

		internal void register() {
			IntPtr listener = linphone_call_cbs_get_user_data(nativePtr);
			if (listener == IntPtr.Zero)
			{
				GCHandle _handle = GCHandle.Alloc(this, GCHandleType.Normal);
				listener = GCHandle.ToIntPtr(_handle);
			} else
			{
				GCHandle _handle = GCHandle.FromIntPtr(listener);
				if (_handle.Target == this)
				{
					return;
				} else
				{
					_handle.Free();
					_handle = GCHandle.Alloc(this, GCHandleType.Normal);
					listener = GCHandle.ToIntPtr(_handle);
				}
			}
			linphone_call_cbs_set_user_data(nativePtr, listener);
		}

		internal void unregister() {
			IntPtr listener = linphone_call_cbs_get_user_data(nativePtr);
			linphone_call_cbs_set_user_data(nativePtr, IntPtr.Zero);
			if (listener != IntPtr.Zero)
			{
				GCHandle.FromIntPtr(listener).Free();
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for the handling a LinphoneChatMessage
	/// objects. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ChatMessageListener : LinphoneObject
	{
        ~ChatMessageListener()
        {
            unregister();
        }

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern void linphone_chat_message_cbs_set_user_data(IntPtr thiz, IntPtr listener);

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr linphone_chat_message_cbs_get_user_data(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_message_cbs_set_participant_imdn_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_participant_imdn_state_changed(IntPtr thiz, OnParticipantImdnStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantImdnStateChangedDelegatePrivate(IntPtr message, IntPtr state);

		/// <summary>
		/// Call back used to notify participant IMDN state. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">LinphoneChatMessage object   </param>
		/// <param name="state">LinphoneParticipantImdnState   </param>
		/// 
		public delegate void OnParticipantImdnStateChangedDelegate(Linphone.ChatMessage message, Linphone.ParticipantImdnState state);
		private OnParticipantImdnStateChangedDelegatePrivate on_participant_imdn_state_changed_private;
		private OnParticipantImdnStateChangedDelegate on_participant_imdn_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantImdnStateChangedDelegatePrivate))]
#endif
		private static void on_participant_imdn_state_changed(IntPtr message, IntPtr state)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);
			ChatMessageListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_imdn_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ParticipantImdnState>(state));
			}
		}

		public OnParticipantImdnStateChangedDelegate OnParticipantImdnStateChanged
		{
			get
			{
				return on_participant_imdn_state_changed_public;
			}
			set
			{
				on_participant_imdn_state_changed_public = value;
#if WINDOWS_UWP
				on_participant_imdn_state_changed_private = on_participant_imdn_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_imdn_state_changed_private);
				linphone_chat_message_cbs_set_participant_imdn_state_changed(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_participant_imdn_state_changed(nativePtr, on_participant_imdn_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_message_cbs_set_file_transfer_recv(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_file_transfer_recv(IntPtr thiz, OnFileTransferRecvDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFileTransferRecvDelegatePrivate(IntPtr message, IntPtr content, IntPtr buffer);

		/// <summary>
		/// File transfer receive callback prototype. 
		/// <para>
		/// This function is called by the core upon an incoming File transfer is started.
		/// This function may be call several time for the same file in case of large file. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="message">LinphoneChatMessage message from which the body is
		/// received.   </param>
		/// <param name="content">LinphoneContent incoming content information   </param>
		/// <param name="buffer">LinphoneBuffer holding the received data. Empty buffer
		/// means end of file.   </param>
		/// 
		public delegate void OnFileTransferRecvDelegate(Linphone.ChatMessage message, Linphone.Content content, Linphone.Buffer buffer);
		private OnFileTransferRecvDelegatePrivate on_file_transfer_recv_private;
		private OnFileTransferRecvDelegate on_file_transfer_recv_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFileTransferRecvDelegatePrivate))]
#endif
		private static void on_file_transfer_recv(IntPtr message, IntPtr content, IntPtr buffer)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);
			ChatMessageListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_file_transfer_recv_public?.Invoke(thiz, fromNativePtr<Linphone.Content>(content), fromNativePtr<Linphone.Buffer>(buffer));
			}
		}

		public OnFileTransferRecvDelegate OnFileTransferRecv
		{
			get
			{
				return on_file_transfer_recv_public;
			}
			set
			{
				on_file_transfer_recv_public = value;
#if WINDOWS_UWP
				on_file_transfer_recv_private = on_file_transfer_recv;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_file_transfer_recv_private);
				linphone_chat_message_cbs_set_file_transfer_recv(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_file_transfer_recv(nativePtr, on_file_transfer_recv);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_message_cbs_set_msg_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_msg_state_changed(IntPtr thiz, OnMsgStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnMsgStateChangedDelegatePrivate(IntPtr message, int state);

		/// <summary>
		/// Call back used to notify message delivery status. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">LinphoneChatMessage object   </param>
		/// <param name="state">LinphoneChatMessageState </param>
		/// 
		public delegate void OnMsgStateChangedDelegate(Linphone.ChatMessage message, Linphone.ChatMessageState state);
		private OnMsgStateChangedDelegatePrivate on_msg_state_changed_private;
		private OnMsgStateChangedDelegate on_msg_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnMsgStateChangedDelegatePrivate))]
#endif
		private static void on_msg_state_changed(IntPtr message, int state)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);
			ChatMessageListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_msg_state_changed_public?.Invoke(thiz, (Linphone.ChatMessageState)state);
			}
		}

		public OnMsgStateChangedDelegate OnMsgStateChanged
		{
			get
			{
				return on_msg_state_changed_public;
			}
			set
			{
				on_msg_state_changed_public = value;
#if WINDOWS_UWP
				on_msg_state_changed_private = on_msg_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_msg_state_changed_private);
				linphone_chat_message_cbs_set_msg_state_changed(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_msg_state_changed(nativePtr, on_msg_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_message_cbs_set_file_transfer_send(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_file_transfer_send(IntPtr thiz, OnFileTransferSendDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFileTransferSendDelegatePrivate(IntPtr message, IntPtr content, long offset, long size);

		/// <summary>
		/// File transfer send callback prototype. 
		/// <para>
		/// This function is called by the core when an outgoing file transfer is started.
		/// This function is called until size is set to 0. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="message">LinphoneChatMessage message from which the body is
		/// received.   </param>
		/// <param name="content">LinphoneContent outgoing content   </param>
		/// <param name="offset">the offset in the file from where to get the data to be
		/// sent </param>
		/// <param name="size">the number of bytes expected by the framework </param>
		/// 
		/// 
		/// <returns>A LinphoneBuffer object holding the data written by the application.
		/// An empty buffer means end of file.   </returns>
		/// 
		/// <remarks>Warning : The returned value isn't used, hence the deprecation!
		/// </remarks> 
		/// 
		/// deprecated : 17/08/2020 Use LinphoneChatMessageCbsFileTransferSendChunkCb
		/// instead. 
		public delegate void OnFileTransferSendDelegate(Linphone.ChatMessage message, Linphone.Content content, long offset, long size);
		private OnFileTransferSendDelegatePrivate on_file_transfer_send_private;
		private OnFileTransferSendDelegate on_file_transfer_send_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFileTransferSendDelegatePrivate))]
#endif
		private static void on_file_transfer_send(IntPtr message, IntPtr content, long offset, long size)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);
			ChatMessageListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_file_transfer_send_public?.Invoke(thiz, fromNativePtr<Linphone.Content>(content), offset, size);
			}
		}

		public OnFileTransferSendDelegate OnFileTransferSend
		{
			get
			{
				return on_file_transfer_send_public;
			}
			set
			{
				on_file_transfer_send_public = value;
#if WINDOWS_UWP
				on_file_transfer_send_private = on_file_transfer_send;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_file_transfer_send_private);
				linphone_chat_message_cbs_set_file_transfer_send(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_file_transfer_send(nativePtr, on_file_transfer_send);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_message_cbs_set_ephemeral_message_timer_started(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_ephemeral_message_timer_started(IntPtr thiz, OnEphemeralMessageTimerStartedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEphemeralMessageTimerStartedDelegatePrivate(IntPtr message);

		/// <summary>
		/// Callback used to notify an ephemeral message that its lifespan before
		/// disappearing has started to decrease. 
		/// <para>
		/// This callback is called when the ephemeral message is read by the receiver. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="message">LinphoneChatMessage object   </param>
		/// 
		public delegate void OnEphemeralMessageTimerStartedDelegate(Linphone.ChatMessage message);
		private OnEphemeralMessageTimerStartedDelegatePrivate on_ephemeral_message_timer_started_private;
		private OnEphemeralMessageTimerStartedDelegate on_ephemeral_message_timer_started_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEphemeralMessageTimerStartedDelegatePrivate))]
#endif
		private static void on_ephemeral_message_timer_started(IntPtr message)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);
			ChatMessageListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_ephemeral_message_timer_started_public?.Invoke(thiz);
			}
		}

		public OnEphemeralMessageTimerStartedDelegate OnEphemeralMessageTimerStarted
		{
			get
			{
				return on_ephemeral_message_timer_started_public;
			}
			set
			{
				on_ephemeral_message_timer_started_public = value;
#if WINDOWS_UWP
				on_ephemeral_message_timer_started_private = on_ephemeral_message_timer_started;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ephemeral_message_timer_started_private);
				linphone_chat_message_cbs_set_ephemeral_message_timer_started(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_ephemeral_message_timer_started(nativePtr, on_ephemeral_message_timer_started);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_message_cbs_set_file_transfer_progress_indication(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_file_transfer_progress_indication(IntPtr thiz, OnFileTransferProgressIndicationDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFileTransferProgressIndicationDelegatePrivate(IntPtr message, IntPtr content, long offset, long total);

		/// <summary>
		/// File transfer progress indication callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">LinphoneChatMessage message from which the body is
		/// received.   </param>
		/// <param name="content">LinphoneContent incoming content information   </param>
		/// <param name="offset">The number of bytes sent/received since the beginning of
		/// the transfer. </param>
		/// <param name="total">The total number of bytes to be sent/received. </param>
		/// 
		public delegate void OnFileTransferProgressIndicationDelegate(Linphone.ChatMessage message, Linphone.Content content, long offset, long total);
		private OnFileTransferProgressIndicationDelegatePrivate on_file_transfer_progress_indication_private;
		private OnFileTransferProgressIndicationDelegate on_file_transfer_progress_indication_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFileTransferProgressIndicationDelegatePrivate))]
#endif
		private static void on_file_transfer_progress_indication(IntPtr message, IntPtr content, long offset, long total)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);
			ChatMessageListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_file_transfer_progress_indication_public?.Invoke(thiz, fromNativePtr<Linphone.Content>(content), offset, total);
			}
		}

		public OnFileTransferProgressIndicationDelegate OnFileTransferProgressIndication
		{
			get
			{
				return on_file_transfer_progress_indication_public;
			}
			set
			{
				on_file_transfer_progress_indication_public = value;
#if WINDOWS_UWP
				on_file_transfer_progress_indication_private = on_file_transfer_progress_indication;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_file_transfer_progress_indication_private);
				linphone_chat_message_cbs_set_file_transfer_progress_indication(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_file_transfer_progress_indication(nativePtr, on_file_transfer_progress_indication);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_message_cbs_set_file_transfer_send_chunk(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_file_transfer_send_chunk(IntPtr thiz, OnFileTransferSendChunkDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFileTransferSendChunkDelegatePrivate(IntPtr message, IntPtr content, long offset, long size, IntPtr buffer);

		/// <summary>
		/// File transfer send callback prototype. 
		/// <para>
		/// This function is called by the core when an outgoing file transfer is started.
		/// This function is called until size is set to 0. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="message">LinphoneChatMessage message from which the body is
		/// received.   </param>
		/// <param name="content">LinphoneContent outgoing content   </param>
		/// <param name="offset">the offset in the file from where to get the data to be
		/// sent </param>
		/// <param name="size">the number of bytes expected by the framework </param>
		/// <param name="buffer">A LinphoneBuffer to be filled. Leave it empty when end of
		/// file has been reached.   </param>
		/// 
		public delegate void OnFileTransferSendChunkDelegate(Linphone.ChatMessage message, Linphone.Content content, long offset, long size, Linphone.Buffer buffer);
		private OnFileTransferSendChunkDelegatePrivate on_file_transfer_send_chunk_private;
		private OnFileTransferSendChunkDelegate on_file_transfer_send_chunk_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFileTransferSendChunkDelegatePrivate))]
#endif
		private static void on_file_transfer_send_chunk(IntPtr message, IntPtr content, long offset, long size, IntPtr buffer)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);
			ChatMessageListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_file_transfer_send_chunk_public?.Invoke(thiz, fromNativePtr<Linphone.Content>(content), offset, size, fromNativePtr<Linphone.Buffer>(buffer));
			}
		}

		public OnFileTransferSendChunkDelegate OnFileTransferSendChunk
		{
			get
			{
				return on_file_transfer_send_chunk_public;
			}
			set
			{
				on_file_transfer_send_chunk_public = value;
#if WINDOWS_UWP
				on_file_transfer_send_chunk_private = on_file_transfer_send_chunk;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_file_transfer_send_chunk_private);
				linphone_chat_message_cbs_set_file_transfer_send_chunk(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_file_transfer_send_chunk(nativePtr, on_file_transfer_send_chunk);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_message_cbs_set_ephemeral_message_deleted(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_ephemeral_message_deleted(IntPtr thiz, OnEphemeralMessageDeletedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEphemeralMessageDeletedDelegatePrivate(IntPtr message);

		/// <summary>
		/// Call back used to notify ephemeral message is deleted. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">LinphoneChatMessage object   </param>
		/// 
		public delegate void OnEphemeralMessageDeletedDelegate(Linphone.ChatMessage message);
		private OnEphemeralMessageDeletedDelegatePrivate on_ephemeral_message_deleted_private;
		private OnEphemeralMessageDeletedDelegate on_ephemeral_message_deleted_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEphemeralMessageDeletedDelegatePrivate))]
#endif
		private static void on_ephemeral_message_deleted(IntPtr message)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);
			ChatMessageListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_ephemeral_message_deleted_public?.Invoke(thiz);
			}
		}

		public OnEphemeralMessageDeletedDelegate OnEphemeralMessageDeleted
		{
			get
			{
				return on_ephemeral_message_deleted_public;
			}
			set
			{
				on_ephemeral_message_deleted_public = value;
#if WINDOWS_UWP
				on_ephemeral_message_deleted_private = on_ephemeral_message_deleted;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ephemeral_message_deleted_private);
				linphone_chat_message_cbs_set_ephemeral_message_deleted(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_ephemeral_message_deleted(nativePtr, on_ephemeral_message_deleted);
#endif
			}
		}

		internal void register() {
			IntPtr listener = linphone_chat_message_cbs_get_user_data(nativePtr);
			if (listener == IntPtr.Zero)
			{
				GCHandle _handle = GCHandle.Alloc(this, GCHandleType.Normal);
				listener = GCHandle.ToIntPtr(_handle);
			} else
			{
				GCHandle _handle = GCHandle.FromIntPtr(listener);
				if (_handle.Target == this)
				{
					return;
				} else
				{
					_handle.Free();
					_handle = GCHandle.Alloc(this, GCHandleType.Normal);
					listener = GCHandle.ToIntPtr(_handle);
				}
			}
			linphone_chat_message_cbs_set_user_data(nativePtr, listener);
		}

		internal void unregister() {
			IntPtr listener = linphone_chat_message_cbs_get_user_data(nativePtr);
			linphone_chat_message_cbs_set_user_data(nativePtr, IntPtr.Zero);
			if (listener != IntPtr.Zero)
			{
				GCHandle.FromIntPtr(listener).Free();
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for the handling a LinphoneChatRoom objects. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ChatRoomListener : LinphoneObject
	{
        ~ChatRoomListener()
        {
            unregister();
        }

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern void linphone_chat_room_cbs_set_user_data(IntPtr thiz, IntPtr listener);

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr linphone_chat_room_cbs_get_user_data(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_state_changed(IntPtr thiz, OnStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnStateChangedDelegatePrivate(IntPtr chatRoom, int newState);

		/// <summary>
		/// Callback used to notify a chat room state has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="newState">The new LinphoneChatRoomState of the chat room </param>
		/// 
		public delegate void OnStateChangedDelegate(Linphone.ChatRoom chatRoom, Linphone.ChatRoomState newState);
		private OnStateChangedDelegatePrivate on_state_changed_private;
		private OnStateChangedDelegate on_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnStateChangedDelegatePrivate))]
#endif
		private static void on_state_changed(IntPtr chatRoom, int newState)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_state_changed_public?.Invoke(thiz, (Linphone.ChatRoomState)newState);
			}
		}

		public OnStateChangedDelegate OnStateChanged
		{
			get
			{
				return on_state_changed_public;
			}
			set
			{
				on_state_changed_public = value;
#if WINDOWS_UWP
				on_state_changed_private = on_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_state_changed_private);
				linphone_chat_room_cbs_set_state_changed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_state_changed(nativePtr, on_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_ephemeral_message_timer_started(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_ephemeral_message_timer_started(IntPtr thiz, OnEphemeralMessageTimerStartedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEphemeralMessageTimerStartedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that the lifespan of an ephemeral message
		/// before disappearing has started to decrease. 
		/// <para>
		/// This callback is called when the ephemeral message is read by the receiver. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnEphemeralMessageTimerStartedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnEphemeralMessageTimerStartedDelegatePrivate on_ephemeral_message_timer_started_private;
		private OnEphemeralMessageTimerStartedDelegate on_ephemeral_message_timer_started_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEphemeralMessageTimerStartedDelegatePrivate))]
#endif
		private static void on_ephemeral_message_timer_started(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_ephemeral_message_timer_started_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnEphemeralMessageTimerStartedDelegate OnEphemeralMessageTimerStarted
		{
			get
			{
				return on_ephemeral_message_timer_started_public;
			}
			set
			{
				on_ephemeral_message_timer_started_public = value;
#if WINDOWS_UWP
				on_ephemeral_message_timer_started_private = on_ephemeral_message_timer_started;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ephemeral_message_timer_started_private);
				linphone_chat_room_cbs_set_ephemeral_message_timer_started(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_ephemeral_message_timer_started(nativePtr, on_ephemeral_message_timer_started);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_participant_admin_status_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_admin_status_changed(IntPtr thiz, OnParticipantAdminStatusChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantAdminStatusChangedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that the admin status of a participant has
		/// been changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnParticipantAdminStatusChangedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnParticipantAdminStatusChangedDelegatePrivate on_participant_admin_status_changed_private;
		private OnParticipantAdminStatusChangedDelegate on_participant_admin_status_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantAdminStatusChangedDelegatePrivate))]
#endif
		private static void on_participant_admin_status_changed(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_admin_status_changed_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnParticipantAdminStatusChangedDelegate OnParticipantAdminStatusChanged
		{
			get
			{
				return on_participant_admin_status_changed_public;
			}
			set
			{
				on_participant_admin_status_changed_public = value;
#if WINDOWS_UWP
				on_participant_admin_status_changed_private = on_participant_admin_status_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_admin_status_changed_private);
				linphone_chat_room_cbs_set_participant_admin_status_changed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_admin_status_changed(nativePtr, on_participant_admin_status_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_participant_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_removed(IntPtr thiz, OnParticipantRemovedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantRemovedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a participant has been removed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnParticipantRemovedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnParticipantRemovedDelegatePrivate on_participant_removed_private;
		private OnParticipantRemovedDelegate on_participant_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantRemovedDelegatePrivate))]
#endif
		private static void on_participant_removed(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_removed_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnParticipantRemovedDelegate OnParticipantRemoved
		{
			get
			{
				return on_participant_removed_public;
			}
			set
			{
				on_participant_removed_public = value;
#if WINDOWS_UWP
				on_participant_removed_private = on_participant_removed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_removed_private);
				linphone_chat_room_cbs_set_participant_removed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_removed(nativePtr, on_participant_removed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_participant_registration_unsubscription_requested(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_registration_unsubscription_requested(IntPtr thiz, OnParticipantRegistrationUnsubscriptionRequestedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantRegistrationUnsubscriptionRequestedDelegatePrivate(IntPtr chatRoom, IntPtr participantAddress);

		/// <summary>
		/// Callback used when a group chat room server is unsubscribing to registration
		/// state of a participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="participantAddress">LinphoneAddress object   </param>
		/// 
		public delegate void OnParticipantRegistrationUnsubscriptionRequestedDelegate(Linphone.ChatRoom chatRoom, Linphone.Address participantAddress);
		private OnParticipantRegistrationUnsubscriptionRequestedDelegatePrivate on_participant_registration_unsubscription_requested_private;
		private OnParticipantRegistrationUnsubscriptionRequestedDelegate on_participant_registration_unsubscription_requested_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantRegistrationUnsubscriptionRequestedDelegatePrivate))]
#endif
		private static void on_participant_registration_unsubscription_requested(IntPtr chatRoom, IntPtr participantAddress)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_registration_unsubscription_requested_public?.Invoke(thiz, fromNativePtr<Linphone.Address>(participantAddress));
			}
		}

		public OnParticipantRegistrationUnsubscriptionRequestedDelegate OnParticipantRegistrationUnsubscriptionRequested
		{
			get
			{
				return on_participant_registration_unsubscription_requested_public;
			}
			set
			{
				on_participant_registration_unsubscription_requested_public = value;
#if WINDOWS_UWP
				on_participant_registration_unsubscription_requested_private = on_participant_registration_unsubscription_requested;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_registration_unsubscription_requested_private);
				linphone_chat_room_cbs_set_participant_registration_unsubscription_requested(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_registration_unsubscription_requested(nativePtr, on_participant_registration_unsubscription_requested);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_undecryptable_message_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_undecryptable_message_received(IntPtr thiz, OnUndecryptableMessageReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnUndecryptableMessageReceivedDelegatePrivate(IntPtr chatRoom, IntPtr message);

		/// <summary>
		/// Callback used to notify a chat room that a message has been received but we
		/// were unable to decrypt it. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom involved in this conversation   </param>
		/// <param name="message">The LinphoneChatMessage that has been received   </param>
		/// 
		public delegate void OnUndecryptableMessageReceivedDelegate(Linphone.ChatRoom chatRoom, Linphone.ChatMessage message);
		private OnUndecryptableMessageReceivedDelegatePrivate on_undecryptable_message_received_private;
		private OnUndecryptableMessageReceivedDelegate on_undecryptable_message_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnUndecryptableMessageReceivedDelegatePrivate))]
#endif
		private static void on_undecryptable_message_received(IntPtr chatRoom, IntPtr message)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_undecryptable_message_received_public?.Invoke(thiz, fromNativePtr<Linphone.ChatMessage>(message));
			}
		}

		public OnUndecryptableMessageReceivedDelegate OnUndecryptableMessageReceived
		{
			get
			{
				return on_undecryptable_message_received_public;
			}
			set
			{
				on_undecryptable_message_received_public = value;
#if WINDOWS_UWP
				on_undecryptable_message_received_private = on_undecryptable_message_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_undecryptable_message_received_private);
				linphone_chat_room_cbs_set_undecryptable_message_received(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_undecryptable_message_received(nativePtr, on_undecryptable_message_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_participant_added(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_added(IntPtr thiz, OnParticipantAddedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantAddedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a participant has been added. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnParticipantAddedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnParticipantAddedDelegatePrivate on_participant_added_private;
		private OnParticipantAddedDelegate on_participant_added_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantAddedDelegatePrivate))]
#endif
		private static void on_participant_added(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_added_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnParticipantAddedDelegate OnParticipantAdded
		{
			get
			{
				return on_participant_added_public;
			}
			set
			{
				on_participant_added_public = value;
#if WINDOWS_UWP
				on_participant_added_private = on_participant_added;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_added_private);
				linphone_chat_room_cbs_set_participant_added(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_added(nativePtr, on_participant_added);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_ephemeral_event(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_ephemeral_event(IntPtr thiz, OnEphemeralEventDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEphemeralEventDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that an ephemeral related event has been
		/// generated. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnEphemeralEventDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnEphemeralEventDelegatePrivate on_ephemeral_event_private;
		private OnEphemeralEventDelegate on_ephemeral_event_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEphemeralEventDelegatePrivate))]
#endif
		private static void on_ephemeral_event(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_ephemeral_event_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnEphemeralEventDelegate OnEphemeralEvent
		{
			get
			{
				return on_ephemeral_event_public;
			}
			set
			{
				on_ephemeral_event_public = value;
#if WINDOWS_UWP
				on_ephemeral_event_private = on_ephemeral_event;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ephemeral_event_private);
				linphone_chat_room_cbs_set_ephemeral_event(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_ephemeral_event(nativePtr, on_ephemeral_event);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_chat_message_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_chat_message_received(IntPtr thiz, OnChatMessageReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatMessageReceivedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a chat message has been received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnChatMessageReceivedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnChatMessageReceivedDelegatePrivate on_chat_message_received_private;
		private OnChatMessageReceivedDelegate on_chat_message_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatMessageReceivedDelegatePrivate))]
#endif
		private static void on_chat_message_received(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_chat_message_received_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnChatMessageReceivedDelegate OnChatMessageReceived
		{
			get
			{
				return on_chat_message_received_public;
			}
			set
			{
				on_chat_message_received_public = value;
#if WINDOWS_UWP
				on_chat_message_received_private = on_chat_message_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_message_received_private);
				linphone_chat_room_cbs_set_chat_message_received(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_chat_message_received(nativePtr, on_chat_message_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_conference_address_generation(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_conference_address_generation(IntPtr thiz, OnConferenceAddressGenerationDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnConferenceAddressGenerationDelegatePrivate(IntPtr chatRoom);

		/// <summary>
		/// Callback used when a group chat room is created server-side to generate the
		/// address of the chat room. 
		/// <para>
		/// The function linphone_chat_room_set_conference_address needs to be called by
		/// this callback. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// 
		public delegate void OnConferenceAddressGenerationDelegate(Linphone.ChatRoom chatRoom);
		private OnConferenceAddressGenerationDelegatePrivate on_conference_address_generation_private;
		private OnConferenceAddressGenerationDelegate on_conference_address_generation_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnConferenceAddressGenerationDelegatePrivate))]
#endif
		private static void on_conference_address_generation(IntPtr chatRoom)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_conference_address_generation_public?.Invoke(thiz);
			}
		}

		public OnConferenceAddressGenerationDelegate OnConferenceAddressGeneration
		{
			get
			{
				return on_conference_address_generation_public;
			}
			set
			{
				on_conference_address_generation_public = value;
#if WINDOWS_UWP
				on_conference_address_generation_private = on_conference_address_generation;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_conference_address_generation_private);
				linphone_chat_room_cbs_set_conference_address_generation(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_conference_address_generation(nativePtr, on_conference_address_generation);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_participant_device_added(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_device_added(IntPtr thiz, OnParticipantDeviceAddedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceAddedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a participant has been added. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnParticipantDeviceAddedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnParticipantDeviceAddedDelegatePrivate on_participant_device_added_private;
		private OnParticipantDeviceAddedDelegate on_participant_device_added_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceAddedDelegatePrivate))]
#endif
		private static void on_participant_device_added(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_device_added_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnParticipantDeviceAddedDelegate OnParticipantDeviceAdded
		{
			get
			{
				return on_participant_device_added_public;
			}
			set
			{
				on_participant_device_added_public = value;
#if WINDOWS_UWP
				on_participant_device_added_private = on_participant_device_added;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_added_private);
				linphone_chat_room_cbs_set_participant_device_added(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_device_added(nativePtr, on_participant_device_added);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_security_event(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_security_event(IntPtr thiz, OnSecurityEventDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSecurityEventDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a security event in the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnSecurityEventDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnSecurityEventDelegatePrivate on_security_event_private;
		private OnSecurityEventDelegate on_security_event_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSecurityEventDelegatePrivate))]
#endif
		private static void on_security_event(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_security_event_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnSecurityEventDelegate OnSecurityEvent
		{
			get
			{
				return on_security_event_public;
			}
			set
			{
				on_security_event_public = value;
#if WINDOWS_UWP
				on_security_event_private = on_security_event;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_security_event_private);
				linphone_chat_room_cbs_set_security_event(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_security_event(nativePtr, on_security_event);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_conference_left(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_conference_left(IntPtr thiz, OnConferenceLeftDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnConferenceLeftDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room has been left. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnConferenceLeftDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnConferenceLeftDelegatePrivate on_conference_left_private;
		private OnConferenceLeftDelegate on_conference_left_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnConferenceLeftDelegatePrivate))]
#endif
		private static void on_conference_left(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_conference_left_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnConferenceLeftDelegate OnConferenceLeft
		{
			get
			{
				return on_conference_left_public;
			}
			set
			{
				on_conference_left_public = value;
#if WINDOWS_UWP
				on_conference_left_private = on_conference_left;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_conference_left_private);
				linphone_chat_room_cbs_set_conference_left(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_conference_left(nativePtr, on_conference_left);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_subject_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_subject_changed(IntPtr thiz, OnSubjectChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSubjectChangedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify that the subject of a chat room has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnSubjectChangedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnSubjectChangedDelegatePrivate on_subject_changed_private;
		private OnSubjectChangedDelegate on_subject_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSubjectChangedDelegatePrivate))]
#endif
		private static void on_subject_changed(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_subject_changed_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnSubjectChangedDelegate OnSubjectChanged
		{
			get
			{
				return on_subject_changed_public;
			}
			set
			{
				on_subject_changed_public = value;
#if WINDOWS_UWP
				on_subject_changed_private = on_subject_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_subject_changed_private);
				linphone_chat_room_cbs_set_subject_changed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_subject_changed(nativePtr, on_subject_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_chat_message_sent(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_chat_message_sent(IntPtr thiz, OnChatMessageSentDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatMessageSentDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a chat message is being sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnChatMessageSentDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnChatMessageSentDelegatePrivate on_chat_message_sent_private;
		private OnChatMessageSentDelegate on_chat_message_sent_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatMessageSentDelegatePrivate))]
#endif
		private static void on_chat_message_sent(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_chat_message_sent_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnChatMessageSentDelegate OnChatMessageSent
		{
			get
			{
				return on_chat_message_sent_public;
			}
			set
			{
				on_chat_message_sent_public = value;
#if WINDOWS_UWP
				on_chat_message_sent_private = on_chat_message_sent;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_message_sent_private);
				linphone_chat_room_cbs_set_chat_message_sent(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_chat_message_sent(nativePtr, on_chat_message_sent);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_chat_message_participant_imdn_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_chat_message_participant_imdn_state_changed(IntPtr thiz, OnChatMessageParticipantImdnStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatMessageParticipantImdnStateChangedDelegatePrivate(IntPtr chatRoom, IntPtr message, IntPtr state);

		/// <summary>
		/// Callback used to notify a participant state has changed in a message of this
		/// chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="message">The LinphoneChatMessage for which a participant has it's
		/// state changed   </param>
		/// <param name="state">The LinphoneParticipantImdnState   </param>
		/// 
		public delegate void OnChatMessageParticipantImdnStateChangedDelegate(Linphone.ChatRoom chatRoom, Linphone.ChatMessage message, Linphone.ParticipantImdnState state);
		private OnChatMessageParticipantImdnStateChangedDelegatePrivate on_chat_message_participant_imdn_state_changed_private;
		private OnChatMessageParticipantImdnStateChangedDelegate on_chat_message_participant_imdn_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatMessageParticipantImdnStateChangedDelegatePrivate))]
#endif
		private static void on_chat_message_participant_imdn_state_changed(IntPtr chatRoom, IntPtr message, IntPtr state)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_chat_message_participant_imdn_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ChatMessage>(message), fromNativePtr<Linphone.ParticipantImdnState>(state));
			}
		}

		public OnChatMessageParticipantImdnStateChangedDelegate OnChatMessageParticipantImdnStateChanged
		{
			get
			{
				return on_chat_message_participant_imdn_state_changed_public;
			}
			set
			{
				on_chat_message_participant_imdn_state_changed_public = value;
#if WINDOWS_UWP
				on_chat_message_participant_imdn_state_changed_private = on_chat_message_participant_imdn_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_message_participant_imdn_state_changed_private);
				linphone_chat_room_cbs_set_chat_message_participant_imdn_state_changed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_chat_message_participant_imdn_state_changed(nativePtr, on_chat_message_participant_imdn_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_conference_joined(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_conference_joined(IntPtr thiz, OnConferenceJoinedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnConferenceJoinedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room has been joined. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnConferenceJoinedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnConferenceJoinedDelegatePrivate on_conference_joined_private;
		private OnConferenceJoinedDelegate on_conference_joined_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnConferenceJoinedDelegatePrivate))]
#endif
		private static void on_conference_joined(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_conference_joined_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnConferenceJoinedDelegate OnConferenceJoined
		{
			get
			{
				return on_conference_joined_public;
			}
			set
			{
				on_conference_joined_public = value;
#if WINDOWS_UWP
				on_conference_joined_private = on_conference_joined;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_conference_joined_private);
				linphone_chat_room_cbs_set_conference_joined(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_conference_joined(nativePtr, on_conference_joined);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_message_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_message_received(IntPtr thiz, OnMessageReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnMessageReceivedDelegatePrivate(IntPtr chatRoom, IntPtr message);

		/// <summary>
		/// Callback used to notify a chat room that a message has been received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="message">The LinphoneChatMessage that has been received   </param>
		/// 
		public delegate void OnMessageReceivedDelegate(Linphone.ChatRoom chatRoom, Linphone.ChatMessage message);
		private OnMessageReceivedDelegatePrivate on_message_received_private;
		private OnMessageReceivedDelegate on_message_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnMessageReceivedDelegatePrivate))]
#endif
		private static void on_message_received(IntPtr chatRoom, IntPtr message)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_message_received_public?.Invoke(thiz, fromNativePtr<Linphone.ChatMessage>(message));
			}
		}

		public OnMessageReceivedDelegate OnMessageReceived
		{
			get
			{
				return on_message_received_public;
			}
			set
			{
				on_message_received_public = value;
#if WINDOWS_UWP
				on_message_received_private = on_message_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_message_received_private);
				linphone_chat_room_cbs_set_message_received(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_message_received(nativePtr, on_message_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_ephemeral_message_deleted(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_ephemeral_message_deleted(IntPtr thiz, OnEphemeralMessageDeletedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEphemeralMessageDeletedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that an ephemeral message has been deleted. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnEphemeralMessageDeletedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnEphemeralMessageDeletedDelegatePrivate on_ephemeral_message_deleted_private;
		private OnEphemeralMessageDeletedDelegate on_ephemeral_message_deleted_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEphemeralMessageDeletedDelegatePrivate))]
#endif
		private static void on_ephemeral_message_deleted(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_ephemeral_message_deleted_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnEphemeralMessageDeletedDelegate OnEphemeralMessageDeleted
		{
			get
			{
				return on_ephemeral_message_deleted_public;
			}
			set
			{
				on_ephemeral_message_deleted_public = value;
#if WINDOWS_UWP
				on_ephemeral_message_deleted_private = on_ephemeral_message_deleted;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ephemeral_message_deleted_private);
				linphone_chat_room_cbs_set_ephemeral_message_deleted(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_ephemeral_message_deleted(nativePtr, on_ephemeral_message_deleted);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_participant_registration_subscription_requested(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_registration_subscription_requested(IntPtr thiz, OnParticipantRegistrationSubscriptionRequestedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantRegistrationSubscriptionRequestedDelegatePrivate(IntPtr chatRoom, IntPtr participantAddress);

		/// <summary>
		/// Callback used when a group chat room server is subscribing to registration
		/// state of a participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="participantAddress">LinphoneAddress object   </param>
		/// 
		public delegate void OnParticipantRegistrationSubscriptionRequestedDelegate(Linphone.ChatRoom chatRoom, Linphone.Address participantAddress);
		private OnParticipantRegistrationSubscriptionRequestedDelegatePrivate on_participant_registration_subscription_requested_private;
		private OnParticipantRegistrationSubscriptionRequestedDelegate on_participant_registration_subscription_requested_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantRegistrationSubscriptionRequestedDelegatePrivate))]
#endif
		private static void on_participant_registration_subscription_requested(IntPtr chatRoom, IntPtr participantAddress)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_registration_subscription_requested_public?.Invoke(thiz, fromNativePtr<Linphone.Address>(participantAddress));
			}
		}

		public OnParticipantRegistrationSubscriptionRequestedDelegate OnParticipantRegistrationSubscriptionRequested
		{
			get
			{
				return on_participant_registration_subscription_requested_public;
			}
			set
			{
				on_participant_registration_subscription_requested_public = value;
#if WINDOWS_UWP
				on_participant_registration_subscription_requested_private = on_participant_registration_subscription_requested;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_registration_subscription_requested_private);
				linphone_chat_room_cbs_set_participant_registration_subscription_requested(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_registration_subscription_requested(nativePtr, on_participant_registration_subscription_requested);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_participant_device_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_device_removed(IntPtr thiz, OnParticipantDeviceRemovedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceRemovedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a participant has been removed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="eventLog">LinphoneEventLog The event to be notified   </param>
		/// 
		public delegate void OnParticipantDeviceRemovedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnParticipantDeviceRemovedDelegatePrivate on_participant_device_removed_private;
		private OnParticipantDeviceRemovedDelegate on_participant_device_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceRemovedDelegatePrivate))]
#endif
		private static void on_participant_device_removed(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_device_removed_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnParticipantDeviceRemovedDelegate OnParticipantDeviceRemoved
		{
			get
			{
				return on_participant_device_removed_public;
			}
			set
			{
				on_participant_device_removed_public = value;
#if WINDOWS_UWP
				on_participant_device_removed_private = on_participant_device_removed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_removed_private);
				linphone_chat_room_cbs_set_participant_device_removed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_device_removed(nativePtr, on_participant_device_removed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_is_composing_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_is_composing_received(IntPtr thiz, OnIsComposingReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsComposingReceivedDelegatePrivate(IntPtr chatRoom, IntPtr remoteAddress, char isComposing);

		/// <summary>
		/// Is composing notification callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom involved in the conversation   </param>
		/// <param name="remoteAddress">The LinphoneAddress that has sent the is-composing
		/// notification   </param>
		/// <param name="isComposing">A boolean value telling whether the remote is
		/// composing or not </param>
		/// 
		public delegate void OnIsComposingReceivedDelegate(Linphone.ChatRoom chatRoom, Linphone.Address remoteAddress, bool isComposing);
		private OnIsComposingReceivedDelegatePrivate on_is_composing_received_private;
		private OnIsComposingReceivedDelegate on_is_composing_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsComposingReceivedDelegatePrivate))]
#endif
		private static void on_is_composing_received(IntPtr chatRoom, IntPtr remoteAddress, char isComposing)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_is_composing_received_public?.Invoke(thiz, fromNativePtr<Linphone.Address>(remoteAddress), isComposing == 0);
			}
		}

		public OnIsComposingReceivedDelegate OnIsComposingReceived
		{
			get
			{
				return on_is_composing_received_public;
			}
			set
			{
				on_is_composing_received_public = value;
#if WINDOWS_UWP
				on_is_composing_received_private = on_is_composing_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_composing_received_private);
				linphone_chat_room_cbs_set_is_composing_received(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_is_composing_received(nativePtr, on_is_composing_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_chat_room_cbs_set_chat_message_should_be_stored(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_chat_message_should_be_stored(IntPtr thiz, OnChatMessageShouldBeStoredDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatMessageShouldBeStoredDelegatePrivate(IntPtr chatRoom, IntPtr message);

		/// <summary>
		/// Callback used to tell the core whether or not to store the incoming message in
		/// db or not using linphone_chat_message_set_to_be_stored. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object   </param>
		/// <param name="message">The LinphoneChatMessage that is being received   </param>
		/// 
		public delegate void OnChatMessageShouldBeStoredDelegate(Linphone.ChatRoom chatRoom, Linphone.ChatMessage message);
		private OnChatMessageShouldBeStoredDelegatePrivate on_chat_message_should_be_stored_private;
		private OnChatMessageShouldBeStoredDelegate on_chat_message_should_be_stored_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatMessageShouldBeStoredDelegatePrivate))]
#endif
		private static void on_chat_message_should_be_stored(IntPtr chatRoom, IntPtr message)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);
			ChatRoomListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_chat_message_should_be_stored_public?.Invoke(thiz, fromNativePtr<Linphone.ChatMessage>(message));
			}
		}

		public OnChatMessageShouldBeStoredDelegate OnChatMessageShouldBeStored
		{
			get
			{
				return on_chat_message_should_be_stored_public;
			}
			set
			{
				on_chat_message_should_be_stored_public = value;
#if WINDOWS_UWP
				on_chat_message_should_be_stored_private = on_chat_message_should_be_stored;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_message_should_be_stored_private);
				linphone_chat_room_cbs_set_chat_message_should_be_stored(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_chat_message_should_be_stored(nativePtr, on_chat_message_should_be_stored);
#endif
			}
		}

		internal void register() {
			IntPtr listener = linphone_chat_room_cbs_get_user_data(nativePtr);
			if (listener == IntPtr.Zero)
			{
				GCHandle _handle = GCHandle.Alloc(this, GCHandleType.Normal);
				listener = GCHandle.ToIntPtr(_handle);
			} else
			{
				GCHandle _handle = GCHandle.FromIntPtr(listener);
				if (_handle.Target == this)
				{
					return;
				} else
				{
					_handle.Free();
					_handle = GCHandle.Alloc(this, GCHandleType.Normal);
					listener = GCHandle.ToIntPtr(_handle);
				}
			}
			linphone_chat_room_cbs_set_user_data(nativePtr, listener);
		}

		internal void unregister() {
			IntPtr listener = linphone_chat_room_cbs_get_user_data(nativePtr);
			linphone_chat_room_cbs_set_user_data(nativePtr, IntPtr.Zero);
			if (listener != IntPtr.Zero)
			{
				GCHandle.FromIntPtr(listener).Free();
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for the handling a LinphoneConference
	/// objects. 
	/// <para>
	/// Use linphone_factory_create_conference_cbs to create an instance. Then pass the
	/// object to a LinphoneConference instance through
	/// linphone_conference_add_callbacks. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ConferenceListener : LinphoneObject
	{
        ~ConferenceListener()
        {
            unregister();
        }

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern void linphone_conference_cbs_set_user_data(IntPtr thiz, IntPtr listener);

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr linphone_conference_cbs_get_user_data(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_conference_cbs_set_participant_device_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_device_removed(IntPtr thiz, OnParticipantDeviceRemovedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceRemovedDelegatePrivate(IntPtr conference, IntPtr participantDevice);

		/// <summary>
		/// Callback used to notify a chat room that a participant has been removed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object   </param>
		/// <param name="participantDevice">LinphoneParticipantDevice that has been removed
		/// to the conference   </param>
		/// 
		public delegate void OnParticipantDeviceRemovedDelegate(Linphone.Conference conference, Linphone.ParticipantDevice participantDevice);
		private OnParticipantDeviceRemovedDelegatePrivate on_participant_device_removed_private;
		private OnParticipantDeviceRemovedDelegate on_participant_device_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceRemovedDelegatePrivate))]
#endif
		private static void on_participant_device_removed(IntPtr conference, IntPtr participantDevice)
		{
			Conference thiz = fromNativePtr<Conference>(conference);
			ConferenceListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_device_removed_public?.Invoke(thiz, fromNativePtr<Linphone.ParticipantDevice>(participantDevice));
			}
		}

		public OnParticipantDeviceRemovedDelegate OnParticipantDeviceRemoved
		{
			get
			{
				return on_participant_device_removed_public;
			}
			set
			{
				on_participant_device_removed_public = value;
#if WINDOWS_UWP
				on_participant_device_removed_private = on_participant_device_removed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_removed_private);
				linphone_conference_cbs_set_participant_device_removed(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_device_removed(nativePtr, on_participant_device_removed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_conference_cbs_set_participant_added(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_added(IntPtr thiz, OnParticipantAddedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantAddedDelegatePrivate(IntPtr conference, IntPtr participant);

		/// <summary>
		/// Callback used to notify a chat room that a participant has been added. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object   </param>
		/// <param name="participant">LinphoneParticipant that has been added to the
		/// conference   </param>
		/// 
		public delegate void OnParticipantAddedDelegate(Linphone.Conference conference, Linphone.Participant participant);
		private OnParticipantAddedDelegatePrivate on_participant_added_private;
		private OnParticipantAddedDelegate on_participant_added_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantAddedDelegatePrivate))]
#endif
		private static void on_participant_added(IntPtr conference, IntPtr participant)
		{
			Conference thiz = fromNativePtr<Conference>(conference);
			ConferenceListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_added_public?.Invoke(thiz, fromNativePtr<Linphone.Participant>(participant));
			}
		}

		public OnParticipantAddedDelegate OnParticipantAdded
		{
			get
			{
				return on_participant_added_public;
			}
			set
			{
				on_participant_added_public = value;
#if WINDOWS_UWP
				on_participant_added_private = on_participant_added;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_added_private);
				linphone_conference_cbs_set_participant_added(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_added(nativePtr, on_participant_added);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_conference_cbs_set_subject_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_subject_changed(IntPtr thiz, OnSubjectChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSubjectChangedDelegatePrivate(IntPtr conference, string subject);

		/// <summary>
		/// Callback used to notify that the subject of a chat room has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object   </param>
		/// <param name="subject">subject of the conference   </param>
		/// 
		public delegate void OnSubjectChangedDelegate(Linphone.Conference conference, string subject);
		private OnSubjectChangedDelegatePrivate on_subject_changed_private;
		private OnSubjectChangedDelegate on_subject_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSubjectChangedDelegatePrivate))]
#endif
		private static void on_subject_changed(IntPtr conference, string subject)
		{
			Conference thiz = fromNativePtr<Conference>(conference);
			ConferenceListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_subject_changed_public?.Invoke(thiz, subject);
			}
		}

		public OnSubjectChangedDelegate OnSubjectChanged
		{
			get
			{
				return on_subject_changed_public;
			}
			set
			{
				on_subject_changed_public = value;
#if WINDOWS_UWP
				on_subject_changed_private = on_subject_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_subject_changed_private);
				linphone_conference_cbs_set_subject_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_subject_changed(nativePtr, on_subject_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_conference_cbs_set_participant_admin_status_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_admin_status_changed(IntPtr thiz, OnParticipantAdminStatusChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantAdminStatusChangedDelegatePrivate(IntPtr conference, IntPtr participant);

		/// <summary>
		/// Callback used to notify a chat room that the admin status of a participant has
		/// been changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object   </param>
		/// <param name="participant">LinphoneParticipant whose admin status has changed  
		/// </param>
		/// 
		public delegate void OnParticipantAdminStatusChangedDelegate(Linphone.Conference conference, Linphone.Participant participant);
		private OnParticipantAdminStatusChangedDelegatePrivate on_participant_admin_status_changed_private;
		private OnParticipantAdminStatusChangedDelegate on_participant_admin_status_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantAdminStatusChangedDelegatePrivate))]
#endif
		private static void on_participant_admin_status_changed(IntPtr conference, IntPtr participant)
		{
			Conference thiz = fromNativePtr<Conference>(conference);
			ConferenceListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_admin_status_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Participant>(participant));
			}
		}

		public OnParticipantAdminStatusChangedDelegate OnParticipantAdminStatusChanged
		{
			get
			{
				return on_participant_admin_status_changed_public;
			}
			set
			{
				on_participant_admin_status_changed_public = value;
#if WINDOWS_UWP
				on_participant_admin_status_changed_private = on_participant_admin_status_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_admin_status_changed_private);
				linphone_conference_cbs_set_participant_admin_status_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_admin_status_changed(nativePtr, on_participant_admin_status_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_conference_cbs_set_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_state_changed(IntPtr thiz, OnStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnStateChangedDelegatePrivate(IntPtr conference, int newState);

		/// <summary>
		/// Callback used to notify a chat room state has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object   </param>
		/// <param name="newState">The new state of the chat room </param>
		/// 
		public delegate void OnStateChangedDelegate(Linphone.Conference conference, Linphone.ConferenceState newState);
		private OnStateChangedDelegatePrivate on_state_changed_private;
		private OnStateChangedDelegate on_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnStateChangedDelegatePrivate))]
#endif
		private static void on_state_changed(IntPtr conference, int newState)
		{
			Conference thiz = fromNativePtr<Conference>(conference);
			ConferenceListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_state_changed_public?.Invoke(thiz, (Linphone.ConferenceState)newState);
			}
		}

		public OnStateChangedDelegate OnStateChanged
		{
			get
			{
				return on_state_changed_public;
			}
			set
			{
				on_state_changed_public = value;
#if WINDOWS_UWP
				on_state_changed_private = on_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_state_changed_private);
				linphone_conference_cbs_set_state_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_state_changed(nativePtr, on_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_conference_cbs_set_participant_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_removed(IntPtr thiz, OnParticipantRemovedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantRemovedDelegatePrivate(IntPtr conference, IntPtr participant);

		/// <summary>
		/// Callback used to notify a chat room that a participant has been removed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object   </param>
		/// <param name="participant">LinphoneParticipant that has been removed to the
		/// conference   </param>
		/// 
		public delegate void OnParticipantRemovedDelegate(Linphone.Conference conference, Linphone.Participant participant);
		private OnParticipantRemovedDelegatePrivate on_participant_removed_private;
		private OnParticipantRemovedDelegate on_participant_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantRemovedDelegatePrivate))]
#endif
		private static void on_participant_removed(IntPtr conference, IntPtr participant)
		{
			Conference thiz = fromNativePtr<Conference>(conference);
			ConferenceListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_removed_public?.Invoke(thiz, fromNativePtr<Linphone.Participant>(participant));
			}
		}

		public OnParticipantRemovedDelegate OnParticipantRemoved
		{
			get
			{
				return on_participant_removed_public;
			}
			set
			{
				on_participant_removed_public = value;
#if WINDOWS_UWP
				on_participant_removed_private = on_participant_removed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_removed_private);
				linphone_conference_cbs_set_participant_removed(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_removed(nativePtr, on_participant_removed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_conference_cbs_set_participant_device_added(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_device_added(IntPtr thiz, OnParticipantDeviceAddedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceAddedDelegatePrivate(IntPtr conference, IntPtr participantDevice);

		/// <summary>
		/// Callback used to notify a chat room that a participant has been added. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object   </param>
		/// <param name="participantDevice">LinphoneParticipantDevice that has been added
		/// to the conference   </param>
		/// 
		public delegate void OnParticipantDeviceAddedDelegate(Linphone.Conference conference, Linphone.ParticipantDevice participantDevice);
		private OnParticipantDeviceAddedDelegatePrivate on_participant_device_added_private;
		private OnParticipantDeviceAddedDelegate on_participant_device_added_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceAddedDelegatePrivate))]
#endif
		private static void on_participant_device_added(IntPtr conference, IntPtr participantDevice)
		{
			Conference thiz = fromNativePtr<Conference>(conference);
			ConferenceListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_participant_device_added_public?.Invoke(thiz, fromNativePtr<Linphone.ParticipantDevice>(participantDevice));
			}
		}

		public OnParticipantDeviceAddedDelegate OnParticipantDeviceAdded
		{
			get
			{
				return on_participant_device_added_public;
			}
			set
			{
				on_participant_device_added_public = value;
#if WINDOWS_UWP
				on_participant_device_added_private = on_participant_device_added;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_added_private);
				linphone_conference_cbs_set_participant_device_added(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_device_added(nativePtr, on_participant_device_added);
#endif
			}
		}

		internal void register() {
			IntPtr listener = linphone_conference_cbs_get_user_data(nativePtr);
			if (listener == IntPtr.Zero)
			{
				GCHandle _handle = GCHandle.Alloc(this, GCHandleType.Normal);
				listener = GCHandle.ToIntPtr(_handle);
			} else
			{
				GCHandle _handle = GCHandle.FromIntPtr(listener);
				if (_handle.Target == this)
				{
					return;
				} else
				{
					_handle.Free();
					_handle = GCHandle.Alloc(this, GCHandleType.Normal);
					listener = GCHandle.ToIntPtr(_handle);
				}
			}
			linphone_conference_cbs_set_user_data(nativePtr, listener);
		}

		internal void unregister() {
			IntPtr listener = linphone_conference_cbs_get_user_data(nativePtr);
			linphone_conference_cbs_set_user_data(nativePtr, IntPtr.Zero);
			if (listener != IntPtr.Zero)
			{
				GCHandle.FromIntPtr(listener).Free();
			}
		}
	}

	/// <summary>
	/// That class holds all the callbacks which are called by LinphoneCore. 
	/// <para>
	/// Once created, add your LinphoneCoreCbs using linphone_core_add_listener. Keep a
	/// reference on it as long as you need it. You can use
	/// linphone_core_remove_listener to remove it but that isn't mandatory.
	/// 
	/// The same applies to all listeners in our API. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class CoreListener : LinphoneObject
	{
        ~CoreListener()
        {
            unregister();
        }

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern void linphone_core_cbs_set_user_data(IntPtr thiz, IntPtr listener);

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr linphone_core_cbs_get_user_data(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_transfer_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_transfer_state_changed(IntPtr thiz, OnTransferStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnTransferStateChangedDelegatePrivate(IntPtr core, IntPtr transfered, int callState);

		/// <summary>
		/// Callback for notifying progresses of transfers. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="transfered">the LinphoneCall that was transfered   </param>
		/// <param name="callState">the LinphoneCallState of the call to transfer target at
		/// the far end. </param>
		/// 
		public delegate void OnTransferStateChangedDelegate(Linphone.Core core, Linphone.Call transfered, Linphone.CallState callState);
		private OnTransferStateChangedDelegatePrivate on_transfer_state_changed_private;
		private OnTransferStateChangedDelegate on_transfer_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnTransferStateChangedDelegatePrivate))]
#endif
		private static void on_transfer_state_changed(IntPtr core, IntPtr transfered, int callState)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_transfer_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(transfered), (Linphone.CallState)callState);
			}
		}

		public OnTransferStateChangedDelegate OnTransferStateChanged
		{
			get
			{
				return on_transfer_state_changed_public;
			}
			set
			{
				on_transfer_state_changed_public = value;
#if WINDOWS_UWP
				on_transfer_state_changed_private = on_transfer_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_transfer_state_changed_private);
				linphone_core_cbs_set_transfer_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_transfer_state_changed(nativePtr, on_transfer_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_friend_list_created(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_friend_list_created(IntPtr thiz, OnFriendListCreatedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFriendListCreatedDelegatePrivate(IntPtr core, IntPtr friendList);

		/// <summary>
		/// Callback prototype for reporting when a friend list has been added to the core
		/// friends list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="friendList">LinphoneFriendList object   </param>
		/// 
		public delegate void OnFriendListCreatedDelegate(Linphone.Core core, Linphone.FriendList friendList);
		private OnFriendListCreatedDelegatePrivate on_friend_list_created_private;
		private OnFriendListCreatedDelegate on_friend_list_created_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFriendListCreatedDelegatePrivate))]
#endif
		private static void on_friend_list_created(IntPtr core, IntPtr friendList)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_friend_list_created_public?.Invoke(thiz, fromNativePtr<Linphone.FriendList>(friendList));
			}
		}

		public OnFriendListCreatedDelegate OnFriendListCreated
		{
			get
			{
				return on_friend_list_created_public;
			}
			set
			{
				on_friend_list_created_public = value;
#if WINDOWS_UWP
				on_friend_list_created_private = on_friend_list_created;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_friend_list_created_private);
				linphone_core_cbs_set_friend_list_created(nativePtr, cb);
#else
				linphone_core_cbs_set_friend_list_created(nativePtr, on_friend_list_created);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_subscription_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_subscription_state_changed(IntPtr thiz, OnSubscriptionStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSubscriptionStateChangedDelegatePrivate(IntPtr core, IntPtr linphoneEvent, int state);

		/// <summary>
		/// Callback prototype for notifying the application about changes of subscription
		/// states, including arrival of new subscriptions. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="linphoneEvent">the LinphoneEvent   </param>
		/// <param name="state">the new LinphoneSubscriptionState </param>
		/// 
		public delegate void OnSubscriptionStateChangedDelegate(Linphone.Core core, Linphone.Event linphoneEvent, Linphone.SubscriptionState state);
		private OnSubscriptionStateChangedDelegatePrivate on_subscription_state_changed_private;
		private OnSubscriptionStateChangedDelegate on_subscription_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSubscriptionStateChangedDelegatePrivate))]
#endif
		private static void on_subscription_state_changed(IntPtr core, IntPtr linphoneEvent, int state)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_subscription_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Event>(linphoneEvent), (Linphone.SubscriptionState)state);
			}
		}

		public OnSubscriptionStateChangedDelegate OnSubscriptionStateChanged
		{
			get
			{
				return on_subscription_state_changed_public;
			}
			set
			{
				on_subscription_state_changed_public = value;
#if WINDOWS_UWP
				on_subscription_state_changed_private = on_subscription_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_subscription_state_changed_private);
				linphone_core_cbs_set_subscription_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_subscription_state_changed(nativePtr, on_subscription_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_call_log_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_log_updated(IntPtr thiz, OnCallLogUpdatedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallLogUpdatedDelegatePrivate(IntPtr core, IntPtr callLog);

		/// <summary>
		/// Callback to notify a new call-log entry has been added. 
		/// <para>
		/// This is done typically when a call terminates. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="callLog">the new LinphoneCallLog entry added.   </param>
		/// 
		public delegate void OnCallLogUpdatedDelegate(Linphone.Core core, Linphone.CallLog callLog);
		private OnCallLogUpdatedDelegatePrivate on_call_log_updated_private;
		private OnCallLogUpdatedDelegate on_call_log_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallLogUpdatedDelegatePrivate))]
#endif
		private static void on_call_log_updated(IntPtr core, IntPtr callLog)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_call_log_updated_public?.Invoke(thiz, fromNativePtr<Linphone.CallLog>(callLog));
			}
		}

		public OnCallLogUpdatedDelegate OnCallLogUpdated
		{
			get
			{
				return on_call_log_updated_public;
			}
			set
			{
				on_call_log_updated_public = value;
#if WINDOWS_UWP
				on_call_log_updated_private = on_call_log_updated;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_log_updated_private);
				linphone_core_cbs_set_call_log_updated(nativePtr, cb);
#else
				linphone_core_cbs_set_call_log_updated(nativePtr, on_call_log_updated);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_chat_room_subject_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_chat_room_subject_changed(IntPtr thiz, OnChatRoomSubjectChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatRoomSubjectChangedDelegatePrivate(IntPtr core, IntPtr chatRoom);

		/// <summary>
		/// Callback prototype telling that a LinphoneChatRoom subject has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="chatRoom">The LinphoneChatRoom object for which the subject has
		/// changed   </param>
		/// 
		public delegate void OnChatRoomSubjectChangedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom);
		private OnChatRoomSubjectChangedDelegatePrivate on_chat_room_subject_changed_private;
		private OnChatRoomSubjectChangedDelegate on_chat_room_subject_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatRoomSubjectChangedDelegatePrivate))]
#endif
		private static void on_chat_room_subject_changed(IntPtr core, IntPtr chatRoom)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_chat_room_subject_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom));
			}
		}

		public OnChatRoomSubjectChangedDelegate OnChatRoomSubjectChanged
		{
			get
			{
				return on_chat_room_subject_changed_public;
			}
			set
			{
				on_chat_room_subject_changed_public = value;
#if WINDOWS_UWP
				on_chat_room_subject_changed_private = on_chat_room_subject_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_room_subject_changed_private);
				linphone_core_cbs_set_chat_room_subject_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_chat_room_subject_changed(nativePtr, on_chat_room_subject_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_call_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_state_changed(IntPtr thiz, OnCallStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallStateChangedDelegatePrivate(IntPtr core, IntPtr call, int state, string message);

		/// <summary>
		/// Call state notification callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="call">the LinphoneCall object whose state is changed.   </param>
		/// <param name="state">the new LinphoneCallState of the call </param>
		/// <param name="message">a non null informational message about the state.  
		/// </param>
		/// 
		public delegate void OnCallStateChangedDelegate(Linphone.Core core, Linphone.Call call, Linphone.CallState state, string message);
		private OnCallStateChangedDelegatePrivate on_call_state_changed_private;
		private OnCallStateChangedDelegate on_call_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallStateChangedDelegatePrivate))]
#endif
		private static void on_call_state_changed(IntPtr core, IntPtr call, int state, string message)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_call_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call), (Linphone.CallState)state, message);
			}
		}

		public OnCallStateChangedDelegate OnCallStateChanged
		{
			get
			{
				return on_call_state_changed_public;
			}
			set
			{
				on_call_state_changed_public = value;
#if WINDOWS_UWP
				on_call_state_changed_private = on_call_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_state_changed_private);
				linphone_core_cbs_set_call_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_call_state_changed(nativePtr, on_call_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_authentication_requested(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_authentication_requested(IntPtr thiz, OnAuthenticationRequestedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAuthenticationRequestedDelegatePrivate(IntPtr core, IntPtr authInfo, int method);

		/// <summary>
		/// Callback for requesting authentication information to application or user. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="authInfo">a LinphoneAuthInfo pre-filled with username, realm and
		/// domain values as much as possible   </param>
		/// <param name="method">the type of authentication requested as LinphoneAuthMethod
		/// enum   Application shall reply to this callback using
		/// linphone_core_add_auth_info. </param>
		/// 
		public delegate void OnAuthenticationRequestedDelegate(Linphone.Core core, Linphone.AuthInfo authInfo, Linphone.AuthMethod method);
		private OnAuthenticationRequestedDelegatePrivate on_authentication_requested_private;
		private OnAuthenticationRequestedDelegate on_authentication_requested_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAuthenticationRequestedDelegatePrivate))]
#endif
		private static void on_authentication_requested(IntPtr core, IntPtr authInfo, int method)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_authentication_requested_public?.Invoke(thiz, fromNativePtr<Linphone.AuthInfo>(authInfo), (Linphone.AuthMethod)method);
			}
		}

		public OnAuthenticationRequestedDelegate OnAuthenticationRequested
		{
			get
			{
				return on_authentication_requested_public;
			}
			set
			{
				on_authentication_requested_public = value;
#if WINDOWS_UWP
				on_authentication_requested_private = on_authentication_requested;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_authentication_requested_private);
				linphone_core_cbs_set_authentication_requested(nativePtr, cb);
#else
				linphone_core_cbs_set_authentication_requested(nativePtr, on_authentication_requested);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_notify_presence_received_for_uri_or_tel(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_notify_presence_received_for_uri_or_tel(IntPtr thiz, OnNotifyPresenceReceivedForUriOrTelDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNotifyPresenceReceivedForUriOrTelDelegatePrivate(IntPtr core, IntPtr linphoneFriend, string uriOrTel, IntPtr presenceModel);

		/// <summary>
		/// Reports presence model change for a specific URI or phone number of a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="linphoneFriend">LinphoneFriend object   </param>
		/// <param name="uriOrTel">The URI or phone number for which the presence model has
		/// changed   </param>
		/// <param name="presenceModel">The new LinphonePresenceModel   </param>
		/// 
		public delegate void OnNotifyPresenceReceivedForUriOrTelDelegate(Linphone.Core core, Linphone.Friend linphoneFriend, string uriOrTel, Linphone.PresenceModel presenceModel);
		private OnNotifyPresenceReceivedForUriOrTelDelegatePrivate on_notify_presence_received_for_uri_or_tel_private;
		private OnNotifyPresenceReceivedForUriOrTelDelegate on_notify_presence_received_for_uri_or_tel_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNotifyPresenceReceivedForUriOrTelDelegatePrivate))]
#endif
		private static void on_notify_presence_received_for_uri_or_tel(IntPtr core, IntPtr linphoneFriend, string uriOrTel, IntPtr presenceModel)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_notify_presence_received_for_uri_or_tel_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(linphoneFriend), uriOrTel, fromNativePtr<Linphone.PresenceModel>(presenceModel));
			}
		}

		public OnNotifyPresenceReceivedForUriOrTelDelegate OnNotifyPresenceReceivedForUriOrTel
		{
			get
			{
				return on_notify_presence_received_for_uri_or_tel_public;
			}
			set
			{
				on_notify_presence_received_for_uri_or_tel_public = value;
#if WINDOWS_UWP
				on_notify_presence_received_for_uri_or_tel_private = on_notify_presence_received_for_uri_or_tel;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_notify_presence_received_for_uri_or_tel_private);
				linphone_core_cbs_set_notify_presence_received_for_uri_or_tel(nativePtr, cb);
#else
				linphone_core_cbs_set_notify_presence_received_for_uri_or_tel(nativePtr, on_notify_presence_received_for_uri_or_tel);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_chat_room_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_chat_room_state_changed(IntPtr thiz, OnChatRoomStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatRoomStateChangedDelegatePrivate(IntPtr core, IntPtr chatRoom, int state);

		/// <summary>
		/// Callback prototype telling that a LinphoneChatRoom state has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="chatRoom">The LinphoneChatRoom object for which the state has
		/// changed   </param>
		/// <param name="state">the current LinphoneChatRoomState </param>
		/// 
		public delegate void OnChatRoomStateChangedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom, Linphone.ChatRoomState state);
		private OnChatRoomStateChangedDelegatePrivate on_chat_room_state_changed_private;
		private OnChatRoomStateChangedDelegate on_chat_room_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatRoomStateChangedDelegatePrivate))]
#endif
		private static void on_chat_room_state_changed(IntPtr core, IntPtr chatRoom, int state)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_chat_room_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom), (Linphone.ChatRoomState)state);
			}
		}

		public OnChatRoomStateChangedDelegate OnChatRoomStateChanged
		{
			get
			{
				return on_chat_room_state_changed_public;
			}
			set
			{
				on_chat_room_state_changed_public = value;
#if WINDOWS_UWP
				on_chat_room_state_changed_private = on_chat_room_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_room_state_changed_private);
				linphone_core_cbs_set_chat_room_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_chat_room_state_changed(nativePtr, on_chat_room_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_buddy_info_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_buddy_info_updated(IntPtr thiz, OnBuddyInfoUpdatedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnBuddyInfoUpdatedDelegatePrivate(IntPtr core, IntPtr linphoneFriend);

		/// <summary>
		/// Callback prototype when using the buddy plugin. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="linphoneFriend">the LinphoneFriend that has been updated   </param>
		/// 
		public delegate void OnBuddyInfoUpdatedDelegate(Linphone.Core core, Linphone.Friend linphoneFriend);
		private OnBuddyInfoUpdatedDelegatePrivate on_buddy_info_updated_private;
		private OnBuddyInfoUpdatedDelegate on_buddy_info_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnBuddyInfoUpdatedDelegatePrivate))]
#endif
		private static void on_buddy_info_updated(IntPtr core, IntPtr linphoneFriend)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_buddy_info_updated_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(linphoneFriend));
			}
		}

		public OnBuddyInfoUpdatedDelegate OnBuddyInfoUpdated
		{
			get
			{
				return on_buddy_info_updated_public;
			}
			set
			{
				on_buddy_info_updated_public = value;
#if WINDOWS_UWP
				on_buddy_info_updated_private = on_buddy_info_updated;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_buddy_info_updated_private);
				linphone_core_cbs_set_buddy_info_updated(nativePtr, cb);
#else
				linphone_core_cbs_set_buddy_info_updated(nativePtr, on_buddy_info_updated);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_network_reachable(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_network_reachable(IntPtr thiz, OnNetworkReachableDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNetworkReachableDelegatePrivate(IntPtr core, char reachable);

		/// <summary>
		/// Callback prototype for reporting network change either automatically detected
		/// or notified by linphone_core_set_network_reachable. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="reachable">true if network is reachable. </param>
		/// 
		public delegate void OnNetworkReachableDelegate(Linphone.Core core, bool reachable);
		private OnNetworkReachableDelegatePrivate on_network_reachable_private;
		private OnNetworkReachableDelegate on_network_reachable_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNetworkReachableDelegatePrivate))]
#endif
		private static void on_network_reachable(IntPtr core, char reachable)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_network_reachable_public?.Invoke(thiz, reachable == 0);
			}
		}

		public OnNetworkReachableDelegate OnNetworkReachable
		{
			get
			{
				return on_network_reachable_public;
			}
			set
			{
				on_network_reachable_public = value;
#if WINDOWS_UWP
				on_network_reachable_private = on_network_reachable;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_network_reachable_private);
				linphone_core_cbs_set_network_reachable(nativePtr, cb);
#else
				linphone_core_cbs_set_network_reachable(nativePtr, on_network_reachable);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_notify_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_notify_received(IntPtr thiz, OnNotifyReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNotifyReceivedDelegatePrivate(IntPtr core, IntPtr linphoneEvent, string notifiedEvent, IntPtr body);

		/// <summary>
		/// Callback prototype for notifying the application about notification received
		/// from the network. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="linphoneEvent">the LinphoneEvent received   </param>
		/// <param name="notifiedEvent">The event as string   </param>
		/// <param name="body">the LinphoneContent of the event   </param>
		/// 
		public delegate void OnNotifyReceivedDelegate(Linphone.Core core, Linphone.Event linphoneEvent, string notifiedEvent, Linphone.Content body);
		private OnNotifyReceivedDelegatePrivate on_notify_received_private;
		private OnNotifyReceivedDelegate on_notify_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNotifyReceivedDelegatePrivate))]
#endif
		private static void on_notify_received(IntPtr core, IntPtr linphoneEvent, string notifiedEvent, IntPtr body)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_notify_received_public?.Invoke(thiz, fromNativePtr<Linphone.Event>(linphoneEvent), notifiedEvent, fromNativePtr<Linphone.Content>(body));
			}
		}

		public OnNotifyReceivedDelegate OnNotifyReceived
		{
			get
			{
				return on_notify_received_public;
			}
			set
			{
				on_notify_received_public = value;
#if WINDOWS_UWP
				on_notify_received_private = on_notify_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_notify_received_private);
				linphone_core_cbs_set_notify_received(nativePtr, cb);
#else
				linphone_core_cbs_set_notify_received(nativePtr, on_notify_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_new_subscription_requested(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_new_subscription_requested(IntPtr thiz, OnNewSubscriptionRequestedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNewSubscriptionRequestedDelegatePrivate(IntPtr core, IntPtr linphoneFriend, string url);

		/// <summary>
		/// Reports that a new subscription request has been received and wait for a
		/// decision. 
		/// <para>
		/// Status on this subscription request is notified by changing policy  for this
		/// friend 
		/// 
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="linphoneFriend">LinphoneFriend corresponding to the subscriber  
		/// </param>
		/// <param name="url">of the subscriber   </param>
		/// 
		public delegate void OnNewSubscriptionRequestedDelegate(Linphone.Core core, Linphone.Friend linphoneFriend, string url);
		private OnNewSubscriptionRequestedDelegatePrivate on_new_subscription_requested_private;
		private OnNewSubscriptionRequestedDelegate on_new_subscription_requested_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNewSubscriptionRequestedDelegatePrivate))]
#endif
		private static void on_new_subscription_requested(IntPtr core, IntPtr linphoneFriend, string url)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_new_subscription_requested_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(linphoneFriend), url);
			}
		}

		public OnNewSubscriptionRequestedDelegate OnNewSubscriptionRequested
		{
			get
			{
				return on_new_subscription_requested_public;
			}
			set
			{
				on_new_subscription_requested_public = value;
#if WINDOWS_UWP
				on_new_subscription_requested_private = on_new_subscription_requested;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_new_subscription_requested_private);
				linphone_core_cbs_set_new_subscription_requested(nativePtr, cb);
#else
				linphone_core_cbs_set_new_subscription_requested(nativePtr, on_new_subscription_requested);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_call_stats_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_stats_updated(IntPtr thiz, OnCallStatsUpdatedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallStatsUpdatedDelegatePrivate(IntPtr core, IntPtr call, IntPtr callStats);

		/// <summary>
		/// Callback for receiving quality statistics for calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="call">the call   </param>
		/// <param name="callStats">the call statistics.   </param>
		/// 
		public delegate void OnCallStatsUpdatedDelegate(Linphone.Core core, Linphone.Call call, Linphone.CallStats callStats);
		private OnCallStatsUpdatedDelegatePrivate on_call_stats_updated_private;
		private OnCallStatsUpdatedDelegate on_call_stats_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallStatsUpdatedDelegatePrivate))]
#endif
		private static void on_call_stats_updated(IntPtr core, IntPtr call, IntPtr callStats)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_call_stats_updated_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call), fromNativePtr<Linphone.CallStats>(callStats));
			}
		}

		public OnCallStatsUpdatedDelegate OnCallStatsUpdated
		{
			get
			{
				return on_call_stats_updated_public;
			}
			set
			{
				on_call_stats_updated_public = value;
#if WINDOWS_UWP
				on_call_stats_updated_private = on_call_stats_updated;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_stats_updated_private);
				linphone_core_cbs_set_call_stats_updated(nativePtr, cb);
#else
				linphone_core_cbs_set_call_stats_updated(nativePtr, on_call_stats_updated);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_notify_presence_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_notify_presence_received(IntPtr thiz, OnNotifyPresenceReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNotifyPresenceReceivedDelegatePrivate(IntPtr core, IntPtr linphoneFriend);

		/// <summary>
		/// Report status change for a friend previously added  to LinphoneCore. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="linphoneFriend">Updated LinphoneFriend   </param>
		/// 
		public delegate void OnNotifyPresenceReceivedDelegate(Linphone.Core core, Linphone.Friend linphoneFriend);
		private OnNotifyPresenceReceivedDelegatePrivate on_notify_presence_received_private;
		private OnNotifyPresenceReceivedDelegate on_notify_presence_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNotifyPresenceReceivedDelegatePrivate))]
#endif
		private static void on_notify_presence_received(IntPtr core, IntPtr linphoneFriend)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_notify_presence_received_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(linphoneFriend));
			}
		}

		public OnNotifyPresenceReceivedDelegate OnNotifyPresenceReceived
		{
			get
			{
				return on_notify_presence_received_public;
			}
			set
			{
				on_notify_presence_received_public = value;
#if WINDOWS_UWP
				on_notify_presence_received_private = on_notify_presence_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_notify_presence_received_private);
				linphone_core_cbs_set_notify_presence_received(nativePtr, cb);
#else
				linphone_core_cbs_set_notify_presence_received(nativePtr, on_notify_presence_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_audio_device_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_audio_device_changed(IntPtr thiz, OnAudioDeviceChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAudioDeviceChangedDelegatePrivate(IntPtr core, IntPtr audioDevice);

		/// <summary>
		/// Callback prototype telling that the audio device for at least one call has
		/// changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="audioDevice">the newly used LinphoneAudioDevice object   </param>
		/// 
		public delegate void OnAudioDeviceChangedDelegate(Linphone.Core core, Linphone.AudioDevice audioDevice);
		private OnAudioDeviceChangedDelegatePrivate on_audio_device_changed_private;
		private OnAudioDeviceChangedDelegate on_audio_device_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAudioDeviceChangedDelegatePrivate))]
#endif
		private static void on_audio_device_changed(IntPtr core, IntPtr audioDevice)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_audio_device_changed_public?.Invoke(thiz, fromNativePtr<Linphone.AudioDevice>(audioDevice));
			}
		}

		public OnAudioDeviceChangedDelegate OnAudioDeviceChanged
		{
			get
			{
				return on_audio_device_changed_public;
			}
			set
			{
				on_audio_device_changed_public = value;
#if WINDOWS_UWP
				on_audio_device_changed_private = on_audio_device_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_audio_device_changed_private);
				linphone_core_cbs_set_audio_device_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_audio_device_changed(nativePtr, on_audio_device_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_ec_calibration_audio_init(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_ec_calibration_audio_init(IntPtr thiz, OnEcCalibrationAudioInitDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEcCalibrationAudioInitDelegatePrivate(IntPtr core);

		/// <summary>
		/// Function prototype used by #linphone_core_cbs_set_ec_calibrator_audio_init(). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">The LinphoneCore.   </param>
		/// 
		public delegate void OnEcCalibrationAudioInitDelegate(Linphone.Core core);
		private OnEcCalibrationAudioInitDelegatePrivate on_ec_calibration_audio_init_private;
		private OnEcCalibrationAudioInitDelegate on_ec_calibration_audio_init_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEcCalibrationAudioInitDelegatePrivate))]
#endif
		private static void on_ec_calibration_audio_init(IntPtr core)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_ec_calibration_audio_init_public?.Invoke(thiz);
			}
		}

		public OnEcCalibrationAudioInitDelegate OnEcCalibrationAudioInit
		{
			get
			{
				return on_ec_calibration_audio_init_public;
			}
			set
			{
				on_ec_calibration_audio_init_public = value;
#if WINDOWS_UWP
				on_ec_calibration_audio_init_private = on_ec_calibration_audio_init;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ec_calibration_audio_init_private);
				linphone_core_cbs_set_ec_calibration_audio_init(nativePtr, cb);
#else
				linphone_core_cbs_set_ec_calibration_audio_init(nativePtr, on_ec_calibration_audio_init);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_message_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_message_received(IntPtr thiz, OnMessageReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnMessageReceivedDelegatePrivate(IntPtr core, IntPtr chatRoom, IntPtr message);

		/// <summary>
		/// Chat message callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="chatRoom">LinphoneChatRoom involved in this conversation. Can be
		/// be created by the framework in case the from  is not present in any chat room. 
		///  </param>
		/// <param name="message">LinphoneChatMessage incoming message   </param>
		/// 
		public delegate void OnMessageReceivedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom, Linphone.ChatMessage message);
		private OnMessageReceivedDelegatePrivate on_message_received_private;
		private OnMessageReceivedDelegate on_message_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnMessageReceivedDelegatePrivate))]
#endif
		private static void on_message_received(IntPtr core, IntPtr chatRoom, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_message_received_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom), fromNativePtr<Linphone.ChatMessage>(message));
			}
		}

		public OnMessageReceivedDelegate OnMessageReceived
		{
			get
			{
				return on_message_received_public;
			}
			set
			{
				on_message_received_public = value;
#if WINDOWS_UWP
				on_message_received_private = on_message_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_message_received_private);
				linphone_core_cbs_set_message_received(nativePtr, cb);
#else
				linphone_core_cbs_set_message_received(nativePtr, on_message_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_ec_calibration_result(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_ec_calibration_result(IntPtr thiz, OnEcCalibrationResultDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEcCalibrationResultDelegatePrivate(IntPtr core, int status, int delayMs);

		/// <summary>
		/// Function prototype used by #linphone_core_cbs_set_ec_calibrator_result(). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">The LinphoneCore.   </param>
		/// <param name="status">The LinphoneEcCalibratorStatus of the calibrator. </param>
		/// <param name="delayMs">The measured delay if available. </param>
		/// 
		public delegate void OnEcCalibrationResultDelegate(Linphone.Core core, Linphone.EcCalibratorStatus status, int delayMs);
		private OnEcCalibrationResultDelegatePrivate on_ec_calibration_result_private;
		private OnEcCalibrationResultDelegate on_ec_calibration_result_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEcCalibrationResultDelegatePrivate))]
#endif
		private static void on_ec_calibration_result(IntPtr core, int status, int delayMs)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_ec_calibration_result_public?.Invoke(thiz, (Linphone.EcCalibratorStatus)status, delayMs);
			}
		}

		public OnEcCalibrationResultDelegate OnEcCalibrationResult
		{
			get
			{
				return on_ec_calibration_result_public;
			}
			set
			{
				on_ec_calibration_result_public = value;
#if WINDOWS_UWP
				on_ec_calibration_result_private = on_ec_calibration_result;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ec_calibration_result_private);
				linphone_core_cbs_set_ec_calibration_result(nativePtr, cb);
#else
				linphone_core_cbs_set_ec_calibration_result(nativePtr, on_ec_calibration_result);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_subscribe_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_subscribe_received(IntPtr thiz, OnSubscribeReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSubscribeReceivedDelegatePrivate(IntPtr core, IntPtr linphoneEvent, string subscribeEvent, IntPtr body);

		/// <summary>
		/// Callback prototype for notifying the application about subscription received
		/// from the network. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="linphoneEvent">the LinphoneEvent received   </param>
		/// <param name="subscribeEvent">The event as string   </param>
		/// <param name="body">the LinphoneContent of the event   </param>
		/// 
		public delegate void OnSubscribeReceivedDelegate(Linphone.Core core, Linphone.Event linphoneEvent, string subscribeEvent, Linphone.Content body);
		private OnSubscribeReceivedDelegatePrivate on_subscribe_received_private;
		private OnSubscribeReceivedDelegate on_subscribe_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSubscribeReceivedDelegatePrivate))]
#endif
		private static void on_subscribe_received(IntPtr core, IntPtr linphoneEvent, string subscribeEvent, IntPtr body)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_subscribe_received_public?.Invoke(thiz, fromNativePtr<Linphone.Event>(linphoneEvent), subscribeEvent, fromNativePtr<Linphone.Content>(body));
			}
		}

		public OnSubscribeReceivedDelegate OnSubscribeReceived
		{
			get
			{
				return on_subscribe_received_public;
			}
			set
			{
				on_subscribe_received_public = value;
#if WINDOWS_UWP
				on_subscribe_received_private = on_subscribe_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_subscribe_received_private);
				linphone_core_cbs_set_subscribe_received(nativePtr, cb);
#else
				linphone_core_cbs_set_subscribe_received(nativePtr, on_subscribe_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_info_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_info_received(IntPtr thiz, OnInfoReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnInfoReceivedDelegatePrivate(IntPtr core, IntPtr call, IntPtr message);

		/// <summary>
		/// Callback prototype for receiving info messages. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="call">the call whose info message belongs to.   </param>
		/// <param name="message">the info message.   </param>
		/// 
		public delegate void OnInfoReceivedDelegate(Linphone.Core core, Linphone.Call call, Linphone.InfoMessage message);
		private OnInfoReceivedDelegatePrivate on_info_received_private;
		private OnInfoReceivedDelegate on_info_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnInfoReceivedDelegatePrivate))]
#endif
		private static void on_info_received(IntPtr core, IntPtr call, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_info_received_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call), fromNativePtr<Linphone.InfoMessage>(message));
			}
		}

		public OnInfoReceivedDelegate OnInfoReceived
		{
			get
			{
				return on_info_received_public;
			}
			set
			{
				on_info_received_public = value;
#if WINDOWS_UWP
				on_info_received_private = on_info_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_info_received_private);
				linphone_core_cbs_set_info_received(nativePtr, cb);
#else
				linphone_core_cbs_set_info_received(nativePtr, on_info_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_chat_room_read(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_chat_room_read(IntPtr thiz, OnChatRoomReadDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatRoomReadDelegatePrivate(IntPtr core, IntPtr chatRoom);

		/// <summary>
		/// Chat room marked as read callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="chatRoom">LinphoneChatRoom that has been marked as read.   </param>
		/// 
		public delegate void OnChatRoomReadDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom);
		private OnChatRoomReadDelegatePrivate on_chat_room_read_private;
		private OnChatRoomReadDelegate on_chat_room_read_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatRoomReadDelegatePrivate))]
#endif
		private static void on_chat_room_read(IntPtr core, IntPtr chatRoom)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_chat_room_read_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom));
			}
		}

		public OnChatRoomReadDelegate OnChatRoomRead
		{
			get
			{
				return on_chat_room_read_public;
			}
			set
			{
				on_chat_room_read_public = value;
#if WINDOWS_UWP
				on_chat_room_read_private = on_chat_room_read;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_room_read_private);
				linphone_core_cbs_set_chat_room_read(nativePtr, cb);
#else
				linphone_core_cbs_set_chat_room_read(nativePtr, on_chat_room_read);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_registration_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_registration_state_changed(IntPtr thiz, OnRegistrationStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnRegistrationStateChangedDelegatePrivate(IntPtr core, IntPtr proxyConfig, int state, string message);

		/// <summary>
		/// Registration state notification callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="proxyConfig">the LinphoneProxyConfig which state has changed  
		/// </param>
		/// <param name="state">the current LinphoneRegistrationState </param>
		/// <param name="message">a non null informational message about the state  
		/// </param>
		/// 
		public delegate void OnRegistrationStateChangedDelegate(Linphone.Core core, Linphone.ProxyConfig proxyConfig, Linphone.RegistrationState state, string message);
		private OnRegistrationStateChangedDelegatePrivate on_registration_state_changed_private;
		private OnRegistrationStateChangedDelegate on_registration_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnRegistrationStateChangedDelegatePrivate))]
#endif
		private static void on_registration_state_changed(IntPtr core, IntPtr proxyConfig, int state, string message)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_registration_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ProxyConfig>(proxyConfig), (Linphone.RegistrationState)state, message);
			}
		}

		public OnRegistrationStateChangedDelegate OnRegistrationStateChanged
		{
			get
			{
				return on_registration_state_changed_public;
			}
			set
			{
				on_registration_state_changed_public = value;
#if WINDOWS_UWP
				on_registration_state_changed_private = on_registration_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_registration_state_changed_private);
				linphone_core_cbs_set_registration_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_registration_state_changed(nativePtr, on_registration_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_imee_user_registration(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_imee_user_registration(IntPtr thiz, OnImeeUserRegistrationDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnImeeUserRegistrationDelegatePrivate(IntPtr core, char status, string userId, string info);

		/// <summary>
		/// Callback prototype telling that an Instant Message Encryption Engine user
		/// registered on the server with or without success. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="status">the return status of the registration action. </param>
		/// <param name="userId">the userId published on the encryption engine server  
		/// </param>
		/// <param name="info">information about failure   </param>
		/// 
		public delegate void OnImeeUserRegistrationDelegate(Linphone.Core core, bool status, string userId, string info);
		private OnImeeUserRegistrationDelegatePrivate on_imee_user_registration_private;
		private OnImeeUserRegistrationDelegate on_imee_user_registration_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnImeeUserRegistrationDelegatePrivate))]
#endif
		private static void on_imee_user_registration(IntPtr core, char status, string userId, string info)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_imee_user_registration_public?.Invoke(thiz, status == 0, userId, info);
			}
		}

		public OnImeeUserRegistrationDelegate OnImeeUserRegistration
		{
			get
			{
				return on_imee_user_registration_public;
			}
			set
			{
				on_imee_user_registration_public = value;
#if WINDOWS_UWP
				on_imee_user_registration_private = on_imee_user_registration;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_imee_user_registration_private);
				linphone_core_cbs_set_imee_user_registration(nativePtr, cb);
#else
				linphone_core_cbs_set_imee_user_registration(nativePtr, on_imee_user_registration);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_friend_list_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_friend_list_removed(IntPtr thiz, OnFriendListRemovedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFriendListRemovedDelegatePrivate(IntPtr core, IntPtr friendList);

		/// <summary>
		/// Callback prototype for reporting when a friend list has been removed from the
		/// core friends list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="friendList">LinphoneFriendList object   </param>
		/// 
		public delegate void OnFriendListRemovedDelegate(Linphone.Core core, Linphone.FriendList friendList);
		private OnFriendListRemovedDelegatePrivate on_friend_list_removed_private;
		private OnFriendListRemovedDelegate on_friend_list_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFriendListRemovedDelegatePrivate))]
#endif
		private static void on_friend_list_removed(IntPtr core, IntPtr friendList)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_friend_list_removed_public?.Invoke(thiz, fromNativePtr<Linphone.FriendList>(friendList));
			}
		}

		public OnFriendListRemovedDelegate OnFriendListRemoved
		{
			get
			{
				return on_friend_list_removed_public;
			}
			set
			{
				on_friend_list_removed_public = value;
#if WINDOWS_UWP
				on_friend_list_removed_private = on_friend_list_removed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_friend_list_removed_private);
				linphone_core_cbs_set_friend_list_removed(nativePtr, cb);
#else
				linphone_core_cbs_set_friend_list_removed(nativePtr, on_friend_list_removed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_refer_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_refer_received(IntPtr thiz, OnReferReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnReferReceivedDelegatePrivate(IntPtr core, string referTo);

		/// <summary>
		/// Callback prototype for when a refer is received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="referTo">the address of the refer   </param>
		/// 
		public delegate void OnReferReceivedDelegate(Linphone.Core core, string referTo);
		private OnReferReceivedDelegatePrivate on_refer_received_private;
		private OnReferReceivedDelegate on_refer_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnReferReceivedDelegatePrivate))]
#endif
		private static void on_refer_received(IntPtr core, string referTo)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_refer_received_public?.Invoke(thiz, referTo);
			}
		}

		public OnReferReceivedDelegate OnReferReceived
		{
			get
			{
				return on_refer_received_public;
			}
			set
			{
				on_refer_received_public = value;
#if WINDOWS_UWP
				on_refer_received_private = on_refer_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_refer_received_private);
				linphone_core_cbs_set_refer_received(nativePtr, cb);
#else
				linphone_core_cbs_set_refer_received(nativePtr, on_refer_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_qrcode_found(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_qrcode_found(IntPtr thiz, OnQrcodeFoundDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnQrcodeFoundDelegatePrivate(IntPtr core, string result);

		/// <summary>
		/// Callback prototype telling the result of decoded qrcode. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="result">The result of the decoded qrcode   </param>
		/// 
		public delegate void OnQrcodeFoundDelegate(Linphone.Core core, string result);
		private OnQrcodeFoundDelegatePrivate on_qrcode_found_private;
		private OnQrcodeFoundDelegate on_qrcode_found_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnQrcodeFoundDelegatePrivate))]
#endif
		private static void on_qrcode_found(IntPtr core, string result)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_qrcode_found_public?.Invoke(thiz, result);
			}
		}

		public OnQrcodeFoundDelegate OnQrcodeFound
		{
			get
			{
				return on_qrcode_found_public;
			}
			set
			{
				on_qrcode_found_public = value;
#if WINDOWS_UWP
				on_qrcode_found_private = on_qrcode_found;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_qrcode_found_private);
				linphone_core_cbs_set_qrcode_found(nativePtr, cb);
#else
				linphone_core_cbs_set_qrcode_found(nativePtr, on_qrcode_found);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_configuring_status(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_configuring_status(IntPtr thiz, OnConfiguringStatusDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnConfiguringStatusDelegatePrivate(IntPtr core, int status, string message);

		/// <summary>
		/// Callback prototype for configuring status changes notification. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="status">the current LinphoneConfiguringState </param>
		/// <param name="message">informational message.   </param>
		/// 
		public delegate void OnConfiguringStatusDelegate(Linphone.Core core, Linphone.ConfiguringState status, string message);
		private OnConfiguringStatusDelegatePrivate on_configuring_status_private;
		private OnConfiguringStatusDelegate on_configuring_status_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnConfiguringStatusDelegatePrivate))]
#endif
		private static void on_configuring_status(IntPtr core, int status, string message)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_configuring_status_public?.Invoke(thiz, (Linphone.ConfiguringState)status, message);
			}
		}

		public OnConfiguringStatusDelegate OnConfiguringStatus
		{
			get
			{
				return on_configuring_status_public;
			}
			set
			{
				on_configuring_status_public = value;
#if WINDOWS_UWP
				on_configuring_status_private = on_configuring_status;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_configuring_status_private);
				linphone_core_cbs_set_configuring_status(nativePtr, cb);
#else
				linphone_core_cbs_set_configuring_status(nativePtr, on_configuring_status);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_call_created(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_created(IntPtr thiz, OnCallCreatedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallCreatedDelegatePrivate(IntPtr core, IntPtr call);

		/// <summary>
		/// Callback notifying that a new LinphoneCall (either incoming or outgoing) has
		/// been created. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object that has created the call   </param>
		/// <param name="call">The newly created LinphoneCall object   </param>
		/// 
		public delegate void OnCallCreatedDelegate(Linphone.Core core, Linphone.Call call);
		private OnCallCreatedDelegatePrivate on_call_created_private;
		private OnCallCreatedDelegate on_call_created_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallCreatedDelegatePrivate))]
#endif
		private static void on_call_created(IntPtr core, IntPtr call)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_call_created_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call));
			}
		}

		public OnCallCreatedDelegate OnCallCreated
		{
			get
			{
				return on_call_created_public;
			}
			set
			{
				on_call_created_public = value;
#if WINDOWS_UWP
				on_call_created_private = on_call_created;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_created_private);
				linphone_core_cbs_set_call_created(nativePtr, cb);
#else
				linphone_core_cbs_set_call_created(nativePtr, on_call_created);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_publish_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_publish_state_changed(IntPtr thiz, OnPublishStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnPublishStateChangedDelegatePrivate(IntPtr core, IntPtr linphoneEvent, int state);

		/// <summary>
		/// Callback prototype for notifying the application about changes of publish
		/// states. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="linphoneEvent">the LinphoneEvent   </param>
		/// <param name="state">the new LinphonePublishState </param>
		/// 
		public delegate void OnPublishStateChangedDelegate(Linphone.Core core, Linphone.Event linphoneEvent, Linphone.PublishState state);
		private OnPublishStateChangedDelegatePrivate on_publish_state_changed_private;
		private OnPublishStateChangedDelegate on_publish_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnPublishStateChangedDelegatePrivate))]
#endif
		private static void on_publish_state_changed(IntPtr core, IntPtr linphoneEvent, int state)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_publish_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Event>(linphoneEvent), (Linphone.PublishState)state);
			}
		}

		public OnPublishStateChangedDelegate OnPublishStateChanged
		{
			get
			{
				return on_publish_state_changed_public;
			}
			set
			{
				on_publish_state_changed_public = value;
#if WINDOWS_UWP
				on_publish_state_changed_private = on_publish_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_publish_state_changed_private);
				linphone_core_cbs_set_publish_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_publish_state_changed(nativePtr, on_publish_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_first_call_started(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_first_call_started(IntPtr thiz, OnFirstCallStartedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFirstCallStartedDelegatePrivate(IntPtr core);

		/// <summary>
		/// Callback prototype telling a call has started (incoming or outgoing) while
		/// there was no other call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// 
		public delegate void OnFirstCallStartedDelegate(Linphone.Core core);
		private OnFirstCallStartedDelegatePrivate on_first_call_started_private;
		private OnFirstCallStartedDelegate on_first_call_started_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFirstCallStartedDelegatePrivate))]
#endif
		private static void on_first_call_started(IntPtr core)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_first_call_started_public?.Invoke(thiz);
			}
		}

		public OnFirstCallStartedDelegate OnFirstCallStarted
		{
			get
			{
				return on_first_call_started_public;
			}
			set
			{
				on_first_call_started_public = value;
#if WINDOWS_UWP
				on_first_call_started_private = on_first_call_started;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_first_call_started_private);
				linphone_core_cbs_set_first_call_started(nativePtr, cb);
#else
				linphone_core_cbs_set_first_call_started(nativePtr, on_first_call_started);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_call_encryption_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_encryption_changed(IntPtr thiz, OnCallEncryptionChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallEncryptionChangedDelegatePrivate(IntPtr core, IntPtr call, char mediaEncryptionEnabled, string authenticationToken);

		/// <summary>
		/// Call encryption changed callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="call">the LinphoneCall on which encryption is changed.   </param>
		/// <param name="mediaEncryptionEnabled">whether encryption is activated. </param>
		/// <param name="authenticationToken">an authentication_token, currently set for
		/// ZRTP kind of encryption only.   </param>
		/// 
		public delegate void OnCallEncryptionChangedDelegate(Linphone.Core core, Linphone.Call call, bool mediaEncryptionEnabled, string authenticationToken);
		private OnCallEncryptionChangedDelegatePrivate on_call_encryption_changed_private;
		private OnCallEncryptionChangedDelegate on_call_encryption_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallEncryptionChangedDelegatePrivate))]
#endif
		private static void on_call_encryption_changed(IntPtr core, IntPtr call, char mediaEncryptionEnabled, string authenticationToken)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_call_encryption_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call), mediaEncryptionEnabled == 0, authenticationToken);
			}
		}

		public OnCallEncryptionChangedDelegate OnCallEncryptionChanged
		{
			get
			{
				return on_call_encryption_changed_public;
			}
			set
			{
				on_call_encryption_changed_public = value;
#if WINDOWS_UWP
				on_call_encryption_changed_private = on_call_encryption_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_encryption_changed_private);
				linphone_core_cbs_set_call_encryption_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_call_encryption_changed(nativePtr, on_call_encryption_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_is_composing_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_is_composing_received(IntPtr thiz, OnIsComposingReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsComposingReceivedDelegatePrivate(IntPtr core, IntPtr chatRoom);

		/// <summary>
		/// Is composing notification callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="chatRoom">LinphoneChatRoom involved in the conversation.   </param>
		/// 
		public delegate void OnIsComposingReceivedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom);
		private OnIsComposingReceivedDelegatePrivate on_is_composing_received_private;
		private OnIsComposingReceivedDelegate on_is_composing_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsComposingReceivedDelegatePrivate))]
#endif
		private static void on_is_composing_received(IntPtr core, IntPtr chatRoom)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_is_composing_received_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom));
			}
		}

		public OnIsComposingReceivedDelegate OnIsComposingReceived
		{
			get
			{
				return on_is_composing_received_public;
			}
			set
			{
				on_is_composing_received_public = value;
#if WINDOWS_UWP
				on_is_composing_received_private = on_is_composing_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_composing_received_private);
				linphone_core_cbs_set_is_composing_received(nativePtr, cb);
#else
				linphone_core_cbs_set_is_composing_received(nativePtr, on_is_composing_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_message_received_unable_decrypt(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_message_received_unable_decrypt(IntPtr thiz, OnMessageReceivedUnableDecryptDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnMessageReceivedUnableDecryptDelegatePrivate(IntPtr core, IntPtr chatRoom, IntPtr message);

		/// <summary>
		/// Chat message not decrypted callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="chatRoom">LinphoneChatRoom involved in this conversation. Can be
		/// be created by the framework in case the from  is not present in any chat room. 
		///  </param>
		/// <param name="message">LinphoneChatMessage incoming message   </param>
		/// 
		public delegate void OnMessageReceivedUnableDecryptDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom, Linphone.ChatMessage message);
		private OnMessageReceivedUnableDecryptDelegatePrivate on_message_received_unable_decrypt_private;
		private OnMessageReceivedUnableDecryptDelegate on_message_received_unable_decrypt_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnMessageReceivedUnableDecryptDelegatePrivate))]
#endif
		private static void on_message_received_unable_decrypt(IntPtr core, IntPtr chatRoom, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_message_received_unable_decrypt_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom), fromNativePtr<Linphone.ChatMessage>(message));
			}
		}

		public OnMessageReceivedUnableDecryptDelegate OnMessageReceivedUnableDecrypt
		{
			get
			{
				return on_message_received_unable_decrypt_public;
			}
			set
			{
				on_message_received_unable_decrypt_public = value;
#if WINDOWS_UWP
				on_message_received_unable_decrypt_private = on_message_received_unable_decrypt;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_message_received_unable_decrypt_private);
				linphone_core_cbs_set_message_received_unable_decrypt(nativePtr, cb);
#else
				linphone_core_cbs_set_message_received_unable_decrypt(nativePtr, on_message_received_unable_decrypt);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_log_collection_upload_progress_indication(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_log_collection_upload_progress_indication(IntPtr thiz, OnLogCollectionUploadProgressIndicationDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLogCollectionUploadProgressIndicationDelegatePrivate(IntPtr core, long offset, long total);

		/// <summary>
		/// Callback prototype for reporting log collection upload progress indication. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="offset">the number of bytes sent since the start of the upload
		/// </param>
		/// <param name="total">the total number of bytes to upload </param>
		/// 
		public delegate void OnLogCollectionUploadProgressIndicationDelegate(Linphone.Core core, long offset, long total);
		private OnLogCollectionUploadProgressIndicationDelegatePrivate on_log_collection_upload_progress_indication_private;
		private OnLogCollectionUploadProgressIndicationDelegate on_log_collection_upload_progress_indication_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLogCollectionUploadProgressIndicationDelegatePrivate))]
#endif
		private static void on_log_collection_upload_progress_indication(IntPtr core, long offset, long total)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_log_collection_upload_progress_indication_public?.Invoke(thiz, offset, total);
			}
		}

		public OnLogCollectionUploadProgressIndicationDelegate OnLogCollectionUploadProgressIndication
		{
			get
			{
				return on_log_collection_upload_progress_indication_public;
			}
			set
			{
				on_log_collection_upload_progress_indication_public = value;
#if WINDOWS_UWP
				on_log_collection_upload_progress_indication_private = on_log_collection_upload_progress_indication;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_log_collection_upload_progress_indication_private);
				linphone_core_cbs_set_log_collection_upload_progress_indication(nativePtr, cb);
#else
				linphone_core_cbs_set_log_collection_upload_progress_indication(nativePtr, on_log_collection_upload_progress_indication);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_conference_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_conference_state_changed(IntPtr thiz, OnConferenceStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnConferenceStateChangedDelegatePrivate(IntPtr core, IntPtr conference, int state);

		/// <summary>
		/// Callback prototype telling that a LinphoneConference state has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="conference">The LinphoneConference object for which the state has
		/// changed   </param>
		/// <param name="state">the current LinphoneChatRoomState </param>
		/// 
		public delegate void OnConferenceStateChangedDelegate(Linphone.Core core, Linphone.Conference conference, Linphone.ConferenceState state);
		private OnConferenceStateChangedDelegatePrivate on_conference_state_changed_private;
		private OnConferenceStateChangedDelegate on_conference_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnConferenceStateChangedDelegatePrivate))]
#endif
		private static void on_conference_state_changed(IntPtr core, IntPtr conference, int state)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_conference_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Conference>(conference), (Linphone.ConferenceState)state);
			}
		}

		public OnConferenceStateChangedDelegate OnConferenceStateChanged
		{
			get
			{
				return on_conference_state_changed_public;
			}
			set
			{
				on_conference_state_changed_public = value;
#if WINDOWS_UWP
				on_conference_state_changed_private = on_conference_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_conference_state_changed_private);
				linphone_core_cbs_set_conference_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_conference_state_changed(nativePtr, on_conference_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_last_call_ended(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_last_call_ended(IntPtr thiz, OnLastCallEndedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLastCallEndedDelegatePrivate(IntPtr core);

		/// <summary>
		/// Callback prototype telling the last call has ended
		/// (#LinphoneCore.get_calls_nb() returns 0) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// 
		public delegate void OnLastCallEndedDelegate(Linphone.Core core);
		private OnLastCallEndedDelegatePrivate on_last_call_ended_private;
		private OnLastCallEndedDelegate on_last_call_ended_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLastCallEndedDelegatePrivate))]
#endif
		private static void on_last_call_ended(IntPtr core)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_last_call_ended_public?.Invoke(thiz);
			}
		}

		public OnLastCallEndedDelegate OnLastCallEnded
		{
			get
			{
				return on_last_call_ended_public;
			}
			set
			{
				on_last_call_ended_public = value;
#if WINDOWS_UWP
				on_last_call_ended_private = on_last_call_ended;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_last_call_ended_private);
				linphone_core_cbs_set_last_call_ended(nativePtr, cb);
#else
				linphone_core_cbs_set_last_call_ended(nativePtr, on_last_call_ended);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_version_update_check_result_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_version_update_check_result_received(IntPtr thiz, OnVersionUpdateCheckResultReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnVersionUpdateCheckResultReceivedDelegatePrivate(IntPtr core, int result, string version, string url);

		/// <summary>
		/// Callback prototype for reporting the result of a version update check. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="result">The result of the version update check   </param>
		/// <param name="url">The url where to download the new version if the result is
		/// #LinphoneVersionUpdateCheckNewVersionAvailable   </param>
		/// 
		public delegate void OnVersionUpdateCheckResultReceivedDelegate(Linphone.Core core, Linphone.VersionUpdateCheckResult result, string version, string url);
		private OnVersionUpdateCheckResultReceivedDelegatePrivate on_version_update_check_result_received_private;
		private OnVersionUpdateCheckResultReceivedDelegate on_version_update_check_result_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnVersionUpdateCheckResultReceivedDelegatePrivate))]
#endif
		private static void on_version_update_check_result_received(IntPtr core, int result, string version, string url)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_version_update_check_result_received_public?.Invoke(thiz, (Linphone.VersionUpdateCheckResult)result, version, url);
			}
		}

		public OnVersionUpdateCheckResultReceivedDelegate OnVersionUpdateCheckResultReceived
		{
			get
			{
				return on_version_update_check_result_received_public;
			}
			set
			{
				on_version_update_check_result_received_public = value;
#if WINDOWS_UWP
				on_version_update_check_result_received_private = on_version_update_check_result_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_version_update_check_result_received_private);
				linphone_core_cbs_set_version_update_check_result_received(nativePtr, cb);
#else
				linphone_core_cbs_set_version_update_check_result_received(nativePtr, on_version_update_check_result_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_ec_calibration_audio_uninit(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_ec_calibration_audio_uninit(IntPtr thiz, OnEcCalibrationAudioUninitDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEcCalibrationAudioUninitDelegatePrivate(IntPtr core);

		/// <summary>
		/// Function prototype used by #linphone_core_cbs_set_ec_calibrator_audio_uninit(). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">The LinphoneCore.   </param>
		/// 
		public delegate void OnEcCalibrationAudioUninitDelegate(Linphone.Core core);
		private OnEcCalibrationAudioUninitDelegatePrivate on_ec_calibration_audio_uninit_private;
		private OnEcCalibrationAudioUninitDelegate on_ec_calibration_audio_uninit_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEcCalibrationAudioUninitDelegatePrivate))]
#endif
		private static void on_ec_calibration_audio_uninit(IntPtr core)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_ec_calibration_audio_uninit_public?.Invoke(thiz);
			}
		}

		public OnEcCalibrationAudioUninitDelegate OnEcCalibrationAudioUninit
		{
			get
			{
				return on_ec_calibration_audio_uninit_public;
			}
			set
			{
				on_ec_calibration_audio_uninit_public = value;
#if WINDOWS_UWP
				on_ec_calibration_audio_uninit_private = on_ec_calibration_audio_uninit;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ec_calibration_audio_uninit_private);
				linphone_core_cbs_set_ec_calibration_audio_uninit(nativePtr, cb);
#else
				linphone_core_cbs_set_ec_calibration_audio_uninit(nativePtr, on_ec_calibration_audio_uninit);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_global_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_global_state_changed(IntPtr thiz, OnGlobalStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnGlobalStateChangedDelegatePrivate(IntPtr core, int state, string message);

		/// <summary>
		/// Global state notification callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore.   </param>
		/// <param name="state">the LinphoneGlobalState </param>
		/// <param name="message">informational message.   </param>
		/// 
		public delegate void OnGlobalStateChangedDelegate(Linphone.Core core, Linphone.GlobalState state, string message);
		private OnGlobalStateChangedDelegatePrivate on_global_state_changed_private;
		private OnGlobalStateChangedDelegate on_global_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnGlobalStateChangedDelegatePrivate))]
#endif
		private static void on_global_state_changed(IntPtr core, int state, string message)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_global_state_changed_public?.Invoke(thiz, (Linphone.GlobalState)state, message);
			}
		}

		public OnGlobalStateChangedDelegate OnGlobalStateChanged
		{
			get
			{
				return on_global_state_changed_public;
			}
			set
			{
				on_global_state_changed_public = value;
#if WINDOWS_UWP
				on_global_state_changed_private = on_global_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_global_state_changed_private);
				linphone_core_cbs_set_global_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_global_state_changed(nativePtr, on_global_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_log_collection_upload_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_log_collection_upload_state_changed(IntPtr thiz, OnLogCollectionUploadStateChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLogCollectionUploadStateChangedDelegatePrivate(IntPtr core, int state, string info);

		/// <summary>
		/// Callback prototype for reporting log collection upload state change. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="state">The state of the log collection upload </param>
		/// <param name="info">Additional information: error message in case of error
		/// state, URL of uploaded file in case of success.   </param>
		/// 
		public delegate void OnLogCollectionUploadStateChangedDelegate(Linphone.Core core, Linphone.CoreLogCollectionUploadState state, string info);
		private OnLogCollectionUploadStateChangedDelegatePrivate on_log_collection_upload_state_changed_private;
		private OnLogCollectionUploadStateChangedDelegate on_log_collection_upload_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLogCollectionUploadStateChangedDelegatePrivate))]
#endif
		private static void on_log_collection_upload_state_changed(IntPtr core, int state, string info)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_log_collection_upload_state_changed_public?.Invoke(thiz, (Linphone.CoreLogCollectionUploadState)state, info);
			}
		}

		public OnLogCollectionUploadStateChangedDelegate OnLogCollectionUploadStateChanged
		{
			get
			{
				return on_log_collection_upload_state_changed_public;
			}
			set
			{
				on_log_collection_upload_state_changed_public = value;
#if WINDOWS_UWP
				on_log_collection_upload_state_changed_private = on_log_collection_upload_state_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_log_collection_upload_state_changed_private);
				linphone_core_cbs_set_log_collection_upload_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_log_collection_upload_state_changed(nativePtr, on_log_collection_upload_state_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_dtmf_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_dtmf_received(IntPtr thiz, OnDtmfReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnDtmfReceivedDelegatePrivate(IntPtr core, IntPtr call, int dtmf);

		/// <summary>
		/// Callback for being notified of DTMFs received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the LinphoneCore   </param>
		/// <param name="call">the LinphoneCall that received the dtmf   </param>
		/// <param name="dtmf">the ascii code of the dtmf </param>
		/// 
		public delegate void OnDtmfReceivedDelegate(Linphone.Core core, Linphone.Call call, int dtmf);
		private OnDtmfReceivedDelegatePrivate on_dtmf_received_private;
		private OnDtmfReceivedDelegate on_dtmf_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnDtmfReceivedDelegatePrivate))]
#endif
		private static void on_dtmf_received(IntPtr core, IntPtr call, int dtmf)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_dtmf_received_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call), dtmf);
			}
		}

		public OnDtmfReceivedDelegate OnDtmfReceived
		{
			get
			{
				return on_dtmf_received_public;
			}
			set
			{
				on_dtmf_received_public = value;
#if WINDOWS_UWP
				on_dtmf_received_private = on_dtmf_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_dtmf_received_private);
				linphone_core_cbs_set_dtmf_received(nativePtr, cb);
#else
				linphone_core_cbs_set_dtmf_received(nativePtr, on_dtmf_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_chat_room_ephemeral_message_deleted(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_chat_room_ephemeral_message_deleted(IntPtr thiz, OnChatRoomEphemeralMessageDeletedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatRoomEphemeralMessageDeletedDelegatePrivate(IntPtr core, IntPtr chatRoom);

		/// <summary>
		/// Callback prototype telling that a LinphoneChatRoom ephemeral message has
		/// expired. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="chatRoom">The LinphoneChatRoom object for which a message has
		/// expired.   </param>
		/// 
		public delegate void OnChatRoomEphemeralMessageDeletedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom);
		private OnChatRoomEphemeralMessageDeletedDelegatePrivate on_chat_room_ephemeral_message_deleted_private;
		private OnChatRoomEphemeralMessageDeletedDelegate on_chat_room_ephemeral_message_deleted_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatRoomEphemeralMessageDeletedDelegatePrivate))]
#endif
		private static void on_chat_room_ephemeral_message_deleted(IntPtr core, IntPtr chatRoom)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_chat_room_ephemeral_message_deleted_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom));
			}
		}

		public OnChatRoomEphemeralMessageDeletedDelegate OnChatRoomEphemeralMessageDeleted
		{
			get
			{
				return on_chat_room_ephemeral_message_deleted_public;
			}
			set
			{
				on_chat_room_ephemeral_message_deleted_public = value;
#if WINDOWS_UWP
				on_chat_room_ephemeral_message_deleted_private = on_chat_room_ephemeral_message_deleted;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_room_ephemeral_message_deleted_private);
				linphone_core_cbs_set_chat_room_ephemeral_message_deleted(nativePtr, cb);
#else
				linphone_core_cbs_set_chat_room_ephemeral_message_deleted(nativePtr, on_chat_room_ephemeral_message_deleted);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_message_sent(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_message_sent(IntPtr thiz, OnMessageSentDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnMessageSentDelegatePrivate(IntPtr core, IntPtr chatRoom, IntPtr message);

		/// <summary>
		/// Called after the #send method of the LinphoneChatMessage was called. 
		/// <para>
		/// The message will be in state InProgress. In case of resend this callback won't
		/// be called. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// <param name="chatRoom">LinphoneChatRoom involved in this conversation. Can be
		/// be created by the framework in case the from  is not present in any chat room. 
		///  </param>
		/// <param name="message">LinphoneChatMessage outgoing message   </param>
		/// 
		public delegate void OnMessageSentDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom, Linphone.ChatMessage message);
		private OnMessageSentDelegatePrivate on_message_sent_private;
		private OnMessageSentDelegate on_message_sent_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnMessageSentDelegatePrivate))]
#endif
		private static void on_message_sent(IntPtr core, IntPtr chatRoom, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_message_sent_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom), fromNativePtr<Linphone.ChatMessage>(message));
			}
		}

		public OnMessageSentDelegate OnMessageSent
		{
			get
			{
				return on_message_sent_public;
			}
			set
			{
				on_message_sent_public = value;
#if WINDOWS_UWP
				on_message_sent_private = on_message_sent;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_message_sent_private);
				linphone_core_cbs_set_message_sent(nativePtr, cb);
#else
				linphone_core_cbs_set_message_sent(nativePtr, on_message_sent);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_core_cbs_set_audio_devices_list_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_audio_devices_list_updated(IntPtr thiz, OnAudioDevicesListUpdatedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAudioDevicesListUpdatedDelegatePrivate(IntPtr core);

		/// <summary>
		/// Callback prototype telling the audio devices list has been updated. 
		/// <para>
		/// Either a new device is available or a previously available device isn't
		/// anymore. You can call linphone_core_get_audio_devices to get the new list. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="core">LinphoneCore object   </param>
		/// 
		public delegate void OnAudioDevicesListUpdatedDelegate(Linphone.Core core);
		private OnAudioDevicesListUpdatedDelegatePrivate on_audio_devices_list_updated_private;
		private OnAudioDevicesListUpdatedDelegate on_audio_devices_list_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAudioDevicesListUpdatedDelegatePrivate))]
#endif
		private static void on_audio_devices_list_updated(IntPtr core)
		{
			Core thiz = fromNativePtr<Core>(core);
			CoreListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_audio_devices_list_updated_public?.Invoke(thiz);
			}
		}

		public OnAudioDevicesListUpdatedDelegate OnAudioDevicesListUpdated
		{
			get
			{
				return on_audio_devices_list_updated_public;
			}
			set
			{
				on_audio_devices_list_updated_public = value;
#if WINDOWS_UWP
				on_audio_devices_list_updated_private = on_audio_devices_list_updated;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_audio_devices_list_updated_private);
				linphone_core_cbs_set_audio_devices_list_updated(nativePtr, cb);
#else
				linphone_core_cbs_set_audio_devices_list_updated(nativePtr, on_audio_devices_list_updated);
#endif
			}
		}

		internal void register() {
			IntPtr listener = linphone_core_cbs_get_user_data(nativePtr);
			if (listener == IntPtr.Zero)
			{
				GCHandle _handle = GCHandle.Alloc(this, GCHandleType.Normal);
				listener = GCHandle.ToIntPtr(_handle);
			} else
			{
				GCHandle _handle = GCHandle.FromIntPtr(listener);
				if (_handle.Target == this)
				{
					return;
				} else
				{
					_handle.Free();
					_handle = GCHandle.Alloc(this, GCHandleType.Normal);
					listener = GCHandle.ToIntPtr(_handle);
				}
			}
			linphone_core_cbs_set_user_data(nativePtr, listener);
		}

		internal void unregister() {
			IntPtr listener = linphone_core_cbs_get_user_data(nativePtr);
			linphone_core_cbs_set_user_data(nativePtr, IntPtr.Zero);
			if (listener != IntPtr.Zero)
			{
				GCHandle.FromIntPtr(listener).Free();
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for handling the LinphoneEvent operations. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class EventListener : LinphoneObject
	{
        ~EventListener()
        {
            unregister();
        }

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern void linphone_event_cbs_set_user_data(IntPtr thiz, IntPtr listener);

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr linphone_event_cbs_get_user_data(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_event_cbs_set_notify_response(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_event_cbs_set_notify_response(IntPtr thiz, OnNotifyResponseDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNotifyResponseDelegatePrivate(IntPtr linphoneEvent);

		/// <summary>
		/// Callback used to notify the response to a sent NOTIFY. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="linphoneEvent">The LinphoneEvent object that has sent the NOTIFY
		/// and for which we received a response   </param>
		/// 
		public delegate void OnNotifyResponseDelegate(Linphone.Event linphoneEvent);
		private OnNotifyResponseDelegatePrivate on_notify_response_private;
		private OnNotifyResponseDelegate on_notify_response_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNotifyResponseDelegatePrivate))]
#endif
		private static void on_notify_response(IntPtr linphoneEvent)
		{
			Event thiz = fromNativePtr<Event>(linphoneEvent);
			EventListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_notify_response_public?.Invoke(thiz);
			}
		}

		public OnNotifyResponseDelegate OnNotifyResponse
		{
			get
			{
				return on_notify_response_public;
			}
			set
			{
				on_notify_response_public = value;
#if WINDOWS_UWP
				on_notify_response_private = on_notify_response;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_notify_response_private);
				linphone_event_cbs_set_notify_response(nativePtr, cb);
#else
				linphone_event_cbs_set_notify_response(nativePtr, on_notify_response);
#endif
			}
		}

		internal void register() {
			IntPtr listener = linphone_event_cbs_get_user_data(nativePtr);
			if (listener == IntPtr.Zero)
			{
				GCHandle _handle = GCHandle.Alloc(this, GCHandleType.Normal);
				listener = GCHandle.ToIntPtr(_handle);
			} else
			{
				GCHandle _handle = GCHandle.FromIntPtr(listener);
				if (_handle.Target == this)
				{
					return;
				} else
				{
					_handle.Free();
					_handle = GCHandle.Alloc(this, GCHandleType.Normal);
					listener = GCHandle.ToIntPtr(_handle);
				}
			}
			linphone_event_cbs_set_user_data(nativePtr, listener);
		}

		internal void unregister() {
			IntPtr listener = linphone_event_cbs_get_user_data(nativePtr);
			linphone_event_cbs_set_user_data(nativePtr, IntPtr.Zero);
			if (listener != IntPtr.Zero)
			{
				GCHandle.FromIntPtr(listener).Free();
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for LinphoneFriend synchronization. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class FriendListListener : LinphoneObject
	{
        ~FriendListListener()
        {
            unregister();
        }

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern void linphone_friend_list_cbs_set_user_data(IntPtr thiz, IntPtr listener);

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr linphone_friend_list_cbs_get_user_data(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_friend_list_cbs_set_contact_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_friend_list_cbs_set_contact_updated(IntPtr thiz, OnContactUpdatedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnContactUpdatedDelegatePrivate(IntPtr friendList, IntPtr newFriend, IntPtr oldFriend);

		/// <summary>
		/// Callback used to notify a contact has been updated on the CardDAV server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="friendList">The LinphoneFriendList object in which a contact has
		/// been updated   </param>
		/// <param name="newFriend">The new LinphoneFriend object corresponding to the
		/// updated contact   </param>
		/// <param name="oldFriend">The old LinphoneFriend object before update   </param>
		/// 
		public delegate void OnContactUpdatedDelegate(Linphone.FriendList friendList, Linphone.Friend newFriend, Linphone.Friend oldFriend);
		private OnContactUpdatedDelegatePrivate on_contact_updated_private;
		private OnContactUpdatedDelegate on_contact_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnContactUpdatedDelegatePrivate))]
#endif
		private static void on_contact_updated(IntPtr friendList, IntPtr newFriend, IntPtr oldFriend)
		{
			FriendList thiz = fromNativePtr<FriendList>(friendList);
			FriendListListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_contact_updated_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(newFriend), fromNativePtr<Linphone.Friend>(oldFriend));
			}
		}

		public OnContactUpdatedDelegate OnContactUpdated
		{
			get
			{
				return on_contact_updated_public;
			}
			set
			{
				on_contact_updated_public = value;
#if WINDOWS_UWP
				on_contact_updated_private = on_contact_updated;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_contact_updated_private);
				linphone_friend_list_cbs_set_contact_updated(nativePtr, cb);
#else
				linphone_friend_list_cbs_set_contact_updated(nativePtr, on_contact_updated);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_friend_list_cbs_set_presence_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_friend_list_cbs_set_presence_received(IntPtr thiz, OnPresenceReceivedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnPresenceReceivedDelegatePrivate(IntPtr friendList, IntPtr friends);

		/// <summary>
		/// Callback used to notify a list with all friends that have received presence
		/// information. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="friendList">The LinphoneFriendList object for which the status has
		/// changed   </param>
		/// <param name="friends">A A list of LinphoneFriend objects. LinphoneFriend  of
		/// the relevant friends   </param>
		/// 
		public delegate void OnPresenceReceivedDelegate(Linphone.FriendList friendList, IEnumerable<Linphone.Friend> friends);
		private OnPresenceReceivedDelegatePrivate on_presence_received_private;
		private OnPresenceReceivedDelegate on_presence_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnPresenceReceivedDelegatePrivate))]
#endif
		private static void on_presence_received(IntPtr friendList, IntPtr friends)
		{
			FriendList thiz = fromNativePtr<FriendList>(friendList);
			FriendListListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_presence_received_public?.Invoke(thiz, MarshalBctbxList<Linphone.Friend>(friends));
			}
		}

		public OnPresenceReceivedDelegate OnPresenceReceived
		{
			get
			{
				return on_presence_received_public;
			}
			set
			{
				on_presence_received_public = value;
#if WINDOWS_UWP
				on_presence_received_private = on_presence_received;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_presence_received_private);
				linphone_friend_list_cbs_set_presence_received(nativePtr, cb);
#else
				linphone_friend_list_cbs_set_presence_received(nativePtr, on_presence_received);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_friend_list_cbs_set_sync_status_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_friend_list_cbs_set_sync_status_changed(IntPtr thiz, OnSyncStatusChangedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSyncStatusChangedDelegatePrivate(IntPtr friendList, int status, string message);

		/// <summary>
		/// Callback used to notify the status of the synchronization has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="friendList">The LinphoneFriendList object for which the status has
		/// changed   </param>
		/// <param name="status">The new LinphoneFriendListSyncStatus </param>
		/// <param name="message">An additional information on the status update   </param>
		/// 
		public delegate void OnSyncStatusChangedDelegate(Linphone.FriendList friendList, Linphone.FriendListSyncStatus status, string message);
		private OnSyncStatusChangedDelegatePrivate on_sync_status_changed_private;
		private OnSyncStatusChangedDelegate on_sync_status_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSyncStatusChangedDelegatePrivate))]
#endif
		private static void on_sync_status_changed(IntPtr friendList, int status, string message)
		{
			FriendList thiz = fromNativePtr<FriendList>(friendList);
			FriendListListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_sync_status_changed_public?.Invoke(thiz, (Linphone.FriendListSyncStatus)status, message);
			}
		}

		public OnSyncStatusChangedDelegate OnSyncStatusChanged
		{
			get
			{
				return on_sync_status_changed_public;
			}
			set
			{
				on_sync_status_changed_public = value;
#if WINDOWS_UWP
				on_sync_status_changed_private = on_sync_status_changed;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_sync_status_changed_private);
				linphone_friend_list_cbs_set_sync_status_changed(nativePtr, cb);
#else
				linphone_friend_list_cbs_set_sync_status_changed(nativePtr, on_sync_status_changed);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_friend_list_cbs_set_contact_created(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_friend_list_cbs_set_contact_created(IntPtr thiz, OnContactCreatedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnContactCreatedDelegatePrivate(IntPtr friendList, IntPtr linphoneFriend);

		/// <summary>
		/// Callback used to notify a new contact has been created on the CardDAV server
		/// and downloaded locally. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="friendList">The LinphoneFriendList object the new contact is added
		/// to   </param>
		/// <param name="linphoneFriend">The LinphoneFriend object that has been created  
		/// </param>
		/// 
		public delegate void OnContactCreatedDelegate(Linphone.FriendList friendList, Linphone.Friend linphoneFriend);
		private OnContactCreatedDelegatePrivate on_contact_created_private;
		private OnContactCreatedDelegate on_contact_created_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnContactCreatedDelegatePrivate))]
#endif
		private static void on_contact_created(IntPtr friendList, IntPtr linphoneFriend)
		{
			FriendList thiz = fromNativePtr<FriendList>(friendList);
			FriendListListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_contact_created_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(linphoneFriend));
			}
		}

		public OnContactCreatedDelegate OnContactCreated
		{
			get
			{
				return on_contact_created_public;
			}
			set
			{
				on_contact_created_public = value;
#if WINDOWS_UWP
				on_contact_created_private = on_contact_created;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_contact_created_private);
				linphone_friend_list_cbs_set_contact_created(nativePtr, cb);
#else
				linphone_friend_list_cbs_set_contact_created(nativePtr, on_contact_created);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_friend_list_cbs_set_contact_deleted(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_friend_list_cbs_set_contact_deleted(IntPtr thiz, OnContactDeletedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnContactDeletedDelegatePrivate(IntPtr friendList, IntPtr linphoneFriend);

		/// <summary>
		/// Callback used to notify a contact has been deleted on the CardDAV server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="friendList">The LinphoneFriendList object a contact has been
		/// removed from   </param>
		/// <param name="linphoneFriend">The LinphoneFriend object that has been deleted  
		/// </param>
		/// 
		public delegate void OnContactDeletedDelegate(Linphone.FriendList friendList, Linphone.Friend linphoneFriend);
		private OnContactDeletedDelegatePrivate on_contact_deleted_private;
		private OnContactDeletedDelegate on_contact_deleted_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnContactDeletedDelegatePrivate))]
#endif
		private static void on_contact_deleted(IntPtr friendList, IntPtr linphoneFriend)
		{
			FriendList thiz = fromNativePtr<FriendList>(friendList);
			FriendListListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_contact_deleted_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(linphoneFriend));
			}
		}

		public OnContactDeletedDelegate OnContactDeleted
		{
			get
			{
				return on_contact_deleted_public;
			}
			set
			{
				on_contact_deleted_public = value;
#if WINDOWS_UWP
				on_contact_deleted_private = on_contact_deleted;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_contact_deleted_private);
				linphone_friend_list_cbs_set_contact_deleted(nativePtr, cb);
#else
				linphone_friend_list_cbs_set_contact_deleted(nativePtr, on_contact_deleted);
#endif
			}
		}

		internal void register() {
			IntPtr listener = linphone_friend_list_cbs_get_user_data(nativePtr);
			if (listener == IntPtr.Zero)
			{
				GCHandle _handle = GCHandle.Alloc(this, GCHandleType.Normal);
				listener = GCHandle.ToIntPtr(_handle);
			} else
			{
				GCHandle _handle = GCHandle.FromIntPtr(listener);
				if (_handle.Target == this)
				{
					return;
				} else
				{
					_handle.Free();
					_handle = GCHandle.Alloc(this, GCHandleType.Normal);
					listener = GCHandle.ToIntPtr(_handle);
				}
			}
			linphone_friend_list_cbs_set_user_data(nativePtr, listener);
		}

		internal void unregister() {
			IntPtr listener = linphone_friend_list_cbs_get_user_data(nativePtr);
			linphone_friend_list_cbs_set_user_data(nativePtr, IntPtr.Zero);
			if (listener != IntPtr.Zero)
			{
				GCHandle.FromIntPtr(listener).Free();
			}
		}
	}

	/// <summary>
	/// Listener for LinphoneLoggingService. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class LoggingServiceListener : LinphoneObject
	{
        ~LoggingServiceListener()
        {
            unregister();
        }

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern void linphone_logging_service_cbs_set_user_data(IntPtr thiz, IntPtr listener);

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr linphone_logging_service_cbs_get_user_data(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_logging_service_cbs_set_log_message_written(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_logging_service_cbs_set_log_message_written(IntPtr thiz, OnLogMessageWrittenDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLogMessageWrittenDelegatePrivate(IntPtr logService, string domain, int level, string message);

		/// <summary>
		/// Type of callbacks called each time liblinphone write a log message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="logService">A pointer on the logging service singleton.   </param>
		/// <param name="domain">A string describing which sub-library of liblinphone the
		/// message is coming from.   </param>
		/// <param name="level">Verbosity LinphoneLogLevel of the message. </param>
		/// <param name="message">Content of the message.   </param>
		/// 
		public delegate void OnLogMessageWrittenDelegate(Linphone.LoggingService logService, string domain, Linphone.LogLevel level, string message);
		private OnLogMessageWrittenDelegatePrivate on_log_message_written_private;
		private OnLogMessageWrittenDelegate on_log_message_written_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLogMessageWrittenDelegatePrivate))]
#endif
		private static void on_log_message_written(IntPtr logService, string domain, int level, string message)
		{
			LoggingService thiz = fromNativePtr<LoggingService>(logService);
			LoggingServiceListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_log_message_written_public?.Invoke(thiz, domain, (Linphone.LogLevel)level, message);
			}
		}

		public OnLogMessageWrittenDelegate OnLogMessageWritten
		{
			get
			{
				return on_log_message_written_public;
			}
			set
			{
				on_log_message_written_public = value;
#if WINDOWS_UWP
				on_log_message_written_private = on_log_message_written;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_log_message_written_private);
				linphone_logging_service_cbs_set_log_message_written(nativePtr, cb);
#else
				linphone_logging_service_cbs_set_log_message_written(nativePtr, on_log_message_written);
#endif
			}
		}

		internal void register() {
			IntPtr listener = linphone_logging_service_cbs_get_user_data(nativePtr);
			if (listener == IntPtr.Zero)
			{
				GCHandle _handle = GCHandle.Alloc(this, GCHandleType.Normal);
				listener = GCHandle.ToIntPtr(_handle);
			} else
			{
				GCHandle _handle = GCHandle.FromIntPtr(listener);
				if (_handle.Target == this)
				{
					return;
				} else
				{
					_handle.Free();
					_handle = GCHandle.Alloc(this, GCHandleType.Normal);
					listener = GCHandle.ToIntPtr(_handle);
				}
			}
			linphone_logging_service_cbs_set_user_data(nativePtr, listener);
		}

		internal void unregister() {
			IntPtr listener = linphone_logging_service_cbs_get_user_data(nativePtr);
			linphone_logging_service_cbs_set_user_data(nativePtr, IntPtr.Zero);
			if (listener != IntPtr.Zero)
			{
				GCHandle.FromIntPtr(listener).Free();
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for the handling a LinphonePlayer objects. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PlayerListener : LinphoneObject
	{
        ~PlayerListener()
        {
            unregister();
        }

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern void linphone_player_cbs_set_user_data(IntPtr thiz, IntPtr listener);

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr linphone_player_cbs_get_user_data(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_player_cbs_set_eof_reached(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_player_cbs_set_eof_reached(IntPtr thiz, OnEofReachedDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEofReachedDelegatePrivate(IntPtr player);

		/// <summary>
		/// Callback for notifying end of play (file). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="player">The LinphonePlayer object   </param>
		/// 
		public delegate void OnEofReachedDelegate(Linphone.Player player);
		private OnEofReachedDelegatePrivate on_eof_reached_private;
		private OnEofReachedDelegate on_eof_reached_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEofReachedDelegatePrivate))]
#endif
		private static void on_eof_reached(IntPtr player)
		{
			Player thiz = fromNativePtr<Player>(player);
			PlayerListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_eof_reached_public?.Invoke(thiz);
			}
		}

		public OnEofReachedDelegate OnEofReached
		{
			get
			{
				return on_eof_reached_public;
			}
			set
			{
				on_eof_reached_public = value;
#if WINDOWS_UWP
				on_eof_reached_private = on_eof_reached;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_eof_reached_private);
				linphone_player_cbs_set_eof_reached(nativePtr, cb);
#else
				linphone_player_cbs_set_eof_reached(nativePtr, on_eof_reached);
#endif
			}
		}

		internal void register() {
			IntPtr listener = linphone_player_cbs_get_user_data(nativePtr);
			if (listener == IntPtr.Zero)
			{
				GCHandle _handle = GCHandle.Alloc(this, GCHandleType.Normal);
				listener = GCHandle.ToIntPtr(_handle);
			} else
			{
				GCHandle _handle = GCHandle.FromIntPtr(listener);
				if (_handle.Target == this)
				{
					return;
				} else
				{
					_handle.Free();
					_handle = GCHandle.Alloc(this, GCHandleType.Normal);
					listener = GCHandle.ToIntPtr(_handle);
				}
			}
			linphone_player_cbs_set_user_data(nativePtr, listener);
		}

		internal void unregister() {
			IntPtr listener = linphone_player_cbs_get_user_data(nativePtr);
			linphone_player_cbs_set_user_data(nativePtr, IntPtr.Zero);
			if (listener != IntPtr.Zero)
			{
				GCHandle.FromIntPtr(listener).Free();
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for handling the LinphoneXmlRpcRequest
	/// operations. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class XmlRpcRequestListener : LinphoneObject
	{
        ~XmlRpcRequestListener()
        {
            unregister();
        }

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern void linphone_xml_rpc_request_cbs_set_user_data(IntPtr thiz, IntPtr listener);

        [DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr linphone_xml_rpc_request_cbs_get_user_data(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if WINDOWS_UWP
		static extern void linphone_xml_rpc_request_cbs_set_response(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_xml_rpc_request_cbs_set_response(IntPtr thiz, OnResponseDelegatePrivate cb);
#endif

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnResponseDelegatePrivate(IntPtr request);

		/// <summary>
		/// Callback used to notify the response to an XML-RPC request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="request">LinphoneXmlRpcRequest object   </param>
		/// 
		public delegate void OnResponseDelegate(Linphone.XmlRpcRequest request);
		private OnResponseDelegatePrivate on_response_private;
		private OnResponseDelegate on_response_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnResponseDelegatePrivate))]
#endif
		private static void on_response(IntPtr request)
		{
			XmlRpcRequest thiz = fromNativePtr<XmlRpcRequest>(request);
			XmlRpcRequestListener current_listener = thiz.CurrentCallbacks;
			if (current_listener != null)
			{
				current_listener.on_response_public?.Invoke(thiz);
			}
		}

		public OnResponseDelegate OnResponse
		{
			get
			{
				return on_response_public;
			}
			set
			{
				on_response_public = value;
#if WINDOWS_UWP
				on_response_private = on_response;
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_response_private);
				linphone_xml_rpc_request_cbs_set_response(nativePtr, cb);
#else
				linphone_xml_rpc_request_cbs_set_response(nativePtr, on_response);
#endif
			}
		}

		internal void register() {
			IntPtr listener = linphone_xml_rpc_request_cbs_get_user_data(nativePtr);
			if (listener == IntPtr.Zero)
			{
				GCHandle _handle = GCHandle.Alloc(this, GCHandleType.Normal);
				listener = GCHandle.ToIntPtr(_handle);
			} else
			{
				GCHandle _handle = GCHandle.FromIntPtr(listener);
				if (_handle.Target == this)
				{
					return;
				} else
				{
					_handle.Free();
					_handle = GCHandle.Alloc(this, GCHandleType.Normal);
					listener = GCHandle.ToIntPtr(_handle);
				}
			}
			linphone_xml_rpc_request_cbs_set_user_data(nativePtr, listener);
		}

		internal void unregister() {
			IntPtr listener = linphone_xml_rpc_request_cbs_get_user_data(nativePtr);
			linphone_xml_rpc_request_cbs_set_user_data(nativePtr, IntPtr.Zero);
			if (listener != IntPtr.Zero)
			{
				GCHandle.FromIntPtr(listener).Free();
			}
		}
	}

#endregion

#region Classes
	/// <summary>
	/// The object used to configure an account on a server via XML-RPC, see
	/// https://wiki.linphone.org/xwiki/wiki/public/view/Lib/Features/Override%20account
	/// %20creator%20request/.
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class AccountCreator : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_account_creator_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_remove_callbacks(IntPtr thiz, IntPtr cbs);

		~AccountCreator() 
		{
			if (listener != null)
			{
				linphone_account_creator_remove_callbacks(nativePtr, listener.nativePtr);
			}
		}

		private AccountCreatorListener listener;

		public AccountCreatorListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_account_creator_cbs(linphone_factory_get());
					listener = fromNativePtr<AccountCreatorListener>(nativeListener, false);
					linphone_account_creator_add_callbacks(nativePtr, nativeListener);
					listener.register();
				}
				return listener;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_activation_code(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorActivationCodeStatus linphone_account_creator_set_activation_code(IntPtr thiz, string activationCode);

		/// <summary>
		/// Get the activation code. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The activation code of the <see cref="Linphone.AccountCreator" />.  
		/// </returns>
		public string ActivationCode
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_activation_code(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_activation_code(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_algorithm(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorAlgoStatus linphone_account_creator_set_algorithm(IntPtr thiz, string algorithm);

		/// <summary>
		/// Get the algorithm configured in the account creator. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The algorithm of the <see cref="Linphone.AccountCreator" />.  
		/// </returns>
		public string Algorithm
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_algorithm(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_algorithm(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_set_as_default(IntPtr thiz, char setAsDefault);

		/// <summary>
		/// Set the set_as_default property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="setAsDefault">true for the created proxy config to be set as
		/// default in <see cref="Linphone.Core" />, false otherwise </param>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorStatusRequestOk if everything is OK, or a
		/// specific error otherwise. </returns>
		public bool AsDefault
		{
			set
			{
				linphone_account_creator_set_as_default(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_current_callbacks(IntPtr thiz);

		/// <summary>
		/// Get the current LinphoneAccountCreatorCbs object associated with a
		/// LinphoneAccountCreator. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current LinphoneAccountCreatorCbs object associated with the
		/// LinphoneAccountCreator.   </returns>
		public Linphone.AccountCreatorListener CurrentCallbacks
		{
			get
			{
				IntPtr ptr = linphone_account_creator_get_current_callbacks(nativePtr);
				Linphone.AccountCreatorListener obj = fromNativePtr<Linphone.AccountCreatorListener>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_display_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorUsernameStatus linphone_account_creator_set_display_name(IntPtr thiz, string displayName);

		/// <summary>
		/// Get the display name. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The display name of the <see cref="Linphone.AccountCreator" />.  
		/// </returns>
		public string DisplayName
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_display_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_display_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_domain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorDomainStatus linphone_account_creator_set_domain(IntPtr thiz, string domain);

		/// <summary>
		/// Get the domain. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The domain of the <see cref="Linphone.AccountCreator" />.   </returns>
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_domain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_email(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorEmailStatus linphone_account_creator_set_email(IntPtr thiz, string email);

		/// <summary>
		/// Get the email. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The email of the <see cref="Linphone.AccountCreator" />.   </returns>
		public string Email
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_email(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_email(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_ha1(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorPasswordStatus linphone_account_creator_set_ha1(IntPtr thiz, string ha1);

		/// <summary>
		/// Get the ha1. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The ha1 of the <see cref="Linphone.AccountCreator" />.   </returns>
		public string Ha1
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_ha1(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_ha1(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_language(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorLanguageStatus linphone_account_creator_set_language(IntPtr thiz, string lang);

		/// <summary>
		/// Get the language use in email of SMS. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The language of the <see cref="Linphone.AccountCreator" />.  
		/// </returns>
		public string Language
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_language(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_language(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_password(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorPasswordStatus linphone_account_creator_set_password(IntPtr thiz, string password);

		/// <summary>
		/// Get the password. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The password of the <see cref="Linphone.AccountCreator" />.  
		/// </returns>
		public string Password
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_password(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_password(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_phone_number(IntPtr thiz);

		/// <summary>
		/// Get the RFC 3966 normalized phone number. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The phone number of the <see cref="Linphone.AccountCreator" />.  
		/// </returns>
		public string PhoneNumber
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_phone_number(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_creator_set_proxy_config(IntPtr thiz, IntPtr cfg);

		/// <summary>
		/// Assign a proxy config pointer to the LinphoneAccountCreator. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="cfg">The LinphoneProxyConfig to associate with the
		/// LinphoneAccountCreator.   </param>
		/// 
		public Linphone.ProxyConfig ProxyConfig
		{
			set
			{
				linphone_account_creator_set_proxy_config(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_route(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_set_route(IntPtr thiz, string route);

		/// <summary>
		/// Get the route. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The route of the <see cref="Linphone.AccountCreator" />.   </returns>
		public string Route
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_route(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_route(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_creator_get_set_as_default(IntPtr thiz);

		/// <summary>
		/// Get the set_as_default property. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if account will be set as default, false otherwise. </returns>
		public bool SetAsDefault
		{
			get
			{
				return linphone_account_creator_get_set_as_default(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.TransportType linphone_account_creator_get_transport(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorTransportStatus linphone_account_creator_set_transport(IntPtr thiz, int transport);

		/// <summary>
		/// Get Transport. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneTransportType of the creator. </returns>
		public Linphone.TransportType Transport
		{
			get
			{
				return linphone_account_creator_get_transport(nativePtr);
			}
			set
			{
				linphone_account_creator_set_transport(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_username(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorUsernameStatus linphone_account_creator_set_username(IntPtr thiz, string username);

		/// <summary>
		/// Get the username. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The username of the <see cref="Linphone.AccountCreator" />.  
		/// </returns>
		public string Username
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_username(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_username(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_activate_account(IntPtr thiz);

		/// <summary>
		/// Send a request to activate an account on server. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorStatusRequestOk if the request has been sent,
		/// LinphoneAccountCreatorStatusRequestFailed otherwise </returns>
		public Linphone.AccountCreatorStatus ActivateAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_activate_account(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_activate_alias(IntPtr thiz);

		/// <summary>
		/// Send a request to activate an alias. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorStatusRequestOk if the request has been sent,
		/// LinphoneAccountCreatorStatusRequestFailed otherwise </returns>
		public Linphone.AccountCreatorStatus ActivateAlias()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_activate_alias(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_create_account(IntPtr thiz);

		/// <summary>
		/// Send a request to create an account on server. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorStatusRequestOk if the request has been sent,
		/// LinphoneAccountCreatorStatusRequestFailed otherwise </returns>
		public Linphone.AccountCreatorStatus CreateAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_create_account(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_create_proxy_config(IntPtr thiz);

		/// <summary>
		/// Create and configure a proxy config and a authentication info for an account
		/// creator. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.ProxyConfig" /> object if successful, null
		/// otherwise.   </returns>
		public Linphone.ProxyConfig CreateProxyConfig()
		{
			IntPtr ptr = linphone_account_creator_create_proxy_config(nativePtr);
			Linphone.ProxyConfig returnVal = fromNativePtr<Linphone.ProxyConfig>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_is_account_activated(IntPtr thiz);

		/// <summary>
		/// Send a request to know if an account is activated on server. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorStatusRequestOk if the request has been sent,
		/// LinphoneAccountCreatorStatusRequestFailed otherwise </returns>
		public Linphone.AccountCreatorStatus IsAccountActivated()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_is_account_activated(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_is_account_exist(IntPtr thiz);

		/// <summary>
		/// Send a request to know the existence of account on server. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorStatusRequestOk if the request has been sent,
		/// LinphoneAccountCreatorStatusRequestFailed otherwise </returns>
		public Linphone.AccountCreatorStatus IsAccountExist()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_is_account_exist(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_is_account_linked(IntPtr thiz);

		/// <summary>
		/// Send a request to know if an account is linked. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorStatusRequestOk if the request has been sent,
		/// LinphoneAccountCreatorStatusRequestFailed otherwise </returns>
		public Linphone.AccountCreatorStatus IsAccountLinked()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_is_account_linked(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_is_alias_used(IntPtr thiz);

		/// <summary>
		/// Send a request to know if an alias is used. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorStatusRequestOk if the request has been sent,
		/// LinphoneAccountCreatorStatusRequestFailed otherwise </returns>
		public Linphone.AccountCreatorStatus IsAliasUsed()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_is_alias_used(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_link_account(IntPtr thiz);

		/// <summary>
		/// Send a request to link an account to an alias. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorStatusRequestOk if the request has been sent,
		/// LinphoneAccountCreatorStatusRequestFailed otherwise </returns>
		public Linphone.AccountCreatorStatus LinkAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_link_account(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_login_linphone_account(IntPtr thiz);

		/// <summary>
		/// Send a request to get the password & algorithm of an account using the
		/// confirmation key. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorStatusRequestOk if everything is OK, or a
		/// specific error otherwise. </returns>
		public Linphone.AccountCreatorStatus LoginLinphoneAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_login_linphone_account(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_recover_account(IntPtr thiz);

		/// <summary>
		/// Send a request to recover an account. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorStatusRequestOk if the request has been sent,
		/// LinphoneAccountCreatorStatusRequestFailed otherwise </returns>
		public Linphone.AccountCreatorStatus RecoverAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_recover_account(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_creator_reset(IntPtr thiz);

		/// <summary>
		/// Reset the account creator entries like username, password, phone number... 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void Reset()
		{
			linphone_account_creator_reset(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_account_creator_set_phone_number(IntPtr thiz, string phoneNumber, string countryCode);

		/// <summary>
		/// Set the phone number normalized. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">The phone number to set   </param>
		/// <param name="countryCode">Country code to associate phone number with   </param>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorPhoneNumberStatusOk if everything is OK, or
		/// specific(s) error(s) otherwise. </returns>
		public uint SetPhoneNumber(string phoneNumber, string countryCode)
		{
			uint returnVal = linphone_account_creator_set_phone_number(nativePtr, phoneNumber, countryCode);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_update_account(IntPtr thiz);

		/// <summary>
		/// Send a request to update an account. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>LinphoneAccountCreatorStatusRequestOk if the request has been sent,
		/// LinphoneAccountCreatorStatusRequestFailed otherwise </returns>
		public Linphone.AccountCreatorStatus UpdateAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_update_account(nativePtr);
			
			
			return returnVal;
		}
	}
	/// <summary>
	/// Object that represents a parsed SIP address. 
	/// <para>
	/// A SIP address is made of display name, username, domain name, port, and various
	/// uri headers (such as tags). It looks like 'Alice <sip:alice@example.net>'.
	/// 
	/// You can create an address using <see cref="Linphone.Factory.CreateAddress()" />
	/// or <see cref="Linphone.Core.InterpretUrl()" /> and both will return a null
	/// object if it doesn't match the grammar defined by the standard.
	/// 
	/// This object is used in almost every other major objects to identity people
	/// (including yourself) & servers.
	/// 
	/// The <see cref="Linphone.Address" /> has methods to extract and manipulate all
	/// parts of the address. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Address : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_display_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_address_set_display_name(IntPtr thiz, string displayName);

		/// <summary>
		/// Returns the display name. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the display name if any, null otherwise.   </returns>
		public string DisplayName
		{
			get
			{
				IntPtr stringPtr = linphone_address_get_display_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_address_set_display_name(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("DisplayName setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_domain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_address_set_domain(IntPtr thiz, string domain);

		/// <summary>
		/// Returns the domain name. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the domain name if any, null otherwise.   </returns>
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_address_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_address_set_domain(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Domain setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_is_sip(IntPtr thiz);

		/// <summary>
		/// returns whether the address is a routable SIP address or not 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if it is a routable SIP address, false otherwise </returns>
		public bool IsSip
		{
			get
			{
				return linphone_address_is_sip(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_method_param(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_method_param(IntPtr thiz, string methodParam);

		/// <summary>
		/// Get the value of the method parameter. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the value of the parameter or null.   </returns>
		public string MethodParam
		{
			get
			{
				IntPtr stringPtr = linphone_address_get_method_param(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_address_set_method_param(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_password(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_password(IntPtr thiz, string password);

		/// <summary>
		/// Get the password encoded in the address. 
		/// <para>
		/// It is used for basic authentication (not recommended). 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the password if any, null otherwise.   </returns>
		public string Password
		{
			get
			{
				IntPtr stringPtr = linphone_address_get_password(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_address_set_password(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_address_get_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_address_set_port(IntPtr thiz, int port);

		/// <summary>
		/// Get port number as an integer value, 0 if not present. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the port set in the address or 0 if not present. </returns>
		public int Port
		{
			get
			{
				return linphone_address_get_port(nativePtr);
			}
			set
			{
				int exception_result = linphone_address_set_port(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Port setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_scheme(IntPtr thiz);

		/// <summary>
		/// Returns the address scheme, normally "sip". 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the scheme if any, null otherwise.   </returns>
		public string Scheme
		{
			get
			{
				IntPtr stringPtr = linphone_address_get_scheme(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_get_secure(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_secure(IntPtr thiz, char enabled);

		/// <summary>
		/// Returns whether the address refers to a secure location (sips) or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if address refers to a secure location, false otherwise </returns>
		public bool Secure
		{
			get
			{
				return linphone_address_get_secure(nativePtr) != 0;
			}
			set
			{
				linphone_address_set_secure(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.TransportType linphone_address_get_transport(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_address_set_transport(IntPtr thiz, int transport);

		/// <summary>
		/// Get the transport. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a LinphoneTransportType, default value if not set is UDP. </returns>
		public Linphone.TransportType Transport
		{
			get
			{
				return linphone_address_get_transport(nativePtr);
			}
			set
			{
				int exception_result = linphone_address_set_transport(nativePtr, (int)value);
				if (exception_result != 0) throw new LinphoneException("Transport setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_uri_params(IntPtr thiz, string parameters);

		/// <summary>
		/// Set the value of the parameters of the URI of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The parameters string </param>
		/// 
		public string UriParams
		{
			set
			{
				linphone_address_set_uri_params(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_username(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_address_set_username(IntPtr thiz, string username);

		/// <summary>
		/// Returns the username. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the username name if any, null otherwise.   </returns>
		public string Username
		{
			get
			{
				IntPtr stringPtr = linphone_address_get_username(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_address_set_username(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Username setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_as_string(IntPtr thiz);

		/// <summary>
		/// Returns the address as a string. 
		/// <para>
		/// The returned char * must be freed by the application. Use ms_free(). 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a string representation of the address.   </returns>
		public string AsString()
		{
			IntPtr stringPtr = linphone_address_as_string(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_as_string_uri_only(IntPtr thiz);

		/// <summary>
		/// Returns the SIP uri only as a string, that is display name is removed. 
		/// <para>
		/// The returned char * must be freed by the application. Use ms_free(). 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a string representation of the address.   </returns>
		public string AsStringUriOnly()
		{
			IntPtr stringPtr = linphone_address_as_string_uri_only(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_clean(IntPtr thiz);

		/// <summary>
		/// Removes address's tags and uri headers so that it is displayable to the user. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void Clean()
		{
			linphone_address_clean(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_clone(IntPtr thiz);

		/// <summary>
		/// Clones a <see cref="Linphone.Address" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a new <see cref="Linphone.Address" /> object.   </returns>
		public Linphone.Address Clone()
		{
			IntPtr ptr = linphone_address_clone(nativePtr);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_equal(IntPtr thiz, IntPtr address2);

		/// <summary>
		/// Compare two <see cref="Linphone.Address" /> taking the tags and headers into
		/// account. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address2"><see cref="Linphone.Address" /> object.   </param>
		/// 
		/// 
		/// <returns>Boolean value telling if the <see cref="Linphone.Address" /> objects
		/// are equal. </returns>
		/// 
		/// <remarks>See : <see cref="Linphone.Address.WeakEqual()" /> </remarks>
		public bool Equal(Linphone.Address address2)
		{
			bool returnVal = linphone_address_equal(nativePtr, address2 != null ? address2.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Get the header encoded in the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">the header name.   </param>
		/// 
		/// 
		/// <returns>the header value or null if it doesn't exists.   </returns>
		public string GetHeader(string headerName)
		{
			IntPtr stringPtr = linphone_address_get_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_param(IntPtr thiz, string paramName);

		/// <summary>
		/// Get the value of a parameter of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="paramName">The name of the parameter.   </param>
		/// 
		/// 
		/// <returns>The value of the parameter or null if it doesn't exists.   </returns>
		public string GetParam(string paramName)
		{
			IntPtr stringPtr = linphone_address_get_param(nativePtr, paramName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_uri_param(IntPtr thiz, string uriParamName);

		/// <summary>
		/// Get the value of a parameter of the URI of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uriParamName">The name of the parameter.   </param>
		/// 
		/// 
		/// <returns>The value of the parameter or null if it doesn't exists.   </returns>
		public string GetUriParam(string uriParamName)
		{
			IntPtr stringPtr = linphone_address_get_uri_param(nativePtr, uriParamName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_has_param(IntPtr thiz, string paramName);

		/// <summary>
		/// Tell whether a parameter is present in the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="paramName">The name of the parameter.   </param>
		/// 
		/// 
		/// <returns>A boolean value telling whether the parameter is present in the
		/// address </returns>
		public bool HasParam(string paramName)
		{
			bool returnVal = linphone_address_has_param(nativePtr, paramName) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_has_uri_param(IntPtr thiz, string uriParamName);

		/// <summary>
		/// Tell whether a parameter is present in the URI of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uriParamName">The name of the parameter.   </param>
		/// 
		/// 
		/// <returns>A boolean value telling whether the parameter is present in the URI of
		/// the address </returns>
		public bool HasUriParam(string uriParamName)
		{
			bool returnVal = linphone_address_has_uri_param(nativePtr, uriParamName) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_remove_uri_param(IntPtr thiz, string uriParamName);

		/// <summary>
		/// Removes the value of a parameter of the URI of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uriParamName">The name of the parameter.   </param>
		/// 
		public void RemoveUriParam(string uriParamName)
		{
			linphone_address_remove_uri_param(nativePtr, uriParamName);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_header(IntPtr thiz, string headerName, string headerValue);

		/// <summary>
		/// Set a header into the address. 
		/// <para>
		/// Headers appear in the URI with '?', such as
		/// <sip:test@linphone.org?SomeHeader=SomeValue>. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="headerName">the header name.   </param>
		/// <param name="headerValue">the header value.   </param>
		/// 
		public void SetHeader(string headerName, string headerValue)
		{
			linphone_address_set_header(nativePtr, headerName, headerValue);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_param(IntPtr thiz, string paramName, string paramValue);

		/// <summary>
		/// Set the value of a parameter of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="paramName">The name of the parameter.   </param>
		/// <param name="paramValue">The new value of the parameter.   </param>
		/// 
		public void SetParam(string paramName, string paramValue)
		{
			linphone_address_set_param(nativePtr, paramName, paramValue);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_uri_param(IntPtr thiz, string uriParamName, string uriParamValue);

		/// <summary>
		/// Set the value of a parameter of the URI of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uriParamName">The name of the parameter.   </param>
		/// <param name="uriParamValue">The new value of the parameter.   </param>
		/// 
		public void SetUriParam(string uriParamName, string uriParamValue)
		{
			linphone_address_set_uri_param(nativePtr, uriParamName, uriParamValue);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_weak_equal(IntPtr thiz, IntPtr address2);

		/// <summary>
		/// Compare two <see cref="Linphone.Address" /> ignoring tags and headers,
		/// basically just domain, username, and port. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address2"><see cref="Linphone.Address" /> object.   </param>
		/// 
		/// 
		/// <returns>Boolean value telling if the <see cref="Linphone.Address" /> objects
		/// are equal. </returns>
		/// 
		/// <remarks>See : <see cref="Linphone.Address.Equal()" /> </remarks>
		public bool WeakEqual(Linphone.Address address2)
		{
			bool returnVal = linphone_address_weak_equal(nativePtr, address2 != null ? address2.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			return returnVal;
		}
	}
	/// <summary>
	/// Object holding audio device information. 
	/// <para>
	/// It contains the name of the device, it's type if available (Earpiece, Speaker,
	/// Bluetooth, etc..) and capabilities (input, output or both) the name of the
	/// driver that created it (filter in mediastreamer).
	/// 
	/// You can use the <see cref="Linphone.AudioDevice" /> objects to configure
	/// default input/output devices or do it dynamically during a call.
	/// 
	/// To get the list of available devices, use <see
	/// cref="Linphone.Core.GetAudioDevices()" />. This list will be limited to one
	/// device of each type. Use <see cref="Linphone.Core.GetExtendedAudioDevices()" />
	/// for a complete list. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class AudioDevice : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AudioDeviceCapabilities linphone_audio_device_get_capabilities(IntPtr thiz);

		/// <summary>
		/// Returns the capabilities of the device. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the LinphoneAudioDeviceCapabilities of the audio device (RECORD, PLAY
		/// or both) as a bit mask </returns>
		public Linphone.AudioDeviceCapabilities Capabilities
		{
			get
			{
				return linphone_audio_device_get_capabilities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_audio_device_get_device_name(IntPtr thiz);

		/// <summary>
		/// Returns the name of the audio device. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the name of the audio device.   </returns>
		public string DeviceName
		{
			get
			{
				IntPtr stringPtr = linphone_audio_device_get_device_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_audio_device_get_driver_name(IntPtr thiz);

		/// <summary>
		/// Returns the driver name used by the device. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the name of the driver used by this audio device.   </returns>
		public string DriverName
		{
			get
			{
				IntPtr stringPtr = linphone_audio_device_get_driver_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_audio_device_get_id(IntPtr thiz);

		/// <summary>
		/// Returns the id of the audio device. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the id of the audio device.   </returns>
		public string Id
		{
			get
			{
				IntPtr stringPtr = linphone_audio_device_get_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AudioDeviceType linphone_audio_device_get_type(IntPtr thiz);

		/// <summary>
		/// Returns the type of the device. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the LinphoneAudioDeviceType of the audio device (microphone, speaker,
		/// earpiece, bluetooth, etc...) </returns>
		public Linphone.AudioDeviceType Type
		{
			get
			{
				return linphone_audio_device_get_type(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_audio_device_has_capability(IntPtr thiz, int capability);

		/// <summary>
		/// Returns whether or not the audio device has the given capability. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">the LinphoneAudioDeviceCapabilities to check </param>
		/// 
		/// 
		/// <returns>true if the audio device has the capability, false otherwise </returns>
		public bool HasCapability(Linphone.AudioDeviceCapabilities capability)
		{
			bool returnVal = linphone_audio_device_has_capability(nativePtr, (int)capability) == (char)0 ? false : true;
			
			return returnVal;
		}
	}
	/// <summary>
	/// Object holding authentication information. 
	/// <para>
	/// In most case, authentication information consists of a username and password.
	/// If realm isn't set, it will be deduced automatically from the first
	/// authentication challenge as for the hash algorithm. Sometimes, a userid is
	/// required by the proxy and then domain can be useful to discriminate different
	/// credentials. You can also use this object if you need to use a client
	/// certificate.
	/// 
	/// Once created and filled, a <see cref="Linphone.AuthInfo" /> must be added to
	/// the <see cref="Linphone.Core" /> in order to become known and used
	/// automatically when needed. Use <see cref="Linphone.Core.AddAuthInfo()" /> for
	/// that purpose.
	/// 
	/// The <see cref="Linphone.Core" /> object can take the initiative to request
	/// authentication information when needed to the application through the
	/// authentication_requested() callback of it's LinphoneCoreCbs.
	/// 
	/// The application can respond to this information request later using <see
	/// cref="Linphone.Core.AddAuthInfo()" />. This will unblock all pending
	/// authentication transactions and retry them with authentication headers. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class AuthInfo : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_algorithm(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_algorithm(IntPtr thiz, string algorithm);

		/// <summary>
		/// Gets the algorithm. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The algorithm.   </returns>
		public string Algorithm
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_algorithm(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_algorithm(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_available_algorithms(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_available_algorithms(IntPtr thiz, IntPtr algorithms);

		/// <summary>
		/// Gets all available algorithms. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of const char * objects. const char *  A list of available
		/// algorithms.   </returns>
		public IEnumerable<string> AvailableAlgorithms
		{
			get
			{
				return MarshalStringArray(linphone_auth_info_get_available_algorithms(nativePtr));
			}
			set
			{
				linphone_auth_info_set_available_algorithms(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_domain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_domain(IntPtr thiz, string domain);

		/// <summary>
		/// Gets the domain. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The domain.   </returns>
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_domain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_ha1(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_ha1(IntPtr thiz, string ha1);

		/// <summary>
		/// Gets the ha1. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The ha1.   </returns>
		public string Ha1
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_ha1(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_ha1(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_password(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_password(IntPtr thiz, string password);

		/// <summary>
		/// Gets the password. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The password.   </returns>
		public string Password
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_password(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_password(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_realm(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_realm(IntPtr thiz, string realm);

		/// <summary>
		/// Gets the realm. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The realm.   </returns>
		public string Realm
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_realm(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_realm(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_tls_cert(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_tls_cert(IntPtr thiz, string tlsCert);

		/// <summary>
		/// Gets the TLS certificate. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The TLS certificate.   </returns>
		public string TlsCert
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_tls_cert(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_tls_cert(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_tls_cert_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_tls_cert_path(IntPtr thiz, string tlsCertPath);

		/// <summary>
		/// Gets the TLS certificate path. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The TLS certificate path.   </returns>
		public string TlsCertPath
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_tls_cert_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_tls_cert_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_tls_key(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_tls_key(IntPtr thiz, string tlsKey);

		/// <summary>
		/// Gets the TLS key. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The TLS key.   </returns>
		public string TlsKey
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_tls_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_tls_key(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_tls_key_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_tls_key_path(IntPtr thiz, string tlsKeyPath);

		/// <summary>
		/// Gets the TLS key path. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The TLS key path.   </returns>
		public string TlsKeyPath
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_tls_key_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_tls_key_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_userid(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_userid(IntPtr thiz, string userId);

		/// <summary>
		/// Gets the user id. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The user id.   </returns>
		public string Userid
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_userid(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_userid(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_username(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_username(IntPtr thiz, string username);

		/// <summary>
		/// Gets the username. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The username.   </returns>
		public string Username
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_username(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_username(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_add_available_algorithm(IntPtr thiz, string algorithm);

		/// <summary>
		/// Add an unique algorithm in the the available algorithms list : Algorithms that
		/// already exist will not be added. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="algorithm">The algorithm to add.   </param>
		/// 
		public void AddAvailableAlgorithm(string algorithm)
		{
			linphone_auth_info_add_available_algorithm(nativePtr, algorithm);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_clear_available_algorithms(IntPtr thiz);

		/// <summary>
		/// Remove all algorithms from the available algorithms list. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void ClearAvailableAlgorithms()
		{
			linphone_auth_info_clear_available_algorithms(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_clone(IntPtr thiz);

		/// <summary>
		/// Instantiates a new auth info with values from source. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The newly created <see cref="Linphone.AuthInfo" /> object.   </returns>
		public Linphone.AuthInfo Clone()
		{
			IntPtr ptr = linphone_auth_info_clone(nativePtr);
			Linphone.AuthInfo returnVal = fromNativePtr<Linphone.AuthInfo>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_auth_info_is_equal_but_algorithms(IntPtr thiz, IntPtr authInfo2);

		/// <summary>
		/// Check if Authinfos are the same without taking account algorithms. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="authInfo2">The second <see cref="Linphone.AuthInfo" /> object.  
		/// </param>
		/// 
		/// 
		/// <returns>true if all fields (Username, UserId, Realm, Domain) are the same.
		/// </returns>
		public bool IsEqualButAlgorithms(Linphone.AuthInfo authInfo2)
		{
			bool returnVal = linphone_auth_info_is_equal_but_algorithms(nativePtr, authInfo2 != null ? authInfo2.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			return returnVal;
		}
	}
	/// <summary>
	/// The object representing a data buffer. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Buffer : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_buffer_new_from_data(uint data, long size);

		/// <summary>
		/// Create a new <see cref="Linphone.Buffer" /> object from existing data. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="data">The initial data to store in the LinphoneBuffer.   </param>
		/// <param name="size">The size of the initial data to stroe in the LinphoneBuffer.
		/// </param>
		/// 
		/// 
		/// <returns>A new <see cref="Linphone.Buffer" /> object.   </returns>
		public static Linphone.Buffer NewFromData(uint data, long size)
		{
			IntPtr ptr = linphone_buffer_new_from_data(data, size);
			Linphone.Buffer returnVal = fromNativePtr<Linphone.Buffer>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_buffer_new_from_string(string data);

		/// <summary>
		/// Create a new <see cref="Linphone.Buffer" /> object from a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="data">The initial string content of the LinphoneBuffer.   </param>
		/// 
		/// 
		/// <returns>A new <see cref="Linphone.Buffer" /> object.   </returns>
		public static Linphone.Buffer NewFromString(string data)
		{
			IntPtr ptr = linphone_buffer_new_from_string(data);
			Linphone.Buffer returnVal = fromNativePtr<Linphone.Buffer>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_buffer_get_content(IntPtr thiz);

		/// <summary>
		/// Get the content of the data buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The content of the data buffer.   </returns>
		public uint Content
		{
			get
			{
				return linphone_buffer_get_content(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_buffer_is_empty(IntPtr thiz);

		/// <summary>
		/// Tell whether the <see cref="Linphone.Buffer" /> is empty. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether the <see cref="Linphone.Buffer" /> is
		/// empty or not. </returns>
		public bool IsEmpty
		{
			get
			{
				return linphone_buffer_is_empty(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_buffer_get_size(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_buffer_set_size(IntPtr thiz, long size);

		/// <summary>
		/// Get the size of the content of the data buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The size of the content of the data buffer. </returns>
		public long Size
		{
			get
			{
				return linphone_buffer_get_size(nativePtr);
			}
			set
			{
				linphone_buffer_set_size(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_buffer_get_string_content(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_buffer_set_string_content(IntPtr thiz, string content);

		/// <summary>
		/// Get the string content of the data buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The string content of the data buffer.   </returns>
		public string StringContent
		{
			get
			{
				IntPtr stringPtr = linphone_buffer_get_string_content(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_buffer_set_string_content(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_buffer_set_content(IntPtr thiz, uint content, long size);

		/// <summary>
		/// Set the content of the data buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">The content of the data buffer.   </param>
		/// <param name="size">The size of the content of the data buffer. </param>
		/// 
		public void SetContent(uint content, long size)
		{
			linphone_buffer_set_content(nativePtr, content, size);
			
			
			
		}
	}
	/// <summary>
	/// This object represents a call issued or received by the <see
	/// cref="Linphone.Core" />. 
	/// <para>
	/// You may have multiple calls at the same time, but only one will be in
	/// LinphoneCallStateStreamsRunning at any time unless they are merged into a <see
	/// cref="Linphone.Conference" />, others will be paused.
	/// 
	/// You can get the LinphoneCallState of the call using <see
	/// cref="Linphone.Call.GetState()" />, it's current <see
	/// cref="Linphone.CallParams" /> with <see cref="Linphone.Call.GetCurrentParams()"
	/// /> and the latest statistics by calling <see
	/// cref="Linphone.Call.GetAudioStats()" /> or <see
	/// cref="Linphone.Call.GetVideoStats()" />. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Call : LinphoneObject
	{
		/// Get the native window handle of the video window, casted as an unsigned long.
		public string NativeVideoWindowIdString
		{
			get
			{
				return Marshal.PtrToStringUni(linphone_call_get_native_video_window_id(nativePtr));
			}
			set
			{
				IntPtr string_ptr_to_remove = linphone_call_get_native_video_window_id(nativePtr);
				IntPtr string_ptr = Marshal.StringToHGlobalUni(value);
				linphone_call_set_native_video_window_id(nativePtr, string_ptr);
				if(string_ptr_to_remove != IntPtr.Zero)
					Marshal.FreeHGlobal(string_ptr_to_remove);
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_call_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_remove_callbacks(IntPtr thiz, IntPtr cbs);

		~Call() 
		{
			if (listener != null)
			{
				linphone_call_remove_callbacks(nativePtr, listener.nativePtr);
			}
		}

		private CallListener listener;

		public CallListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_call_cbs(linphone_factory_get());
					listener = fromNativePtr<CallListener>(nativeListener, false);
					linphone_call_add_callbacks(nativePtr, nativeListener);
					listener.register();
				}
				return listener;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_audio_stats(IntPtr thiz);

		/// <summary>
		/// Returns a copy of the call statistics for the audio stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.CallStats" /> object for the audio stream or
		/// null if it isn't available.   </returns>
		public Linphone.CallStats AudioStats
		{
			get
			{
				IntPtr ptr = linphone_call_get_audio_stats(nativePtr);
				Linphone.CallStats obj = fromNativePtr<Linphone.CallStats>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_authentication_token(IntPtr thiz);

		/// <summary>
		/// Returns the ZRTP authentication token to verify. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the authentication token to verify or null if ZRTP isn't enabled.  
		/// </returns>
		public string AuthenticationToken
		{
			get
			{
				IntPtr stringPtr = linphone_call_get_authentication_token(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_get_authentication_token_verified(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_authentication_token_verified(IntPtr thiz, char verified);

		/// <summary>
		/// Returns whether ZRTP authentication token is verified. 
		/// <para>
		/// If not, it must be verified by users as described in ZRTP procedure. Once done,
		/// the application must inform of the results with <see
		/// cref="Linphone.Call.SetAuthenticationTokenVerified()" />. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if authentication token is verifed, false otherwise. </returns>
		public bool AuthenticationTokenVerified
		{
			get
			{
				return linphone_call_get_authentication_token_verified(nativePtr) != 0;
			}
			set
			{
				linphone_call_set_authentication_token_verified(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_get_average_quality(IntPtr thiz);

		/// <summary>
		/// Returns call quality averaged over all the duration of the call. 
		/// <para>
		/// See <see cref="Linphone.Call.GetCurrentQuality()" /> for more details about
		/// quality measurement. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the call average quality since tbe beginning of the call. </returns>
		public float AverageQuality
		{
			get
			{
				return linphone_call_get_average_quality(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_call_log(IntPtr thiz);

		/// <summary>
		/// Gets the call log associated to this call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The <see cref="Linphone.CallLog" /> associated with the specified <see
		/// cref="Linphone.Call" />.   </returns>
		public Linphone.CallLog CallLog
		{
			get
			{
				IntPtr ptr = linphone_call_get_call_log(nativePtr);
				Linphone.CallLog obj = fromNativePtr<Linphone.CallLog>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_camera_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_enable_camera(IntPtr thiz, char enabled);

		/// <summary>
		/// Returns if camera pictures are allowed to be sent to the remote party. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if local video stream is being sent, false otherwise. </returns>
		public bool CameraEnabled
		{
			get
			{
				return linphone_call_camera_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_enable_camera(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_chat_room(IntPtr thiz);

		/// <summary>
		/// Create a new chat room for real time messaging from a call if not already
		/// existing, else return existing one. 
		/// <para>
		/// No reference is given to the caller: the chat room will be deleted when the
		/// call is ended. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.ChatRoom" /> where real time messaging can take
		/// place or null if chat room couldn't be created.   </returns>
		public Linphone.ChatRoom ChatRoom
		{
			get
			{
				IntPtr ptr = linphone_call_get_chat_room(nativePtr);
				Linphone.ChatRoom obj = fromNativePtr<Linphone.ChatRoom>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_conference(IntPtr thiz);

		/// <summary>
		/// Return the associated conference object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A pointer on <see cref="Linphone.Conference" /> or null if the call is
		/// not part of any conference.   </returns>
		public Linphone.Conference Conference
		{
			get
			{
				IntPtr ptr = linphone_call_get_conference(nativePtr);
				Linphone.Conference obj = fromNativePtr<Linphone.Conference>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_core(IntPtr thiz);

		/// <summary>
		/// Get the core that has created the specified call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The <see cref="Linphone.Core" /> object that has created the specified
		/// call.   </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_call_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_current_callbacks(IntPtr thiz);

		/// <summary>
		/// Gets the current LinphoneCallCbs. 
		/// <para>
		/// This is meant only to be called from a callback to be able to get the user_data
		/// associated with the LinphoneCallCbs that is calling the callback. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneCallCbs that has called the last callback   </returns>
		public Linphone.CallListener CurrentCallbacks
		{
			get
			{
				IntPtr ptr = linphone_call_get_current_callbacks(nativePtr);
				Linphone.CallListener obj = fromNativePtr<Linphone.CallListener>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_current_params(IntPtr thiz);

		/// <summary>
		/// Returns current parameters associated to the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the current <see cref="Linphone.CallParams" /> of this call.  
		/// </returns>
		public Linphone.CallParams CurrentParams
		{
			get
			{
				IntPtr ptr = linphone_call_get_current_params(nativePtr);
				Linphone.CallParams obj = fromNativePtr<Linphone.CallParams>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_get_current_quality(IntPtr thiz);

		/// <summary>
		/// Obtain real-time quality rating of the call. 
		/// <para>
		/// Based on local RTP statistics and RTCP feedback, a quality rating is computed
		/// and updated during all the duration of the call. This function returns its
		/// value at the time of the function call. It is expected that the rating is
		/// updated at least every 5 seconds or so. The rating is a floating point number
		/// comprised between 0 and 5.
		/// 
		/// 4-5 = good quality  3-4 = average quality  2-3 = poor quality  1-2 = very poor
		/// quality  0-1 = can't be worse, mostly unusable 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The function returns -1 if no quality measurement is available, for
		/// example if no active audio stream exist. Otherwise it returns the quality
		/// rating. </returns>
		public float CurrentQuality
		{
			get
			{
				return linphone_call_get_current_quality(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.CallDir linphone_call_get_dir(IntPtr thiz);

		/// <summary>
		/// Returns direction of the call (incoming or outgoing). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the LinphoneCallDir </returns>
		public Linphone.CallDir Dir
		{
			get
			{
				return linphone_call_get_dir(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_diversion_address(IntPtr thiz);

		/// <summary>
		/// Returns the diversion address associated to this call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the diversion address as <see cref="Linphone.Address" /> or null.  
		/// </returns>
		public Linphone.Address DiversionAddress
		{
			get
			{
				IntPtr ptr = linphone_call_get_diversion_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_get_duration(IntPtr thiz);

		/// <summary>
		/// Returns call's duration in seconds. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the call's duration in seconds. </returns>
		public int Duration
		{
			get
			{
				return linphone_call_get_duration(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_echo_cancellation_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_enable_echo_cancellation(IntPtr thiz, char enable);

		/// <summary>
		/// Returns if echo cancellation is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if echo cancellation is enabled, false otherwise. </returns>
		public bool EchoCancellationEnabled
		{
			get
			{
				return linphone_call_echo_cancellation_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_enable_echo_cancellation(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_echo_limiter_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_enable_echo_limiter(IntPtr thiz, char enable);

		/// <summary>
		/// Returns if echo limiter is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if echo limiter is enabled, false otherwise. </returns>
		public bool EchoLimiterEnabled
		{
			get
			{
				return linphone_call_echo_limiter_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_enable_echo_limiter(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_error_info(IntPtr thiz);

		/// <summary>
		/// Returns full details about call errors or termination reasons. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.ErrorInfo" /> object holding the reason error.  
		/// </returns>
		public Linphone.ErrorInfo ErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_call_get_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_input_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_input_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the current input device for this call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.AudioDevice" /> used by this call as input or
		/// null if there is currently no soundcard configured (depending on the state of
		/// the call)   </returns>
		public Linphone.AudioDevice InputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_call_get_input_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_set_input_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_is_recording(IntPtr thiz);

		/// <summary>
		/// Returns whether or not the call is currently being recorded. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if recording is in progress, false otherwise </returns>
		public bool IsRecording
		{
			get
			{
				return linphone_call_is_recording(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_get_microphone_muted(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_microphone_muted(IntPtr thiz, char muted);

		/// <summary>
		/// Get microphone muted state. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The microphone muted state. </returns>
		public bool MicrophoneMuted
		{
			get
			{
				return linphone_call_get_microphone_muted(nativePtr) != 0;
			}
			set
			{
				linphone_call_set_microphone_muted(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_get_microphone_volume_gain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_microphone_volume_gain(IntPtr thiz, float volume);

		/// <summary>
		/// Get microphone volume gain. 
		/// <para>
		/// If the sound backend supports it, the returned gain is equal to the gain set
		/// with the system mixer. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>double Percentage of the max supported volume gain. Valid values are
		/// in [ 0.0 : 1.0 ]. In case of failure, a negative value is returned </returns>
		public float MicrophoneVolumeGain
		{
			get
			{
				return linphone_call_get_microphone_volume_gain(nativePtr);
			}
			set
			{
				linphone_call_set_microphone_volume_gain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_native_video_window_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_native_video_window_id(IntPtr thiz, IntPtr windowId);

		/// <summary>
		/// Get the native window handle of the video window, casted as an unsigned long. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the native video window id (type may vary depending on platform).  
		/// </returns>
		public IntPtr NativeVideoWindowId
		{
			get
			{
				return linphone_call_get_native_video_window_id(nativePtr);
			}
			set
			{
				linphone_call_set_native_video_window_id(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_output_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_output_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the current output device for this call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.AudioDevice" /> used by this call as output or
		/// null if there is currently no soundcard configured (depending on the state of
		/// the call)   </returns>
		public Linphone.AudioDevice OutputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_call_get_output_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_set_output_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_params(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Returns local parameters associated with the call. 
		/// <para>
		/// This is typically the parameters passed at call initiation to <see
		/// cref="Linphone.Core.InviteAddressWithParams()" /> or <see
		/// cref="Linphone.Call.AcceptWithParams()" />, or some default parameters if no
		/// <see cref="Linphone.CallParams" /> was explicitely passed during call
		/// initiation. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the call's local parameters.   </returns>
		public Linphone.CallParams Params
		{
			get
			{
				IntPtr ptr = linphone_call_get_params(nativePtr);
				Linphone.CallParams obj = fromNativePtr<Linphone.CallParams>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_set_params(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_get_play_volume(IntPtr thiz);

		/// <summary>
		/// Get the mesured playback volume level (received from remote) in dbm0. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>float Volume level in percentage. </returns>
		public float PlayVolume
		{
			get
			{
				return linphone_call_get_play_volume(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_player(IntPtr thiz);

		/// <summary>
		/// Gets a player associated with the call to play a local file and stream it to
		/// the remote peer. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Player" /> object   </returns>
		public Linphone.Player Player
		{
			get
			{
				IntPtr ptr = linphone_call_get_player(nativePtr);
				Linphone.Player obj = fromNativePtr<Linphone.Player>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.Reason linphone_call_get_reason(IntPtr thiz);

		/// <summary>
		/// Returns the reason for a call termination (either error or normal termination) 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the LinphoneReason of the call termination. </returns>
		public Linphone.Reason Reason
		{
			get
			{
				return linphone_call_get_reason(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_get_record_volume(IntPtr thiz);

		/// <summary>
		/// Get the mesured record volume level (sent to remote) in dbm0. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>float Volume level in percentage. </returns>
		public float RecordVolume
		{
			get
			{
				return linphone_call_get_record_volume(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_refer_to(IntPtr thiz);

		/// <summary>
		/// Gets the refer-to uri (if the call was transfered). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The refer-to uri of the call (if it was transfered).   </returns>
		public string ReferTo
		{
			get
			{
				IntPtr stringPtr = linphone_call_get_refer_to(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_remote_address(IntPtr thiz);

		/// <summary>
		/// Returns the remote address associated to this call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The <see cref="Linphone.Address" /> of the remote end of the call.  
		/// </returns>
		public Linphone.Address RemoteAddress
		{
			get
			{
				IntPtr ptr = linphone_call_get_remote_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_remote_address_as_string(IntPtr thiz);

		/// <summary>
		/// Returns the remote address associated to this call as a string. 
		/// <para>
		/// The result string must be freed by user using ms_free(). 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the remote address as a string.   </returns>
		/// 
		/// deprecated : 06/07/2020 use <see cref="Linphone.Call.GetRemoteAddress()" />
		/// instead. 
		public string RemoteAddressAsString
		{
			get
			{
				IntPtr stringPtr = linphone_call_get_remote_address_as_string(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_remote_contact(IntPtr thiz);

		/// <summary>
		/// Returns the far end's sip contact as a string, if available. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the remote contact or null.   </returns>
		public string RemoteContact
		{
			get
			{
				IntPtr stringPtr = linphone_call_get_remote_contact(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_remote_params(IntPtr thiz);

		/// <summary>
		/// Returns call parameters proposed by remote. 
		/// <para>
		/// This is useful when receiving an incoming call, to know whether the remote
		/// party supports video, encryption or whatever.
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.CallParams" /> suggested by the remote or
		/// null.   </returns>
		public Linphone.CallParams RemoteParams
		{
			get
			{
				IntPtr ptr = linphone_call_get_remote_params(nativePtr);
				Linphone.CallParams obj = fromNativePtr<Linphone.CallParams>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_remote_user_agent(IntPtr thiz);

		/// <summary>
		/// Returns the far end's user agent description string, if available. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the remote user agent or null.   </returns>
		public string RemoteUserAgent
		{
			get
			{
				IntPtr stringPtr = linphone_call_get_remote_user_agent(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_replaced_call(IntPtr thiz);

		/// <summary>
		/// Returns the call object this call is replacing, if any. 
		/// <para>
		/// Call replacement can occur during call transfers. By default, the core
		/// automatically terminates the replaced call and accept the new one. This
		/// function allows the application to know whether a new incoming call is a one
		/// that replaces another one. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Call" /> object this call is replacing or
		/// null.   </returns>
		public Linphone.Call ReplacedCall
		{
			get
			{
				IntPtr ptr = linphone_call_get_replaced_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_get_speaker_muted(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_speaker_muted(IntPtr thiz, char muted);

		/// <summary>
		/// Get speaker muted state. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The speaker muted state. </returns>
		public bool SpeakerMuted
		{
			get
			{
				return linphone_call_get_speaker_muted(nativePtr) != 0;
			}
			set
			{
				linphone_call_set_speaker_muted(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_get_speaker_volume_gain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_speaker_volume_gain(IntPtr thiz, float volume);

		/// <summary>
		/// Get speaker volume gain. 
		/// <para>
		/// If the sound backend supports it, the returned gain is equal to the gain set
		/// with the system mixer. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Percentage of the max supported volume gain. Valid values are in [ 0.0
		/// : 1.0 ]. In case of failure, a negative value is returned </returns>
		public float SpeakerVolumeGain
		{
			get
			{
				return linphone_call_get_speaker_volume_gain(nativePtr);
			}
			set
			{
				linphone_call_set_speaker_volume_gain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.CallState linphone_call_get_state(IntPtr thiz);

		/// <summary>
		/// Retrieves the call's current state. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the current LinphoneCallState of this call. </returns>
		public Linphone.CallState State
		{
			get
			{
				return linphone_call_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_get_stream_count(IntPtr thiz);

		/// <summary>
		/// Returns the number of stream for the given call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the amount of streams for this call. </returns>
		public int StreamCount
		{
			get
			{
				return linphone_call_get_stream_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_text_stats(IntPtr thiz);

		/// <summary>
		/// Returns a copy of the call statistics for the text stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.CallStats" /> object for the text stream or null
		/// if it isn't available.   </returns>
		public Linphone.CallStats TextStats
		{
			get
			{
				IntPtr ptr = linphone_call_get_text_stats(nativePtr);
				Linphone.CallStats obj = fromNativePtr<Linphone.CallStats>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_to_address(IntPtr thiz);

		/// <summary>
		/// Returns the to address with its headers associated to this call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the #LinphoneAdress matching the TO of the call.   </returns>
		public Linphone.Address ToAddress
		{
			get
			{
				IntPtr ptr = linphone_call_get_to_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.CallState linphone_call_get_transfer_state(IntPtr thiz);

		/// <summary>
		/// Returns the current transfer state, if a transfer has been initiated from this
		/// call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>See : linphone_core_transfer_call ,
		/// linphone_core_transfer_call_to_another </remarks>
		/// 
		/// <returns>the LinphoneCallState. </returns>
		public Linphone.CallState TransferState
		{
			get
			{
				return linphone_call_get_transfer_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_transfer_target_call(IntPtr thiz);

		/// <summary>
		/// When this call has received a transfer request, returns the new call that was
		/// automatically created as a result of the transfer. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the transfer <see cref="Linphone.Call" /> created.   </returns>
		public Linphone.Call TransferTargetCall
		{
			get
			{
				IntPtr ptr = linphone_call_get_transfer_target_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_transferer_call(IntPtr thiz);

		/// <summary>
		/// Gets the transferer if this call was started automatically as a result of an
		/// incoming transfer request. 
		/// <para>
		/// The call in which the transfer request was received is returned in this case. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The transferer <see cref="Linphone.Call" /> if the specified call was
		/// started automatically as a result of an incoming transfer request, null
		/// otherwise.   </returns>
		public Linphone.Call TransfererCall
		{
			get
			{
				IntPtr ptr = linphone_call_get_transferer_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_video_stats(IntPtr thiz);

		/// <summary>
		/// Returns a copy of the call statistics for the video stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.CallStats" /> object for the video stream or
		/// null if it isn't available.   </returns>
		public Linphone.CallStats VideoStats
		{
			get
			{
				IntPtr ptr = linphone_call_get_video_stats(nativePtr);
				Linphone.CallStats obj = fromNativePtr<Linphone.CallStats>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_accept(IntPtr thiz);

		/// <summary>
		/// Accept an incoming call. 
		/// <para>
		/// Basically the application is notified of incoming calls within the
		/// call_state_changed callback of the LinphoneCoreVTable structure, where it will
		/// receive a LinphoneCallIncoming event with the associated <see
		/// cref="Linphone.Call" /> object. The application can later accept the call using
		/// this method. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 on success, -1 on failure </returns>
		public void Accept()
		{
			int exception_result = linphone_call_accept(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Accept returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_accept_early_media(IntPtr thiz);

		/// <summary>
		/// Accept an early media session for an incoming call. 
		/// <para>
		/// This is identical as calling <see
		/// cref="Linphone.Call.AcceptEarlyMediaWithParams()" /> with null parameters. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, -1 otherwise </returns>
		/// 
		/// <remarks>See : <see cref="Linphone.Call.AcceptEarlyMediaWithParams()" />
		/// </remarks>
		public void AcceptEarlyMedia()
		{
			int exception_result = linphone_call_accept_early_media(nativePtr);
			if (exception_result != 0) throw new LinphoneException("AcceptEarlyMedia returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_accept_early_media_with_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// When receiving an incoming, accept to start a media session as early-media. 
		/// <para>
		/// This means the call is not accepted but audio & video streams can be
		/// established if the remote party supports early media. However, unlike after
		/// call acceptance, mic and camera input are not sent during early-media, though
		/// received audio & video are played normally. The call can then later be fully
		/// accepted using <see cref="Linphone.Call.Accept()" /> or <see
		/// cref="Linphone.Call.AcceptWithParams()" />. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="parameters">The call parameters to use (can be null).   </param>
		/// 
		/// 
		/// <returns>0 if successful, -1 otherwise </returns>
		public void AcceptEarlyMediaWithParams(Linphone.CallParams parameters)
		{
			int exception_result = linphone_call_accept_early_media_with_params(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AcceptEarlyMediaWithParams returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_accept_update(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Accept call modifications initiated by other end. 
		/// <para>
		/// This call may be performed in response to a #LinphoneCallUpdatedByRemote state
		/// notification. When such notification arrives, the application can decide to
		/// call <see cref="Linphone.Call.DeferUpdate()" /> so that it can have the time to
		/// prompt the user. <see cref="Linphone.Call.GetRemoteParams()" /> can be used to
		/// get information about the call parameters requested by the other party, such as
		/// whether a video stream is requested.
		/// 
		/// When the user accepts or refuse the change, <see
		/// cref="Linphone.Call.AcceptUpdate()" /> can be done to answer to the other
		/// party. If params is null, then the same call parameters established before the
		/// update request will continue to be used (no change). If params is not null,
		/// then the update will be accepted according to the parameters passed. Typical
		/// example is when a user accepts to start video, then params should indicate that
		/// video stream should be used (see <see cref="Linphone.CallParams.EnableVideo()"
		/// />). 
		/// 
		/// </para>
		/// </summary>
		/// <param name="parameters">A <see cref="Linphone.CallParams" /> object describing
		/// the call parameters to accept.   </param>
		/// 
		/// 
		/// <returns>0 if successful, -1 otherwise (actually when this function call is
		/// performed outside ot #LinphoneCallUpdatedByRemote state) </returns>
		public void AcceptUpdate(Linphone.CallParams parameters)
		{
			int exception_result = linphone_call_accept_update(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AcceptUpdate returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_accept_with_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Accept an incoming call, with parameters. 
		/// <para>
		/// Basically the application is notified of incoming calls within the
		/// call_state_changed callback of the LinphoneCoreVTable structure, where it will
		/// receive a LinphoneCallIncoming event with the associated <see
		/// cref="Linphone.Call" /> object. The application can later accept the call using
		/// this method. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="parameters">The specific parameters for this call, for example
		/// whether video is accepted or not. Use null to use default parameters.   </param>
		/// 
		/// 
		/// <returns>0 on success, -1 on failure </returns>
		public void AcceptWithParams(Linphone.CallParams parameters)
		{
			int exception_result = linphone_call_accept_with_params(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AcceptWithParams returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_asked_to_autoanswer(IntPtr thiz);

		/// <summary>
		/// Tell whether a call has been asked to autoanswer. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether the call has been asked to autoanswer
		/// </returns>
		public bool AskedToAutoanswer()
		{
			bool returnVal = linphone_call_asked_to_autoanswer(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_cancel_dtmfs(IntPtr thiz);

		/// <summary>
		/// Stop current DTMF sequence sending. 
		/// <para>
		/// Please note that some DTMF could be already sent, depending on when this
		/// function call is delayed from linphone_call_send_dtmfs. This function will be
		/// automatically called if call state change to anything but
		/// LinphoneCallStreamsRunning. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void CancelDtmfs()
		{
			linphone_call_cancel_dtmfs(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_decline(IntPtr thiz, int reason);

		/// <summary>
		/// Decline a pending incoming call, with a reason. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="reason">The reason for rejecting the call: LinphoneReasonDeclined
		/// or LinphoneReasonBusy </param>
		/// 
		/// 
		/// <returns>0 on success, -1 on failure </returns>
		public void Decline(Linphone.Reason reason)
		{
			int exception_result = linphone_call_decline(nativePtr, (int)reason);
			if (exception_result != 0) throw new LinphoneException("Decline returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_decline_with_error_info(IntPtr thiz, IntPtr ei);

		/// <summary>
		/// Decline a pending incoming call, with a <see cref="Linphone.ErrorInfo" />
		/// object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="ei"><see cref="Linphone.ErrorInfo" /> containing more information
		/// on the call rejection.   </param>
		/// 
		/// 
		/// <returns>0 on success, -1 on failure </returns>
		public int DeclineWithErrorInfo(Linphone.ErrorInfo ei)
		{
			int returnVal = linphone_call_decline_with_error_info(nativePtr, ei != null ? ei.nativePtr : IntPtr.Zero);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_defer_update(IntPtr thiz);

		/// <summary>
		/// When receiving a #LinphoneCallUpdatedByRemote state notification, prevent <see
		/// cref="Linphone.Core" /> from performing an automatic answer. 
		/// <para>
		/// When receiving a #LinphoneCallUpdatedByRemote state notification (ie an
		/// incoming reINVITE), the default behaviour of <see cref="Linphone.Core" /> is
		/// defined by the "defer_update_default" option of the "sip" section of the
		/// config. If this option is 0 (the default) then the <see cref="Linphone.Core" />
		/// automatically answers the reINIVTE with call parameters unchanged. However when
		/// for example when the remote party updated the call to propose a video stream,
		/// it can be useful to prompt the user before answering. This can be achieved by
		/// calling linphone_core_defer_call_update during the call state notification, to
		/// deactivate the automatic answer that would just confirm the audio but reject
		/// the video. Then, when the user responds to dialog prompt, it becomes possible
		/// to call <see cref="Linphone.Call.AcceptUpdate()" /> to answer the reINVITE,
		/// with eventually video enabled in the <see cref="Linphone.CallParams" />
		/// argument.
		/// 
		/// The #LinphoneCallUpdatedByRemote notification can also arrive when receiving an
		/// INVITE without SDP. In such case, an unchanged offer is made in the 200Ok, and
		/// when the ACK containing the SDP answer is received,
		/// #LinphoneCallUpdatedByRemote is triggered to notify the application of possible
		/// changes in the media session. However in such case defering the update has no
		/// meaning since we just generating an offer.
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, -1 if the <see cref="Linphone.Call.DeferUpdate()" />
		/// was done outside a valid #LinphoneCallUpdatedByRemote notification </returns>
		public void DeferUpdate()
		{
			int exception_result = linphone_call_defer_update(nativePtr);
			if (exception_result != 0) throw new LinphoneException("DeferUpdate returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_stats(IntPtr thiz, int type);

		/// <summary>
		/// Returns a copy of the call statistics for a particular stream type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="type">the LinphoneStreamType </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.CallStats" /> object for the given stream or
		/// null if stream isn't available.   </returns>
		public Linphone.CallStats GetStats(Linphone.StreamType type)
		{
			IntPtr ptr = linphone_call_get_stats(nativePtr, (int)type);
			Linphone.CallStats returnVal = fromNativePtr<Linphone.CallStats>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_to_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Returns the value of the header name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">the name of the header to check.   </param>
		/// 
		/// 
		/// <returns>the value of the header if exists.   </returns>
		/// 
		/// deprecated : 27/10/2020. Use <see cref="Linphone.CallParams.GetCustomHeader()"
		/// /> on <see cref="Linphone.Call.GetRemoteParams()" /> instead. 
		public string GetToHeader(string headerName)
		{
			IntPtr stringPtr = linphone_call_get_to_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_has_transfer_pending(IntPtr thiz);

		/// <summary>
		/// Returns if this calls has received a transfer that has not been executed yet. 
		/// <para>
		/// Pending transfers are executed when this call is being paused or closed,
		/// locally or by remote endpoint. If the call is already paused while receiving
		/// the transfer request, the transfer immediately occurs. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if transfer is pending, false otherwise. </returns>
		public bool HasTransferPending()
		{
			bool returnVal = linphone_call_has_transfer_pending(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_media_in_progress(IntPtr thiz);

		/// <summary>
		/// Indicates whether an operation is in progress at the media side. 
		/// <para>
		/// It can be a bad idea to initiate signaling operations (adding video, pausing
		/// the call, removing video, changing video parameters) while the media is busy in
		/// establishing the connection (typically ICE connectivity checks). It can result
		/// in failures generating loss of time in future operations in the call.
		/// Applications are invited to check this function after each call state change to
		/// decide whether certain operations are permitted or not. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if media is busy in establishing the connection, false otherwise.
		/// </returns>
		public bool MediaInProgress()
		{
			bool returnVal = linphone_call_media_in_progress(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_ogl_render(IntPtr thiz);

		/// <summary>
		/// Calls generic OpenGL render for a given call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void OglRender()
		{
			linphone_call_ogl_render(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_pause(IntPtr thiz);

		/// <summary>
		/// Pauses the call. 
		/// <para>
		/// If a music file has been setup using <see cref="Linphone.Core.SetPlayFile()"
		/// />, this file will be played to the remote user. The only way to resume a
		/// paused call is to call <see cref="Linphone.Call.Resume()" />. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 on success, -1 on failure </returns>
		/// 
		/// <remarks>See : <see cref="Linphone.Call.Resume()" /> </remarks>
		public void Pause()
		{
			int exception_result = linphone_call_pause(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Pause returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_redirect(IntPtr thiz, string redirectUri);

		/// <summary>
		/// Redirect the specified call to the given redirect URI. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="redirectUri">The URI to redirect the call to   </param>
		/// 
		/// 
		/// <returns>0 if successful, -1 on error. </returns>
		/// 
		/// deprecated : 27/10/2020. Use <see cref="Linphone.Call.RedirectTo()" /> instead. 
		public void Redirect(string redirectUri)
		{
			int exception_result = linphone_call_redirect(nativePtr, redirectUri);
			if (exception_result != 0) throw new LinphoneException("Redirect returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_redirect_to(IntPtr thiz, IntPtr redirectAddress);

		/// <summary>
		/// Redirect the specified call to the given redirect Address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="redirectAddress">The <see cref="Linphone.Address" /> to redirect
		/// the call to   </param>
		/// 
		/// 
		/// <returns>0 if successful, -1 on error. </returns>
		public void RedirectTo(Linphone.Address redirectAddress)
		{
			int exception_result = linphone_call_redirect_to(nativePtr, redirectAddress != null ? redirectAddress.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("RedirectTo returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_request_notify_next_video_frame_decoded(IntPtr thiz);

		/// <summary>
		/// Request the callback passed to linphone_call_cbs_set_next_video_frame_decoded
		/// to be called the next time the video decoder properly decodes a video frame. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void RequestNotifyNextVideoFrameDecoded()
		{
			linphone_call_request_notify_next_video_frame_decoded(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_resume(IntPtr thiz);

		/// <summary>
		/// Resumes a call. 
		/// <para>
		/// The call needs to have been paused previously with <see
		/// cref="Linphone.Call.Pause()" />. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 on success, -1 on failure </returns>
		/// 
		/// <remarks>See : <see cref="Linphone.Call.Pause()" /> </remarks>
		public void Resume()
		{
			int exception_result = linphone_call_resume(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Resume returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_send_dtmf(IntPtr thiz, sbyte dtmf);

		/// <summary>
		/// Send the specified dtmf. 
		/// <para>
		/// The dtmf is automatically played to the user. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="dtmf">The dtmf name specified as a char, such as '0', '#' etc...
		/// </param>
		/// 
		/// 
		/// <returns>0 if successful, -1 on error. </returns>
		public void SendDtmf(sbyte dtmf)
		{
			int exception_result = linphone_call_send_dtmf(nativePtr, dtmf);
			if (exception_result != 0) throw new LinphoneException("SendDtmf returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_send_dtmfs(IntPtr thiz, string dtmfs);

		/// <summary>
		/// Send a list of dtmf. 
		/// <para>
		/// The dtmfs are automatically sent to remote, separated by some needed
		/// customizable delay. Sending is canceled if the call state changes to something
		/// not LinphoneCallStreamsRunning. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="dtmfs">A dtmf sequence such as '123#123123'   </param>
		/// 
		/// 
		/// <returns>-2 if there is already a DTMF sequence, -1 if call is not ready, 0
		/// otherwise. </returns>
		public void SendDtmfs(string dtmfs)
		{
			int exception_result = linphone_call_send_dtmfs(nativePtr, dtmfs);
			if (exception_result != 0) throw new LinphoneException("SendDtmfs returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_send_info_message(IntPtr thiz, IntPtr info);

		/// <summary>
		/// Sends an info message through an established call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="info">the <see cref="Linphone.InfoMessage" /> to send   </param>
		/// 
		public void SendInfoMessage(Linphone.InfoMessage info)
		{
			int exception_result = linphone_call_send_info_message(nativePtr, info != null ? info.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("SendInfoMessage returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_send_vfu_request(IntPtr thiz);

		/// <summary>
		/// Request remote side to send us a Video Fast Update. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void SendVfuRequest()
		{
			linphone_call_send_vfu_request(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_start_recording(IntPtr thiz);

		/// <summary>
		/// Starts call recording. 
		/// <para>
		/// Video record is only available if this function is called in state
		/// StreamRunning. The output file where audio is recorded must be previously
		/// specified with <see cref="Linphone.CallParams.SetRecordFile()" />. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void StartRecording()
		{
			linphone_call_start_recording(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_stop_recording(IntPtr thiz);

		/// <summary>
		/// Stops call recording. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void StopRecording()
		{
			linphone_call_stop_recording(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_take_preview_snapshot(IntPtr thiz, string filePath);

		/// <summary>
		/// Take a photo of currently captured video and write it into a jpeg file. 
		/// <para>
		/// Note that the snapshot is asynchronous, an application shall not assume that
		/// the file is created when the function returns. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="filePath">a path where to write the jpeg content.   </param>
		/// 
		/// 
		/// <returns>0 if successfull, -1 otherwise (typically if jpeg format is not
		/// supported). </returns>
		public void TakePreviewSnapshot(string filePath)
		{
			int exception_result = linphone_call_take_preview_snapshot(nativePtr, filePath);
			if (exception_result != 0) throw new LinphoneException("TakePreviewSnapshot returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_take_video_snapshot(IntPtr thiz, string filePath);

		/// <summary>
		/// Take a photo of currently received video and write it into a jpeg file. 
		/// <para>
		/// Note that the snapshot is asynchronous, an application shall not assume that
		/// the file is created when the function returns. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="filePath">a path where to write the jpeg content.   </param>
		/// 
		/// 
		/// <returns>0 if successfull, -1 otherwise (typically if jpeg format is not
		/// supported). </returns>
		public void TakeVideoSnapshot(string filePath)
		{
			int exception_result = linphone_call_take_video_snapshot(nativePtr, filePath);
			if (exception_result != 0) throw new LinphoneException("TakeVideoSnapshot returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_terminate(IntPtr thiz);

		/// <summary>
		/// Terminates a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 on success, -1 on failure </returns>
		public void Terminate()
		{
			int exception_result = linphone_call_terminate(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Terminate returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_terminate_with_error_info(IntPtr thiz, IntPtr ei);

		/// <summary>
		/// Terminates a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="ei"><see cref="Linphone.ErrorInfo" />   </param>
		/// 
		/// 
		/// <returns>0 on success, -1 on failure </returns>
		public void TerminateWithErrorInfo(Linphone.ErrorInfo ei)
		{
			int exception_result = linphone_call_terminate_with_error_info(nativePtr, ei != null ? ei.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("TerminateWithErrorInfo returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_transfer(IntPtr thiz, string referTo);

		/// <summary>
		/// Performs a simple call transfer to the specified destination. 
		/// <para>
		/// The remote endpoint is expected to issue a new call to the specified
		/// destination. The current call remains active and thus can be later paused or
		/// terminated. It is possible to follow the progress of the transfer provided that
		/// transferee sends notification about it. In this case, the
		/// transfer_state_changed callback of the LinphoneCoreVTable is invoked to notify
		/// of the state of the new call at the other party. The notified states are
		/// #LinphoneCallOutgoingInit , #LinphoneCallOutgoingProgress,
		/// #LinphoneCallOutgoingRinging and #LinphoneCallConnected. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="referTo">The destination the call is to be refered to.   </param>
		/// 
		/// 
		/// <returns>0 on success, -1 on failure </returns>
		/// 
		/// deprecated : 27/10/2020. Use <see cref="Linphone.Call.TransferTo()" /> instead. 
		public void Transfer(string referTo)
		{
			int exception_result = linphone_call_transfer(nativePtr, referTo);
			if (exception_result != 0) throw new LinphoneException("Transfer returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_transfer_to(IntPtr thiz, IntPtr referTo);

		/// <summary>
		/// Performs a simple call transfer to the specified destination. 
		/// <para>
		/// The remote endpoint is expected to issue a new call to the specified
		/// destination. The current call remains active and thus can be later paused or
		/// terminated. It is possible to follow the progress of the transfer provided that
		/// transferee sends notification about it. In this case, the
		/// transfer_state_changed callback of the LinphoneCoreVTable is invoked to notify
		/// of the state of the new call at the other party. The notified states are
		/// #LinphoneCallOutgoingInit , #LinphoneCallOutgoingProgress,
		/// #LinphoneCallOutgoingRinging and #LinphoneCallConnected. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="referTo">The <see cref="Linphone.Address" /> the call is to be
		/// refered to.   </param>
		/// 
		/// 
		/// <returns>0 on success, -1 on failure </returns>
		public void TransferTo(Linphone.Address referTo)
		{
			int exception_result = linphone_call_transfer_to(nativePtr, referTo != null ? referTo.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("TransferTo returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_transfer_to_another(IntPtr thiz, IntPtr dest);

		/// <summary>
		/// Transfers a call to destination of another running call. 
		/// <para>
		/// This is used for "attended transfer" scenarios. The transfered call is supposed
		/// to be in paused state, so that it is able to accept the transfer immediately.
		/// The destination call is a call previously established to introduce the
		/// transfered person. This method will send a transfer request to the transfered
		/// person. The phone of the transfered is then expected to automatically call to
		/// the destination of the transfer. The receiver of the transfer will then
		/// automatically close the call with us (the 'dest' call). It is possible to
		/// follow the progress of the transfer provided that transferee sends notification
		/// about it. In this case, the transfer_state_changed callback of the
		/// LinphoneCoreVTable is invoked to notify of the state of the new call at the
		/// other party. The notified states are #LinphoneCallOutgoingInit ,
		/// #LinphoneCallOutgoingProgress, #LinphoneCallOutgoingRinging and
		/// #LinphoneCallConnected. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="dest">A running call whose remote person will receive the transfer
		///   </param>
		/// 
		/// 
		/// <returns>0 on success, -1 on failure </returns>
		public void TransferToAnother(Linphone.Call dest)
		{
			int exception_result = linphone_call_transfer_to_another(nativePtr, dest != null ? dest.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("TransferToAnother returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_update(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Updates a running call according to supplied call parameters or parameters
		/// changed in the LinphoneCore. 
		/// <para>
		/// It triggers a SIP reINVITE in order to perform a new offer/answer of media
		/// capabilities. Changing the size of the transmitted video after calling
		/// linphone_core_set_preferred_video_size can be used by passing null as params
		/// argument. In case no changes are requested through the <see
		/// cref="Linphone.CallParams" /> argument, then this argument can be omitted and
		/// set to null. WARNING: Updating a call in the #LinphoneCallPaused state will
		/// still result in a paused call even if the media directions set in the params
		/// are sendrecv. To resume a paused call, you need to call <see
		/// cref="Linphone.Call.Resume()" />.
		/// 
		/// </para>
		/// </summary>
		/// <param name="parameters">The new call parameters to use (may be null).  
		/// </param>
		/// 
		/// 
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void Update(Linphone.CallParams parameters)
		{
			int exception_result = linphone_call_update(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("Update returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_zoom(IntPtr thiz, float zoomFactor, float cx, float cy);

		/// <summary>
		/// Perform a zoom of the video displayed during a call. 
		/// <para>
		/// The zoom ensures that all the screen is fullfilled with the video. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="zoomFactor">a floating point number describing the zoom factor. A
		/// value 1.0 corresponds to no zoom applied. </param>
		/// <param name="cx">a floating point number pointing the horizontal center of the
		/// zoom to be applied. This value should be between 0.0 and 1.0. </param>
		/// <param name="cy">a floating point number pointing the vertical center of the
		/// zoom to be applied. This value should be between 0.0 and 1.0. </param>
		/// 
		public void Zoom(float zoomFactor, float cx, float cy)
		{
			linphone_call_zoom(nativePtr, zoomFactor, cx, cy);
			
			
			
		}
	}
	/// <summary>
	/// Object used to keep track of all calls initiated, received or missed. 
	/// <para>
	/// It contains the call ID, date & time at which the call took place and it's
	/// duration (0 if it wasn't answered). You can also know if video was enabled or
	/// not or if it was a conference, as well as it's average quality.
	/// 
	/// If needed, you can also create a fake <see cref="Linphone.CallLog" /> using
	/// <see cref="Linphone.Core.CreateCallLog()" />, otherwise use <see
	/// cref="Linphone.Core.GetCallLogs()" /> or even <see
	/// cref="Linphone.Call.GetCallLog()" /> to get the log of an ongoing call. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class CallLog : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_call_id(IntPtr thiz);

		/// <summary>
		/// Get the call ID used by the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The call ID used by the call as a string.   </returns>
		public string CallId
		{
			get
			{
				IntPtr stringPtr = linphone_call_log_get_call_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.CallDir linphone_call_log_get_dir(IntPtr thiz);

		/// <summary>
		/// Get the direction of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneCallDir of the call. </returns>
		public Linphone.CallDir Dir
		{
			get
			{
				return linphone_call_log_get_dir(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_log_get_duration(IntPtr thiz);

		/// <summary>
		/// Get the duration of the call since connected. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The duration of the call in seconds. </returns>
		public int Duration
		{
			get
			{
				return linphone_call_log_get_duration(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_error_info(IntPtr thiz);

		/// <summary>
		/// When the call was failed, return an object describing the failure. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.ErrorInfo" /> about the error encountered by the
		/// call associated with this call log or null.   </returns>
		public Linphone.ErrorInfo ErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_call_log_get_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_from_address(IntPtr thiz);

		/// <summary>
		/// Get the origin address (ie from) of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The origin <see cref="Linphone.Address" /> (ie from) of the call.  
		/// </returns>
		public Linphone.Address FromAddress
		{
			get
			{
				IntPtr ptr = linphone_call_log_get_from_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_local_address(IntPtr thiz);

		/// <summary>
		/// Get the local address (that is from or to depending on call direction) 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The local <see cref="Linphone.Address" /> of the call   </returns>
		public Linphone.Address LocalAddress
		{
			get
			{
				IntPtr ptr = linphone_call_log_get_local_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_log_get_quality(IntPtr thiz);

		/// <summary>
		/// Get the overall quality indication of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The overall quality indication of the call. </returns>
		public float Quality
		{
			get
			{
				return linphone_call_log_get_quality(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_ref_key(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_log_set_ref_key(IntPtr thiz, string refkey);

		/// <summary>
		/// Get the persistent reference key associated to the call log. 
		/// <para>
		/// The reference key can be for example an id to an external database. It is
		/// stored in the config file, thus can survive to process exits/restarts.
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The reference key string that has been associated to the call log, or
		/// null if none has been associated.   </returns>
		public string RefKey
		{
			get
			{
				IntPtr stringPtr = linphone_call_log_get_ref_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_call_log_set_ref_key(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_remote_address(IntPtr thiz);

		/// <summary>
		/// Get the remote address (that is from or to depending on call direction). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The remote <see cref="Linphone.Address" /> of the call.   </returns>
		public Linphone.Address RemoteAddress
		{
			get
			{
				IntPtr ptr = linphone_call_log_get_remote_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_call_log_get_start_date(IntPtr thiz);

		/// <summary>
		/// Get the start date of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The date of the beginning of the call. </returns>
		public long StartDate
		{
			get
			{
				return linphone_call_log_get_start_date(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.CallStatus linphone_call_log_get_status(IntPtr thiz);

		/// <summary>
		/// Get the status of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneCallStatus of the call. </returns>
		public Linphone.CallStatus Status
		{
			get
			{
				return linphone_call_log_get_status(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_to_address(IntPtr thiz);

		/// <summary>
		/// Get the destination address (ie to) of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The destination <see cref="Linphone.Address" /> (ie to) of the call.  
		/// </returns>
		public Linphone.Address ToAddress
		{
			get
			{
				IntPtr ptr = linphone_call_log_get_to_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_log_video_enabled(IntPtr thiz);

		/// <summary>
		/// Tell whether video was enabled at the end of the call or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether video was enabled at the end of the
		/// call. </returns>
		public bool VideoEnabled
		{
			get
			{
				return linphone_call_log_video_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_to_str(IntPtr thiz);

		/// <summary>
		/// Get a human readable string describing the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Note : : the returned string must be freed by the application (use
		/// ms_free()). </remarks>
		/// 
		/// <returns>A human readable string describing the call.   </returns>
		public string ToStr()
		{
			IntPtr stringPtr = linphone_call_log_to_str(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_log_was_conference(IntPtr thiz);

		/// <summary>
		/// Tells whether that call was a call to a conference server. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the call was a call to a conference server, false otherwise.
		/// </returns>
		public bool WasConference()
		{
			bool returnVal = linphone_call_log_was_conference(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
	}
	/// <summary>
	/// An object containing various parameters of a <see cref="Linphone.Call" />. 
	/// <para>
	/// You can specify your params while answering an incoming call using <see
	/// cref="Linphone.Call.AcceptWithParams()" /> or while initiating an outgoing call
	/// with <see cref="Linphone.Core.InviteAddressWithParams()" />.
	/// 
	/// This object can be created using <see cref="Linphone.Core.CreateCallParams()"
	/// />, using null for the call pointer if you plan to use it for an outgoing call.
	/// 
	/// For each call, three <see cref="Linphone.CallParams" /> are available: yours,
	/// your correspondent's and the one that describe the current state of the call
	/// that is the result of the negociation between the previous two. For example,
	/// you might enable a certain feature in your call param but this feature can be
	/// denied in the remote's configuration, hence the difference.
	/// 
	/// </para>
	/// </summary>
	/// <remarks>See : <see cref="Linphone.Call.GetCurrentParams()" />, <see
	/// cref="Linphone.Call.GetRemoteParams()" /> and <see
	/// cref="Linphone.Call.GetParams()" />. </remarks>
	[StructLayout(LayoutKind.Sequential)]
	public class CallParams : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_audio_bandwidth_limit(IntPtr thiz, int bandwidth);

		/// <summary>
		/// Refine bandwidth settings for this call by setting a bandwidth limit for audio
		/// streams. 
		/// <para>
		/// As a consequence, codecs whose bitrates are not compatible with this limit
		/// won't be used. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="bandwidth">The audio bandwidth limit to set in kbit/s. </param>
		/// 
		public int AudioBandwidthLimit
		{
			set
			{
				linphone_call_params_set_audio_bandwidth_limit(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.MediaDirection linphone_call_params_get_audio_direction(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_audio_direction(IntPtr thiz, int direction);

		/// <summary>
		/// Get the audio stream direction. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The audio stream LinphoneMediaDirection associated with the call
		/// params. </returns>
		public Linphone.MediaDirection AudioDirection
		{
			get
			{
				return linphone_call_params_get_audio_direction(nativePtr);
			}
			set
			{
				linphone_call_params_set_audio_direction(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_audio_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_audio(IntPtr thiz, char enabled);

		/// <summary>
		/// Tell whether audio is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether audio is enabled or not. </returns>
		public bool AudioEnabled
		{
			get
			{
				return linphone_call_params_audio_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_audio(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_audio_multicast_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_audio_multicast(IntPtr thiz, char yesno);

		/// <summary>
		/// Use to get multicast state of audio stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if subsequent calls will propose multicast ip set by
		/// linphone_core_set_audio_multicast_addr </returns>
		public bool AudioMulticastEnabled
		{
			get
			{
				return linphone_call_params_audio_multicast_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_audio_multicast(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_avpf(IntPtr thiz, char enable);

		/// <summary>
		/// Set the video stream direction. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="enable">wether or not AVPF should be enabled for this call </param>
		/// 
		public bool AvpfEnabled
		{
			set
			{
				linphone_call_params_enable_avpf(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_custom_contents(IntPtr thiz);

		/// <summary>
		/// Gets a list of <see cref="Linphone.Content" /> set if exists. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Content" /> objects. LinphoneContent  A
		/// list of <see cref="Linphone.Content" /> set if exists, null otherwise.  
		/// </returns>
		public IEnumerable<Linphone.Content> CustomContents
		{
			get
			{
				return MarshalBctbxList<Linphone.Content>(linphone_call_params_get_custom_contents(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_early_media_sending_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_early_media_sending(IntPtr thiz, char enabled);

		/// <summary>
		/// Indicate whether sending of early media was enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether sending of early media was enabled.
		/// </returns>
		public bool EarlyMediaSendingEnabled
		{
			get
			{
				return linphone_call_params_early_media_sending_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_early_media_sending(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_get_local_conference_mode(IntPtr thiz);

		/// <summary>
		/// Tell whether the call is part of the locally managed conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : If a conference server is used to manage conferences, that
		/// function does not return true even if the conference is running. If you want to
		/// test whether the conference is running, you should test whether <see
		/// cref="Linphone.Core.GetConference()" /> return a non-null pointer. </remarks> 
		/// 
		/// <returns>A boolean value telling whether the call is part of the locally
		/// managed conference. </returns>
		public bool LocalConferenceMode
		{
			get
			{
				return linphone_call_params_get_local_conference_mode(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_low_bandwidth_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_low_bandwidth(IntPtr thiz, char enabled);

		/// <summary>
		/// Tell whether the call has been configured in low bandwidth mode or not. 
		/// <para>
		/// This mode can be automatically discovered thanks to a stun server when
		/// activate_edge_workarounds=1 in section [net] of configuration file. An
		/// application that would have reliable way to know network capacity may not use
		/// activate_edge_workarounds=1 but instead manually configure low bandwidth mode
		/// with <see cref="Linphone.CallParams.EnableLowBandwidth()" />. When enabled,
		/// this param may transform a call request with video in audio only mode. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether the low bandwidth mode has been
		/// configured/detected. </returns>
		public bool LowBandwidthEnabled
		{
			get
			{
				return linphone_call_params_low_bandwidth_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_low_bandwidth(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.MediaEncryption linphone_call_params_get_media_encryption(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_media_encryption(IntPtr thiz, int encryption);

		/// <summary>
		/// Get the kind of media encryption selected for the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The kind of LinphoneMediaEncryption selected for the call. </returns>
		public Linphone.MediaEncryption MediaEncryption
		{
			get
			{
				return linphone_call_params_get_media_encryption(nativePtr);
			}
			set
			{
				linphone_call_params_set_media_encryption(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_call_params_get_privacy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_privacy(IntPtr thiz, uint privacy);

		/// <summary>
		/// Get requested level of privacy for the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphonePrivacyMask used for the call. </returns>
		public uint Privacy
		{
			get
			{
				return linphone_call_params_get_privacy(nativePtr);
			}
			set
			{
				linphone_call_params_set_privacy(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_proxy_config(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_proxy_config(IntPtr thiz, IntPtr proxyConfig);

		/// <summary>
		/// Get the <see cref="Linphone.ProxyConfig" /> that is used for the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The selected <see cref="Linphone.ProxyConfig" /> for the call, or null
		/// if none has been selected.   </returns>
		public Linphone.ProxyConfig ProxyConfig
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_proxy_config(nativePtr);
				Linphone.ProxyConfig obj = fromNativePtr<Linphone.ProxyConfig>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_params_set_proxy_config(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_realtime_text_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_params_enable_realtime_text(IntPtr thiz, char yesno);

		/// <summary>
		/// Use to get real time text following rfc4103. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>returns true if call rtt is activated. </returns>
		public bool RealtimeTextEnabled
		{
			get
			{
				return linphone_call_params_realtime_text_enabled(nativePtr) != 0;
			}
			set
			{
				int exception_result = linphone_call_params_enable_realtime_text(nativePtr, value ? (char)1 : (char)0);
				if (exception_result != 0) throw new LinphoneException("RealtimeTextEnabled setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_call_params_get_realtime_text_keepalive_interval(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_realtime_text_keepalive_interval(IntPtr thiz, uint interval);

		/// <summary>
		/// Use to get keep alive interval of real time text following rfc4103. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>returns keep alive interval of real time text. </returns>
		public uint RealtimeTextKeepaliveInterval
		{
			get
			{
				return linphone_call_params_get_realtime_text_keepalive_interval(nativePtr);
			}
			set
			{
				linphone_call_params_set_realtime_text_keepalive_interval(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_params_get_received_framerate(IntPtr thiz);

		/// <summary>
		/// Get the framerate of the video that is received. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The actual received framerate in frames per seconds, 0 if not
		/// available. </returns>
		public float ReceivedFramerate
		{
			get
			{
				return linphone_call_params_get_received_framerate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_received_video_definition(IntPtr thiz);

		/// <summary>
		/// Get the definition of the received video. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The received <see cref="Linphone.VideoDefinition" /> or null.  
		/// </returns>
		public Linphone.VideoDefinition ReceivedVideoDefinition
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_received_video_definition(nativePtr);
				Linphone.VideoDefinition obj = fromNativePtr<Linphone.VideoDefinition>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_record_file(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_record_file(IntPtr thiz, string path);

		/// <summary>
		/// Get the path for the audio recording of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the audio recording of the call or null.   </returns>
		public string RecordFile
		{
			get
			{
				IntPtr stringPtr = linphone_call_params_get_record_file(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_call_params_set_record_file(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_rtp_bundle_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_rtp_bundle(IntPtr thiz, char val);

		/// <summary>
		/// Indicates whether RTP bundle mode (also known as Media Multiplexing) is
		/// enabled. 
		/// <para>
		/// See https://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-54 for
		/// more information. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a boolean indicating the enablement of rtp bundle mode. </returns>
		public bool RtpBundleEnabled
		{
			get
			{
				return linphone_call_params_rtp_bundle_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_rtp_bundle(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_rtp_profile(IntPtr thiz);

		/// <summary>
		/// Get the RTP profile being used. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The RTP profile.   </returns>
		public string RtpProfile
		{
			get
			{
				IntPtr stringPtr = linphone_call_params_get_rtp_profile(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_params_get_sent_framerate(IntPtr thiz);

		/// <summary>
		/// Get the framerate of the video that is sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The actual sent framerate in frames per seconds, 0 if not available.
		/// </returns>
		public float SentFramerate
		{
			get
			{
				return linphone_call_params_get_sent_framerate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_sent_video_definition(IntPtr thiz);

		/// <summary>
		/// Get the definition of the sent video. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The sent <see cref="Linphone.VideoDefinition" /> or null.   </returns>
		public Linphone.VideoDefinition SentVideoDefinition
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_sent_video_definition(nativePtr);
				Linphone.VideoDefinition obj = fromNativePtr<Linphone.VideoDefinition>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_session_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_session_name(IntPtr thiz, string name);

		/// <summary>
		/// Get the session name of the media session (ie in SDP). 
		/// <para>
		/// Subject from the SIP message can be retrieved using <see
		/// cref="Linphone.CallParams.GetCustomHeader()" /> and is different. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The session name of the media session or null.   </returns>
		public string SessionName
		{
			get
			{
				IntPtr stringPtr = linphone_call_params_get_session_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_call_params_set_session_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_used_audio_payload_type(IntPtr thiz);

		/// <summary>
		/// Get the audio payload type that has been selected by a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The selected <see cref="Linphone.PayloadType" />. null is returned if
		/// no audio payload type has been selected by the call.   </returns>
		public Linphone.PayloadType UsedAudioPayloadType
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_used_audio_payload_type(nativePtr);
				Linphone.PayloadType obj = fromNativePtr<Linphone.PayloadType>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_used_text_payload_type(IntPtr thiz);

		/// <summary>
		/// Get the text payload type that has been selected by a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The selected <see cref="Linphone.PayloadType" />. null is returned if
		/// no text payload type has been selected by the call.   </returns>
		public Linphone.PayloadType UsedTextPayloadType
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_used_text_payload_type(nativePtr);
				Linphone.PayloadType obj = fromNativePtr<Linphone.PayloadType>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_used_video_payload_type(IntPtr thiz);

		/// <summary>
		/// Get the video payload type that has been selected by a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The selected <see cref="Linphone.PayloadType" />. null is returned if
		/// no video payload type has been selected by the call.   </returns>
		public Linphone.PayloadType UsedVideoPayloadType
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_used_video_payload_type(nativePtr);
				Linphone.PayloadType obj = fromNativePtr<Linphone.PayloadType>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.MediaDirection linphone_call_params_get_video_direction(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_video_direction(IntPtr thiz, int direction);

		/// <summary>
		/// Get the video stream direction. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The video stream LinphoneMediaDirection associated with the call
		/// params. </returns>
		public Linphone.MediaDirection VideoDirection
		{
			get
			{
				return linphone_call_params_get_video_direction(nativePtr);
			}
			set
			{
				linphone_call_params_set_video_direction(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_video_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_video(IntPtr thiz, char enabled);

		/// <summary>
		/// Tell whether video is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether video is enabled or not. </returns>
		public bool VideoEnabled
		{
			get
			{
				return linphone_call_params_video_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_video(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_video_multicast_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_video_multicast(IntPtr thiz, char yesno);

		/// <summary>
		/// Use to get multicast state of video stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if subsequent calls will propose multicast ip set by
		/// linphone_core_set_video_multicast_addr </returns>
		public bool VideoMulticastEnabled
		{
			get
			{
				return linphone_call_params_video_multicast_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_video_multicast(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_add_custom_content(IntPtr thiz, IntPtr content);

		/// <summary>
		/// Adds a <see cref="Linphone.Content" /> to be added to the INVITE SDP. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">The <see cref="Linphone.Content" /> to be added.  
		/// </param>
		/// 
		public void AddCustomContent(Linphone.Content content)
		{
			linphone_call_params_add_custom_content(nativePtr, content != null ? content.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_add_custom_header(IntPtr thiz, string headerName, string headerValue);

		/// <summary>
		/// Add a custom SIP header in the INVITE for a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">The name of the header to add.   </param>
		/// <param name="headerValue">The content of the header to add.   </param>
		/// 
		public void AddCustomHeader(string headerName, string headerValue)
		{
			linphone_call_params_add_custom_header(nativePtr, headerName, headerValue);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_add_custom_sdp_attribute(IntPtr thiz, string attributeName, string attributeValue);

		/// <summary>
		/// Add a custom attribute related to all the streams in the SDP exchanged within
		/// SIP messages during a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="attributeName">The name of the attribute to add.   </param>
		/// <param name="attributeValue">The content value of the attribute to add.  
		/// </param>
		/// 
		public void AddCustomSdpAttribute(string attributeName, string attributeValue)
		{
			linphone_call_params_add_custom_sdp_attribute(nativePtr, attributeName, attributeValue);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_add_custom_sdp_media_attribute(IntPtr thiz, int type, string attributeName, string attributeValue);

		/// <summary>
		/// Add a custom attribute related to a specific stream in the SDP exchanged within
		/// SIP messages during a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="type">The type of the stream to add a custom SDP attribute to.
		/// </param>
		/// <param name="attributeName">The name of the attribute to add.   </param>
		/// <param name="attributeValue">The content value of the attribute to add.  
		/// </param>
		/// 
		public void AddCustomSdpMediaAttribute(Linphone.StreamType type, string attributeName, string attributeValue)
		{
			linphone_call_params_add_custom_sdp_media_attribute(nativePtr, (int)type, attributeName, attributeValue);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_clear_custom_sdp_attributes(IntPtr thiz);

		/// <summary>
		/// Clear the custom SDP attributes related to all the streams in the SDP exchanged
		/// within SIP messages during a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void ClearCustomSdpAttributes()
		{
			linphone_call_params_clear_custom_sdp_attributes(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_clear_custom_sdp_media_attributes(IntPtr thiz, int type);

		/// <summary>
		/// Clear the custom SDP attributes related to a specific stream in the SDP
		/// exchanged within SIP messages during a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="type">The type of the stream to clear the custom SDP attributes
		/// from. </param>
		/// 
		public void ClearCustomSdpMediaAttributes(Linphone.StreamType type)
		{
			linphone_call_params_clear_custom_sdp_media_attributes(nativePtr, (int)type);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_copy(IntPtr thiz);

		/// <summary>
		/// Copy an existing <see cref="Linphone.CallParams" /> object to a new <see
		/// cref="Linphone.CallParams" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A copy of the <see cref="Linphone.CallParams" /> object.   </returns>
		public Linphone.CallParams Copy()
		{
			IntPtr ptr = linphone_call_params_copy(nativePtr);
			Linphone.CallParams returnVal = fromNativePtr<Linphone.CallParams>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_custom_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Get a custom SIP header. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">The name of the header to get.   </param>
		/// 
		/// 
		/// <returns>The content of the header or null if not found.   </returns>
		public string GetCustomHeader(string headerName)
		{
			IntPtr stringPtr = linphone_call_params_get_custom_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_custom_sdp_attribute(IntPtr thiz, string attributeName);

		/// <summary>
		/// Get a custom SDP attribute that is related to all the streams. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="attributeName">The name of the attribute to get.   </param>
		/// 
		/// 
		/// <returns>The content value of the attribute or null if not found.   </returns>
		public string GetCustomSdpAttribute(string attributeName)
		{
			IntPtr stringPtr = linphone_call_params_get_custom_sdp_attribute(nativePtr, attributeName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_custom_sdp_media_attribute(IntPtr thiz, int type, string attributeName);

		/// <summary>
		/// Get a custom SDP attribute that is related to a specific stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="type">The type of the stream to add a custom SDP attribute to.
		/// </param>
		/// <param name="attributeName">The name of the attribute to get.   </param>
		/// 
		/// 
		/// <returns>The content value of the attribute or null if not found.   </returns>
		public string GetCustomSdpMediaAttribute(Linphone.StreamType type, string attributeName)
		{
			IntPtr stringPtr = linphone_call_params_get_custom_sdp_media_attribute(nativePtr, (int)type, attributeName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
	}
	/// <summary>
	/// This object carry various statistic informations regarding the quality of an
	/// audio or video stream for a given <see cref="Linphone.Call" />. 
	/// <para>
	/// To receive these informations periodically and as soon as they are computed,
	/// implement the call_stats_updated() callback inside a LinphoneCoreCbs.
	/// 
	/// At any time, the application can access latest computed statistics using <see
	/// cref="Linphone.Call.GetAudioStats()" /> and <see
	/// cref="Linphone.Call.GetVideoStats()" />. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class CallStats : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_download_bandwidth(IntPtr thiz);

		/// <summary>
		/// Get the bandwidth measurement of the received stream, expressed in kbit/s,
		/// including IP/UDP/RTP headers. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The bandwidth measurement of the received stream in kbit/s. </returns>
		public float DownloadBandwidth
		{
			get
			{
				return linphone_call_stats_get_download_bandwidth(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_estimated_download_bandwidth(IntPtr thiz);

		/// <summary>
		/// Get the estimated bandwidth measurement of the received stream, expressed in
		/// kbit/s, including IP/UDP/RTP headers. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The estimated bandwidth measurement of the received stream in kbit/s.
		/// </returns>
		public float EstimatedDownloadBandwidth
		{
			get
			{
				return linphone_call_stats_get_estimated_download_bandwidth(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.IceState linphone_call_stats_get_ice_state(IntPtr thiz);

		/// <summary>
		/// Get the state of ICE processing. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneIceState of ICE processing </returns>
		public Linphone.IceState IceState
		{
			get
			{
				return linphone_call_stats_get_ice_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AddressFamily linphone_call_stats_get_ip_family_of_remote(IntPtr thiz);

		/// <summary>
		/// Get the IP address family of the remote peer. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The IP address family LinphoneAddressFamily of the remote peer.
		/// </returns>
		public Linphone.AddressFamily IpFamilyOfRemote
		{
			get
			{
				return linphone_call_stats_get_ip_family_of_remote(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_jitter_buffer_size_ms(IntPtr thiz);

		/// <summary>
		/// Get the jitter buffer size in ms. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The jitter buffer size in ms. </returns>
		public float JitterBufferSizeMs
		{
			get
			{
				return linphone_call_stats_get_jitter_buffer_size_ms(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_call_stats_get_late_packets_cumulative_number(IntPtr thiz);

		/// <summary>
		/// Gets the cumulative number of late packets. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The cumulative number of late packets </returns>
		public uint LatePacketsCumulativeNumber
		{
			get
			{
				return linphone_call_stats_get_late_packets_cumulative_number(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_local_late_rate(IntPtr thiz);

		/// <summary>
		/// Gets the local late rate since last report. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The local late rate </returns>
		public float LocalLateRate
		{
			get
			{
				return linphone_call_stats_get_local_late_rate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_local_loss_rate(IntPtr thiz);

		/// <summary>
		/// Get the local loss rate since last report. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The local loss rate </returns>
		public float LocalLossRate
		{
			get
			{
				return linphone_call_stats_get_local_loss_rate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_receiver_interarrival_jitter(IntPtr thiz);

		/// <summary>
		/// Gets the remote reported interarrival jitter. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The interarrival jitter at last received receiver report </returns>
		public float ReceiverInterarrivalJitter
		{
			get
			{
				return linphone_call_stats_get_receiver_interarrival_jitter(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_receiver_loss_rate(IntPtr thiz);

		/// <summary>
		/// Gets the remote reported loss rate since last report. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The receiver loss rate </returns>
		public float ReceiverLossRate
		{
			get
			{
				return linphone_call_stats_get_receiver_loss_rate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_round_trip_delay(IntPtr thiz);

		/// <summary>
		/// Get the round trip delay in s. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The round trip delay in s. </returns>
		public float RoundTripDelay
		{
			get
			{
				return linphone_call_stats_get_round_trip_delay(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_rtcp_download_bandwidth(IntPtr thiz);

		/// <summary>
		/// Get the bandwidth measurement of the received RTCP, expressed in kbit/s,
		/// including IP/UDP/RTP headers. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The bandwidth measurement of the received RTCP in kbit/s. </returns>
		public float RtcpDownloadBandwidth
		{
			get
			{
				return linphone_call_stats_get_rtcp_download_bandwidth(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_rtcp_upload_bandwidth(IntPtr thiz);

		/// <summary>
		/// Get the bandwidth measurement of the sent RTCP, expressed in kbit/s, including
		/// IP/UDP/RTP headers. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The bandwidth measurement of the sent RTCP in kbit/s. </returns>
		public float RtcpUploadBandwidth
		{
			get
			{
				return linphone_call_stats_get_rtcp_upload_bandwidth(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_sender_interarrival_jitter(IntPtr thiz);

		/// <summary>
		/// Gets the local interarrival jitter. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The interarrival jitter at last emitted sender report </returns>
		public float SenderInterarrivalJitter
		{
			get
			{
				return linphone_call_stats_get_sender_interarrival_jitter(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_sender_loss_rate(IntPtr thiz);

		/// <summary>
		/// Get the local loss rate since last report. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The sender loss rate </returns>
		public float SenderLossRate
		{
			get
			{
				return linphone_call_stats_get_sender_loss_rate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.StreamType linphone_call_stats_get_type(IntPtr thiz);

		/// <summary>
		/// Get the type of the stream the stats refer to. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneStreamType the stats refer to </returns>
		public Linphone.StreamType Type
		{
			get
			{
				return linphone_call_stats_get_type(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_upload_bandwidth(IntPtr thiz);

		/// <summary>
		/// Get the bandwidth measurement of the sent stream, expressed in kbit/s,
		/// including IP/UDP/RTP headers. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The bandwidth measurement of the sent stream in kbit/s. </returns>
		public float UploadBandwidth
		{
			get
			{
				return linphone_call_stats_get_upload_bandwidth(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.UpnpState linphone_call_stats_get_upnp_state(IntPtr thiz);

		/// <summary>
		/// Get the state of uPnP processing. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneUpnpState of uPnP processing. </returns>
		public Linphone.UpnpState UpnpState
		{
			get
			{
				return linphone_call_stats_get_upnp_state(nativePtr);
			}
		}
	}
	/// <summary>
	/// An chat message is the object that is sent or received through a <see
	/// cref="Linphone.ChatRoom" />. 
	/// <para>
	/// To create a <see cref="Linphone.ChatMessage" />, use <see
	/// cref="Linphone.ChatRoom.CreateEmptyMessage()" />, then either add text using
	/// <see cref="Linphone.ChatMessage.AddUtf8TextContent()" /> or a <see
	/// cref="Linphone.Content" /> with file informations using <see
	/// cref="Linphone.ChatMessage.AddFileContent()" />. A valid <see
	/// cref="Linphone.Content" /> for file transfer must contain a type and subtype,
	/// the name of the file and it's size. Finally call <see
	/// cref="Linphone.ChatMessage.Send()" /> to send it.
	/// 
	/// To send files through a <see cref="Linphone.ChatMessage" />, you need to have
	/// configured a file transfer server URL with <see
	/// cref="Linphone.Core.SetFileTransferServer()" />. On the receiving side, either
	/// use <see cref="Linphone.ChatMessage.DownloadContent()" /> to download received
	/// files or enable auto-download in the <see cref="Linphone.Core" /> using <see
	/// cref="Linphone.Core.SetMaxSizeForAutoDownloadIncomingFiles()" />, -1 disabling
	/// the feature and 0 always downloading files no matter it's size.
	/// 
	/// Keep in mind a <see cref="Linphone.ChatMessage" /> created by a
	/// LinphoneChatRoomBackendBasic <see cref="Linphone.ChatRoom" /> can only contain
	/// one <see cref="Linphone.Content" />, either text or file. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ChatMessage : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_chat_message_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_remove_callbacks(IntPtr thiz, IntPtr cbs);

		~ChatMessage() 
		{
			if (listener != null)
			{
				linphone_chat_message_remove_callbacks(nativePtr, listener.nativePtr);
			}
		}

		private ChatMessageListener listener;

		public ChatMessageListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_chat_message_cbs(linphone_factory_get());
					listener = fromNativePtr<ChatMessageListener>(nativeListener, false);
					linphone_chat_message_add_callbacks(nativePtr, nativeListener);
					listener.register();
				}
				return listener;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_appdata(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_set_appdata(IntPtr thiz, string data);

		/// <summary>
		/// Linphone message has an app-specific field that can store a text. 
		/// <para>
		/// The application might want to use it for keeping data over restarts, like
		/// thumbnail image path. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the application-specific data or null if none has been stored.  
		/// </returns>
		public string Appdata
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_appdata(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_chat_message_set_appdata(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_call_id(IntPtr thiz);

		/// <summary>
		/// Gets the callId accociated with the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the call Id   </returns>
		public string CallId
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_call_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_chat_room(IntPtr thiz);

		/// <summary>
		/// Returns the chatroom this message belongs to. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.ChatRoom" /> in which this message has been
		/// sent or received.   </returns>
		public Linphone.ChatRoom ChatRoom
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_chat_room(nativePtr);
				Linphone.ChatRoom obj = fromNativePtr<Linphone.ChatRoom>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_content_type(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_set_content_type(IntPtr thiz, string contentType);

		/// <summary>
		/// Get the content type of a chat message. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The content type of the chat message   </returns>
		public string ContentType
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_content_type(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_chat_message_set_content_type(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_contents(IntPtr thiz);

		/// <summary>
		/// Returns the list of contents in the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Content" /> objects. LinphoneContent 
		/// the list of <see cref="Linphone.Content" />.   </returns>
		public IEnumerable<Linphone.Content> Contents
		{
			get
			{
				return MarshalBctbxList<Linphone.Content>(linphone_chat_message_get_contents(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_core(IntPtr thiz);

		/// <summary>
		/// Returns back pointer to <see cref="Linphone.Core" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Core" /> object associated with this message. 
		///  </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_current_callbacks(IntPtr thiz);

		/// <summary>
		/// Gets the current LinphoneChatMessageCbs. 
		/// <para>
		/// This is meant only to be called from a callback to be able to get the user_data
		/// associated with the LinphoneChatMessageCbs that is calling the callback. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneChatMessageCbs that has called the last callback.  
		/// </returns>
		public Linphone.ChatMessageListener CurrentCallbacks
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_current_callbacks(nativePtr);
				Linphone.ChatMessageListener obj = fromNativePtr<Linphone.ChatMessageListener>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_chat_message_get_ephemeral_expire_time(IntPtr thiz);

		/// <summary>
		/// Returns the real time at which an ephemeral message expires and will be
		/// deleted. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.ChatMessage.IsEphemeral()" /> </remarks>
		/// 
		/// <returns>the time at which an ephemeral message expires. 0 means the message
		/// has not been read. </returns>
		public long EphemeralExpireTime
		{
			get
			{
				return linphone_chat_message_get_ephemeral_expire_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_message_get_ephemeral_lifetime(IntPtr thiz);

		/// <summary>
		/// Returns lifetime of an ephemeral message. 
		/// <para>
		/// The lifetime is the duration after which the ephemeral message will disappear
		/// once viewed. </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.ChatMessage.IsEphemeral()" /> </remarks>
		/// 
		/// <returns>the lifetime of an ephemeral message, by default 86400s. </returns>
		public int EphemeralLifetime
		{
			get
			{
				return linphone_chat_message_get_ephemeral_lifetime(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_error_info(IntPtr thiz);

		/// <summary>
		/// Get full details about delivery error of a chat message. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.ErrorInfo" /> describing the details.  
		/// </returns>
		public Linphone.ErrorInfo ErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_external_body_url(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_set_external_body_url(IntPtr thiz, string externalBodyUrl);

		/// <summary>
		/// Linphone message can carry external body as defined by rfc2017. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>external body url or null if not present.   </returns>
		public string ExternalBodyUrl
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_external_body_url(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_chat_message_set_external_body_url(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_file_transfer_information(IntPtr thiz);

		/// <summary>
		/// Get the file_transfer_information (used by call backs to recover informations
		/// during a rcs file transfer) 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a pointer to the <see cref="Linphone.Content" /> structure or null if
		/// not present.   </returns>
		public Linphone.Content FileTransferInformation
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_file_transfer_information(nativePtr);
				Linphone.Content obj = fromNativePtr<Linphone.Content>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_forward_info(IntPtr thiz);

		/// <summary>
		/// Gets the forward info if available as a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the original sender of the message if it has been forwarded, null
		/// otherwise.   </returns>
		public string ForwardInfo
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_forward_info(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_from_address(IntPtr thiz);

		/// <summary>
		/// Get origin of the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Address" /> of the sender.   </returns>
		public Linphone.Address FromAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_from_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_ephemeral(IntPtr thiz);

		/// <summary>
		/// Returns wether the chat message is an ephemeral message or not. 
		/// <para>
		/// An ephemeral message will automatically disappear from the recipient's screen
		/// after the message has been viewed. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if it is an ephemeral message, false otherwise </returns>
		public bool IsEphemeral
		{
			get
			{
				return linphone_chat_message_is_ephemeral(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_file_transfer(IntPtr thiz);

		/// <summary>
		/// Return whether or not a chat message is a file transfer. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Whether or not the message is a file transfer </returns>
		/// 
		/// deprecated : 06/07/2020 check if <see cref="Linphone.ChatMessage.GetContents()"
		/// /> contains a <see cref="Linphone.Content" /> for which <see
		/// cref="Linphone.Content.IsFileTransfer()" /> returns true. 
		public bool IsFileTransfer
		{
			get
			{
				return linphone_chat_message_is_file_transfer(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_file_transfer_in_progress(IntPtr thiz);

		/// <summary>
		/// Gets whether or not a file is currently being downloaded or uploaded. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if download or upload is in progress, false otherwise </returns>
		public bool IsFileTransferInProgress
		{
			get
			{
				return linphone_chat_message_is_file_transfer_in_progress(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_forward(IntPtr thiz);

		/// <summary>
		/// Returns wether the chat message is a forward message or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if it is a forward message, false otherwise </returns>
		public bool IsForward
		{
			get
			{
				return linphone_chat_message_is_forward(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_outgoing(IntPtr thiz);

		/// <summary>
		/// Returns wehther the message has been sent or received. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if message has been sent, false if it has been received.
		/// </returns>
		public bool IsOutgoing
		{
			get
			{
				return linphone_chat_message_is_outgoing(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_read(IntPtr thiz);

		/// <summary>
		/// Returns wether the message has been read or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if message has been marked as read, false otherwise. </returns>
		public bool IsRead
		{
			get
			{
				return linphone_chat_message_is_read(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_secured(IntPtr thiz);

		/// <summary>
		/// Get if the message was encrypted when transfered. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the message was encrypted when transfered, false otherwise.
		/// </returns>
		public bool IsSecured
		{
			get
			{
				return linphone_chat_message_is_secured(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_text(IntPtr thiz);

		/// <summary>
		/// Return whether or not a chat message is a text. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Whether or not the message is a text </returns>
		/// 
		/// deprecated : 06/07/2020 check if <see cref="Linphone.ChatMessage.GetContents()"
		/// /> contains a <see cref="Linphone.Content" /> with a PlainText content type. 
		public bool IsText
		{
			get
			{
				return linphone_chat_message_is_text(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_local_address(IntPtr thiz);

		/// <summary>
		/// Returns the local address the message was sent or received with. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Address" /> of the local address used to
		/// send/receive this message.   </returns>
		public Linphone.Address LocalAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_local_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_message_id(IntPtr thiz);

		/// <summary>
		/// Get the message identifier. 
		/// <para>
		/// It is used to identify a message so that it can be notified as delivered and/or
		/// displayed. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The message identifier.   </returns>
		public string MessageId
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_message_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatMessageState linphone_chat_message_get_state(IntPtr thiz);

		/// <summary>
		/// Get the state of the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the current LinphoneChatMessageState of the message. </returns>
		public Linphone.ChatMessageState State
		{
			get
			{
				return linphone_chat_message_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_text_content(IntPtr thiz);

		/// <summary>
		/// Gets the text content if available as a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Content" /> buffer if available in System
		/// Locale, null otherwise.   </returns>
		/// 
		/// deprecated : 01/07/2020. Use <see cref="Linphone.ChatMessage.GetUtf8Text()" />
		/// instead. 
		public string TextContent
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_text_content(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_chat_message_get_time(IntPtr thiz);

		/// <summary>
		/// Get the time the message was sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the timestamp of when the message was sent. </returns>
		public long Time
		{
			get
			{
				return linphone_chat_message_get_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_to_address(IntPtr thiz);

		/// <summary>
		/// Get destination of the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Address" /> of the recipient.   </returns>
		public Linphone.Address ToAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_to_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_get_to_be_stored(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_set_to_be_stored(IntPtr thiz, char toBeStored);

		/// <summary>
		/// Get if a chat message is to be stored. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Whether or not the message is to be stored </returns>
		public bool ToBeStored
		{
			get
			{
				return linphone_chat_message_get_to_be_stored(nativePtr) != 0;
			}
			set
			{
				linphone_chat_message_set_to_be_stored(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_utf8_text(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_message_set_utf8_text(IntPtr thiz, string text);

		/// <summary>
		/// Get text part of this message. 
		/// <para>
		/// Introduced in 01/07/2020 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The text in UTF8 or null if no text.   </returns>
		public string Utf8Text
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_utf8_text(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_chat_message_set_utf8_text(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_add_custom_header(IntPtr thiz, string headerName, string headerValue);

		/// <summary>
		/// Add custom headers to the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">name of the header   </param>
		/// <param name="headerValue">header value   </param>
		/// 
		public void AddCustomHeader(string headerName, string headerValue)
		{
			linphone_chat_message_add_custom_header(nativePtr, headerName, headerValue);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_add_file_content(IntPtr thiz, IntPtr content);

		/// <summary>
		/// Adds a file content to the ChatMessage. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">the <see cref="Linphone.Content" /> object to add.  
		/// </param>
		/// 
		public void AddFileContent(Linphone.Content content)
		{
			linphone_chat_message_add_file_content(nativePtr, content != null ? content.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_add_text_content(IntPtr thiz, string text);

		/// <summary>
		/// Creates a <see cref="Linphone.Content" /> of type PlainText with the given text
		/// as body. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="text">The text in System Locale to add to the message.   </param>
		/// 
		/// 
		/// deprecated : 01/07/2020. Use <see
		/// cref="Linphone.ChatMessage.AddUtf8TextContent()" /> instead. 
		public void AddTextContent(string text)
		{
			linphone_chat_message_add_text_content(nativePtr, text);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_add_utf8_text_content(IntPtr thiz, string text);

		/// <summary>
		/// Creates a <see cref="Linphone.Content" /> of type PlainText with the given text
		/// as body. 
		/// <para>
		/// Introduced in 01/07/2020 
		/// 
		/// </para>
		/// </summary>
		/// <param name="text">The text in UTF8 to add to the message.   </param>
		/// 
		public void AddUtf8TextContent(string text)
		{
			linphone_chat_message_add_utf8_text_content(nativePtr, text);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_cancel_file_transfer(IntPtr thiz);

		/// <summary>
		/// Cancel an ongoing file transfer attached to this message. 
		/// <para>
		/// (upload or download) 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void CancelFileTransfer()
		{
			linphone_chat_message_cancel_file_transfer(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_download_content(IntPtr thiz, IntPtr content);

		/// <summary>
		/// Start the download of the <see cref="Linphone.Content" /> referenced in the
		/// <see cref="Linphone.ChatMessage" /> from remote server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">the <see cref="Linphone.Content" /> object to download
		/// (must have the <see cref="Linphone.Content.IsFileTransfer()" /> method return
		/// true).   </param>
		/// 
		/// 
		/// <returns>false if there is an error, true otherwise. </returns>
		public bool DownloadContent(Linphone.Content content)
		{
			bool returnVal = linphone_chat_message_download_content(nativePtr, content != null ? content.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_custom_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Retrieve a custom header value given its name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">header name searched   </param>
		/// 
		/// 
		/// <returns>the custom header value or null if not found.   </returns>
		public string GetCustomHeader(string headerName)
		{
			IntPtr stringPtr = linphone_chat_message_get_custom_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_participants_by_imdn_state(IntPtr thiz, int state);

		/// <summary>
		/// Gets the list of participants for which the imdn state has reached the
		/// specified state and the time at which they did. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="state">The LinphoneChatMessageState the imdn have reached (only
		/// use LinphoneChatMessageStateDelivered, LinphoneChatMessageStateDeliveredToUser,
		/// LinphoneChatMessageStateDisplayed and LinphoneChatMessageStateNotDelivered)
		/// </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.ParticipantImdnState" /> objects.
		/// LinphoneParticipantImdnState      </returns>
		public IEnumerable<Linphone.ParticipantImdnState> GetParticipantsByImdnState(Linphone.ChatMessageState state)
		{
			IEnumerable<Linphone.ParticipantImdnState> returnVal = MarshalBctbxList<Linphone.ParticipantImdnState>(linphone_chat_message_get_participants_by_imdn_state(nativePtr, (int)state), false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_has_text_content(IntPtr thiz);

		/// <summary>
		/// Returns wether the chat message has a text content or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if it has one, false otherwise. </returns>
		/// 
		/// deprecated : 27/10/2020. Check if <see
		/// cref="Linphone.ChatMessage.GetContents()" /> contains a <see
		/// cref="Linphone.Content" /> for which it's content type is PlainText. 
		public bool HasTextContent()
		{
			bool returnVal = linphone_chat_message_has_text_content(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_message_put_char(IntPtr thiz, uint character);

		/// <summary>
		/// Fulfill a chat message char by char. 
		/// <para>
		/// Message linked to a Real Time Text Call send char in realtime following RFC
		/// 4103/T.140 To commit a message, use linphone_chat_room_send_message 
		/// 
		/// </para>
		/// </summary>
		/// <param name="character">T.140 char </param>
		/// 
		/// 
		/// <returns>0 if succeed. </returns>
		public void PutChar(uint character)
		{
			int exception_result = linphone_chat_message_put_char(nativePtr, character);
			if (exception_result != 0) throw new LinphoneException("PutChar returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_remove_content(IntPtr thiz, IntPtr content);

		/// <summary>
		/// Removes a content from the ChatMessage. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">the <see cref="Linphone.Content" /> object to remove.  
		/// </param>
		/// 
		public void RemoveContent(Linphone.Content content)
		{
			linphone_chat_message_remove_content(nativePtr, content != null ? content.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_remove_custom_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Removes a custom header from the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">name of the header to remove   </param>
		/// 
		public void RemoveCustomHeader(string headerName)
		{
			linphone_chat_message_remove_custom_header(nativePtr, headerName);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_send(IntPtr thiz);

		/// <summary>
		/// Send a chat message. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void Send()
		{
			linphone_chat_message_send(nativePtr);
			
			
			
		}
	}
	/// <summary>
	/// A chat room is the place where <see cref="Linphone.ChatMessage" /> are
	/// exchanged. 
	/// <para>
	/// To create (or find) a <see cref="Linphone.ChatRoom" />, you first need a <see
	/// cref="Linphone.ChatRoomParams" /> object. A chat room is uniquely identified by
	/// it's local and remote SIP addresses, meaning you can only have one chat room
	/// between two accounts (unless the backend is
	/// LinphoneChatRoomBackendFlexisipChat). Then you can call <see
	/// cref="Linphone.Core.SearchChatRoom()" /> or <see
	/// cref="Linphone.Core.CreateChatRoom()" />.
	/// 
	/// Be careful as a LinphoneChatRoomBackendFlexisipChat backend <see
	/// cref="Linphone.ChatRoom" /> will be created asynchronously, so make sure you
	/// add a LinphoneChatRoomCbs to the returned object to be notified when it will be
	/// in state LinphoneChatRoomStateCreated.
	/// 
	/// All chat rooms are loaded from database when the <see cref="Linphone.Core" />
	/// starts, and you can get them using <see cref="Linphone.Core.GetChatRooms()" />.
	/// This method doesn't return empty chat rooms nor ones for which the local
	/// address doesn't match an existing <see cref="Linphone.ProxyConfig" /> identity,
	/// unless you specify otherwise in the [misc] section of your configuration file
	/// by setting hide_empty_chat_rooms=0 and/or
	/// hide_chat_rooms_from_removed_proxies=0. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ChatRoom : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_chat_room_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_remove_callbacks(IntPtr thiz, IntPtr cbs);

		~ChatRoom() 
		{
			if (listener != null)
			{
				linphone_chat_room_remove_callbacks(nativePtr, listener.nativePtr);
			}
		}

		private ChatRoomListener listener;

		public ChatRoomListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_chat_room_cbs(linphone_factory_get());
					listener = fromNativePtr<ChatRoomListener>(nativeListener, false);
					linphone_chat_room_add_callbacks(nativePtr, nativeListener);
					listener.register();
				}
				return listener;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_call(IntPtr thiz);

		/// <summary>
		/// Gets the current call associated to this chatroom if any To commit a message,
		/// use linphone_chat_room_send_message 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.Call" /> or null.   </returns>
		public Linphone.Call Call
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_chat_room_get_capabilities(IntPtr thiz);

		/// <summary>
		/// Get the capabilities of a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The capabilities of the chat room (as a
		/// LinphoneChatRoomCapabilitiesMask) </returns>
		public uint Capabilities
		{
			get
			{
				return linphone_chat_room_get_capabilities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_chat_room_get_char(IntPtr thiz);

		/// <summary>
		/// When realtime text is enabled <see
		/// cref="Linphone.CallParams.RealtimeTextEnabled()" />,
		/// LinphoneCoreIsComposingReceivedCb is call everytime a char is received from
		/// peer. 
		/// <para>
		/// At the end of remote typing a regular <see cref="Linphone.ChatMessage" /> is
		/// received with committed data from LinphoneCoreMessageReceivedCb. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>RFC 4103/T.140 char </returns>
		public uint Char
		{
			get
			{
				return linphone_chat_room_get_char(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_composing_addresses(IntPtr thiz);

		/// <summary>
		/// Gets the list of participants that are currently composing. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Address" /> objects. LinphoneAddress 
		/// list of addresses that are in the is_composing state </returns>
		public IEnumerable<Linphone.Address> ComposingAddresses
		{
			get
			{
				return MarshalBctbxList<Linphone.Address>(linphone_chat_room_get_composing_addresses(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_conference_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_set_conference_address(IntPtr thiz, IntPtr conferenceAddress);

		/// <summary>
		/// Get the conference address of the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The conference address of the chat room or null if this type of chat
		/// room is not conference based.   </returns>
		public Linphone.Address ConferenceAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_conference_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_chat_room_set_conference_address(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_core(IntPtr thiz);

		/// <summary>
		/// Returns back pointer to <see cref="Linphone.Core" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Core" /> object this chat room is attached to.
		///   </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_current_callbacks(IntPtr thiz);

		/// <summary>
		/// Gets the current LinphoneChatRoomCbs. 
		/// <para>
		/// This is meant only to be called from a callback to be able to get the user_data
		/// associated with the LinphoneChatRoomCbs that is calling the callback. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneChatRoomCbs that has called the last callback   </returns>
		public Linphone.ChatRoomListener CurrentCallbacks
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_current_callbacks(nativePtr);
				Linphone.ChatRoomListener obj = fromNativePtr<Linphone.ChatRoomListener>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_current_params(IntPtr thiz);

		/// <summary>
		/// Returns current parameters associated with the chat room. 
		/// <para>
		/// This is typically the parameters passed at chat room chat_roomeation to
		/// linphone_core_chat_roomeate_chat_room() or some default parameters if no <see
		/// cref="Linphone.ChatRoomParams" /> was explicitely passed during chat room
		/// chat_roomeation. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the current <see cref="Linphone.ChatRoomParams" /> parameters.  
		/// </returns>
		public Linphone.ChatRoomParams CurrentParams
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_current_params(nativePtr);
				Linphone.ChatRoomParams obj = fromNativePtr<Linphone.ChatRoomParams>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_ephemeral_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_enable_ephemeral(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether or not the ephemeral message feature is enabled in the chat
		/// room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if ephemeral is enabled, false otherwise. </returns>
		public bool EphemeralEnabled
		{
			get
			{
				return linphone_chat_room_ephemeral_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_chat_room_enable_ephemeral(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_room_get_ephemeral_lifetime(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_set_ephemeral_lifetime(IntPtr thiz, int time);

		/// <summary>
		/// Get lifetime (in seconds) for all new ephemeral messages in the chat room. 
		/// <para>
		/// After the message is read, it will be deleted after "time" seconds. </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.ChatRoom.EphemeralEnabled()" /> </remarks>
		/// 
		/// <returns>the ephemeral lifetime (in secoonds) </returns>
		public int EphemeralLifetime
		{
			get
			{
				return linphone_chat_room_get_ephemeral_lifetime(nativePtr);
			}
			set
			{
				linphone_chat_room_set_ephemeral_lifetime(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_room_get_history_events_size(IntPtr thiz);

		/// <summary>
		/// Gets the number of events in a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the number of events. </returns>
		public int HistoryEventsSize
		{
			get
			{
				return linphone_chat_room_get_history_events_size(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_room_get_history_size(IntPtr thiz);

		/// <summary>
		/// Gets the number of messages in a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the number of messages. </returns>
		public int HistorySize
		{
			get
			{
				return linphone_chat_room_get_history_size(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_is_empty(IntPtr thiz);

		/// <summary>
		/// Returns whether or not a <see cref="Linphone.ChatRoom" /> has at least one <see
		/// cref="Linphone.ChatMessage" /> or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if there are no <see cref="Linphone.ChatMessage" />, false
		/// otherwise. </returns>
		public bool IsEmpty
		{
			get
			{
				return linphone_chat_room_is_empty(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_is_remote_composing(IntPtr thiz);

		/// <summary>
		/// Tells whether the remote is currently composing a message. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the remote is currently composing a message, false otherwise.
		/// </returns>
		public bool IsRemoteComposing
		{
			get
			{
				return linphone_chat_room_is_remote_composing(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_last_message_in_history(IntPtr thiz);

		/// <summary>
		/// Gets the last chat message sent or received in this chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the latest <see cref="Linphone.ChatMessage" /> or null if no message. 
		///  </returns>
		public Linphone.ChatMessage LastMessageInHistory
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_last_message_in_history(nativePtr);
				Linphone.ChatMessage obj = fromNativePtr<Linphone.ChatMessage>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_chat_room_get_last_update_time(IntPtr thiz);

		/// <summary>
		/// Return the last updated time for the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the last updated time </returns>
		public long LastUpdateTime
		{
			get
			{
				return linphone_chat_room_get_last_update_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_local_address(IntPtr thiz);

		/// <summary>
		/// Gets the local address associated to  this <see cref="Linphone.ChatRoom" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.Address" /> local address   </returns>
		public Linphone.Address LocalAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_local_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_me(IntPtr thiz);

		/// <summary>
		/// Get the participant representing myself in the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The participant representing myself in the conference or null if me is
		/// not set.   </returns>
		public Linphone.Participant Me
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_me(nativePtr);
				Linphone.Participant obj = fromNativePtr<Linphone.Participant>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_room_get_nb_participants(IntPtr thiz);

		/// <summary>
		/// Get the number of participants in the chat room (that is without ourselves). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The number of participants in the chat room </returns>
		public int NbParticipants
		{
			get
			{
				return linphone_chat_room_get_nb_participants(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_participants(IntPtr thiz);

		/// <summary>
		/// Get the list of participants of a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A A list of <see cref="Linphone.Participant" /> objects.
		/// LinphoneParticipant  of the participants </returns>
		public IEnumerable<Linphone.Participant> Participants
		{
			get
			{
				return MarshalBctbxList<Linphone.Participant>(linphone_chat_room_get_participants(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_peer_address(IntPtr thiz);

		/// <summary>
		/// Gets the peer address associated to  this <see cref="Linphone.ChatRoom" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.Address" /> peer address   </returns>
		public Linphone.Address PeerAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_peer_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomSecurityLevel linphone_chat_room_get_security_level(IntPtr thiz);

		/// <summary>
		/// Get the security level of a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current LinphoneChatRoomSecurityLevel of the chat room </returns>
		public Linphone.ChatRoomSecurityLevel SecurityLevel
		{
			get
			{
				return linphone_chat_room_get_security_level(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomState linphone_chat_room_get_state(IntPtr thiz);

		/// <summary>
		/// Get the state of the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current LinphoneChatRoomState of the chat room </returns>
		public Linphone.ChatRoomState State
		{
			get
			{
				return linphone_chat_room_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_subject(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_set_subject(IntPtr thiz, string subject);

		/// <summary>
		/// Get the subject of a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The subject of the chat room.   </returns>
		public string Subject
		{
			get
			{
				IntPtr stringPtr = linphone_chat_room_get_subject(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_chat_room_set_subject(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_room_get_unread_messages_count(IntPtr thiz);

		/// <summary>
		/// Gets the number of unread messages in the chatroom. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the number of unread messages. </returns>
		public int UnreadMessagesCount
		{
			get
			{
				return linphone_chat_room_get_unread_messages_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_add_participant(IntPtr thiz, IntPtr addr);

		/// <summary>
		/// Add a participant to a chat room. 
		/// <para>
		/// This may fail if this type of chat room does not handle participants. Use <see
		/// cref="Linphone.ChatRoom.CanHandleParticipants()" /> to know if this chat room
		/// handles participants. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="addr">The address of the participant to add to the chat room  
		/// </param>
		/// 
		public void AddParticipant(Linphone.Address addr)
		{
			linphone_chat_room_add_participant(nativePtr, addr != null ? addr.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_add_participants(IntPtr thiz, IntPtr addresses);

		/// <summary>
		/// Add several participants to a chat room at once. 
		/// <para>
		/// This may fail if this type of chat room does not handle participants. Use <see
		/// cref="Linphone.ChatRoom.CanHandleParticipants()" /> to know if this chat room
		/// handles participants. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="addresses">A list of <see cref="Linphone.Address" /> objects.
		/// LinphoneAddress    </param>
		/// 
		/// 
		/// <returns>true if everything is OK, false otherwise </returns>
		public bool AddParticipants(IEnumerable<Linphone.Address> addresses)
		{
			bool returnVal = linphone_chat_room_add_participants(nativePtr, ObjectArrayToBctbxList<Linphone.Address>(addresses)) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_allow_cpim(IntPtr thiz);

		/// <summary>
		/// Allow cpim on a basic chat room   . 
		/// <para>
		/// </para>
		/// </summary>
		public void AllowCpim()
		{
			linphone_chat_room_allow_cpim(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_allow_multipart(IntPtr thiz);

		/// <summary>
		/// Allow multipart on a basic chat room   . 
		/// <para>
		/// </para>
		/// </summary>
		public void AllowMultipart()
		{
			linphone_chat_room_allow_multipart(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_can_handle_participants(IntPtr thiz);

		/// <summary>
		/// Tells whether a chat room is able to handle participants. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the chat room can handle participants, false otherwise
		/// </returns>
		public bool CanHandleParticipants()
		{
			bool returnVal = linphone_chat_room_can_handle_participants(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_compose(IntPtr thiz);

		/// <summary>
		/// Notifies the destination of the chat message being composed that the user is
		/// typing a new message. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void Compose()
		{
			linphone_chat_room_compose(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_create_empty_message(IntPtr thiz);

		/// <summary>
		/// Creates an empty message attached to the given chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a new <see cref="Linphone.ChatMessage" />   </returns>
		public Linphone.ChatMessage CreateEmptyMessage()
		{
			IntPtr ptr = linphone_chat_room_create_empty_message(nativePtr);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_create_file_transfer_message(IntPtr thiz, IntPtr initialContent);

		/// <summary>
		/// Creates a message attached to the given chat room with a particular content. 
		/// <para>
		/// Use linphone_chat_room_send_message to initiate the transfer 
		/// 
		/// </para>
		/// </summary>
		/// <param name="initialContent"><see cref="Linphone.Content" /> initial content.  
		/// </param>
		/// 
		/// 
		/// <returns>a new <see cref="Linphone.ChatMessage" />   </returns>
		public Linphone.ChatMessage CreateFileTransferMessage(Linphone.Content initialContent)
		{
			IntPtr ptr = linphone_chat_room_create_file_transfer_message(nativePtr, initialContent != null ? initialContent.nativePtr : IntPtr.Zero);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_create_forward_message(IntPtr thiz, IntPtr message);

		/// <summary>
		/// Creates a forward message attached to the given chat room with a particular
		/// message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message"><see cref="Linphone.ChatMessage" /> message to be
		/// forwarded.   </param>
		/// 
		/// 
		/// <returns>a new <see cref="Linphone.ChatMessage" />   </returns>
		public Linphone.ChatMessage CreateForwardMessage(Linphone.ChatMessage message)
		{
			IntPtr ptr = linphone_chat_room_create_forward_message(nativePtr, message != null ? message.nativePtr : IntPtr.Zero);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_create_message(IntPtr thiz, string message);

		/// <summary>
		/// Creates a message attached to the given chat room with a plain text content
		/// filled with the given message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">text message, null if absent.   </param>
		/// 
		/// 
		/// <returns>a new <see cref="Linphone.ChatMessage" />   </returns>
		/// 
		/// deprecated : 01/07/2020. Use <see
		/// cref="Linphone.ChatRoom.CreateMessageFromUtf8()" /> instead. 
		public Linphone.ChatMessage CreateMessage(string message)
		{
			IntPtr ptr = linphone_chat_room_create_message(nativePtr, message);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_create_message_from_utf8(IntPtr thiz, string message);

		/// <summary>
		/// Creates a message attached to the given chat room with a plain text content
		/// filled with the given message. 
		/// <para>
		/// Introduced in 01/07/2020 
		/// 
		/// </para>
		/// </summary>
		/// <param name="message">text message in UTF8, null if absent.   </param>
		/// 
		/// 
		/// <returns>a new <see cref="Linphone.ChatMessage" />   </returns>
		public Linphone.ChatMessage CreateMessageFromUtf8(string message)
		{
			IntPtr ptr = linphone_chat_room_create_message_from_utf8(nativePtr, message);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_delete_history(IntPtr thiz);

		/// <summary>
		/// Delete all messages from the history. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void DeleteHistory()
		{
			linphone_chat_room_delete_history(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_delete_message(IntPtr thiz, IntPtr message);

		/// <summary>
		/// Delete a message from the chat room history. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The <see cref="Linphone.ChatMessage" /> object to remove.
		///   </param>
		/// 
		public void DeleteMessage(Linphone.ChatMessage message)
		{
			linphone_chat_room_delete_message(nativePtr, message != null ? message.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_ephemeral_supported_by_all_participants(IntPtr thiz);

		/// <summary>
		/// Uses linphone spec to check if all participants support ephemeral messages. 
		/// <para>
		/// It doesn't prevent to send ephemeral messages in the room but those who don't
		/// support it won't delete messages after lifetime has expired. </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.ChatRoom.EphemeralEnabled()" /> </remarks>
		/// 
		/// <returns>true if all participants in the chat room support ephemeral messages,
		/// false otherwise </returns>
		public bool EphemeralSupportedByAllParticipants()
		{
			bool returnVal = linphone_chat_room_ephemeral_supported_by_all_participants(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_find_message(IntPtr thiz, string messageId);

		/// <summary>
		/// Gets the chat message sent or received in this chat room that matches the
		/// message_id. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="messageId">The id of the message to find   </param>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.ChatMessage" /> if found or null.   </returns>
		public Linphone.ChatMessage FindMessage(string messageId)
		{
			IntPtr ptr = linphone_chat_room_find_message(nativePtr, messageId);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_find_participant(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Find a participant of a chat room from its address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">The <see cref="Linphone.Address" /> to search in the list
		/// of participants of the chat room   </param>
		/// 
		/// 
		/// <returns>The participant if found, null otherwise.   </returns>
		public Linphone.Participant FindParticipant(Linphone.Address address)
		{
			IntPtr ptr = linphone_chat_room_find_participant(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			Linphone.Participant returnVal = fromNativePtr<Linphone.Participant>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_history(IntPtr thiz, int nbMessage);

		/// <summary>
		/// Gets nb_message most recent messages from chat_room chat room, sorted from
		/// oldest to most recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="nbMessage">Number of message to retrieve. 0 means everything.
		/// </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.ChatMessage" /> objects.
		/// LinphoneChatMessage    </returns>
		public IEnumerable<Linphone.ChatMessage> GetHistory(int nbMessage)
		{
			IEnumerable<Linphone.ChatMessage> returnVal = MarshalBctbxList<Linphone.ChatMessage>(linphone_chat_room_get_history(nativePtr, nbMessage), false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_history_events(IntPtr thiz, int nbEvents);

		/// <summary>
		/// Gets nb_events most recent events from chat_room chat room, sorted from oldest
		/// to most recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="nbEvents">Number of events to retrieve. 0 means everything.
		/// </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.EventLog" /> objects. LinphoneEventLog  
		///  </returns>
		public IEnumerable<Linphone.EventLog> GetHistoryEvents(int nbEvents)
		{
			IEnumerable<Linphone.EventLog> returnVal = MarshalBctbxList<Linphone.EventLog>(linphone_chat_room_get_history_events(nativePtr, nbEvents), false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_history_message_events(IntPtr thiz, int nbEvents);

		/// <summary>
		/// Gets nb_events most recent chat message events from chat_room chat room, sorted
		/// from oldest to most recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="nbEvents">Number of events to retrieve. 0 means everything.
		/// </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.EventLog" /> objects. LinphoneEventLog  
		///  </returns>
		public IEnumerable<Linphone.EventLog> GetHistoryMessageEvents(int nbEvents)
		{
			IEnumerable<Linphone.EventLog> returnVal = MarshalBctbxList<Linphone.EventLog>(linphone_chat_room_get_history_message_events(nativePtr, nbEvents), false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_history_range(IntPtr thiz, int begin, int end);

		/// <summary>
		/// Gets the partial list of messages in the given range, sorted from oldest to
		/// most recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="begin">The first message of the range to be retrieved. History
		/// most recent message has index 0. </param>
		/// <param name="end">The last message of the range to be retrieved. History oldest
		/// message has index of history size - 1 (use linphone_chat_room_get_history_size
		/// to retrieve history size) </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.ChatMessage" /> objects.
		/// LinphoneChatMessage    </returns>
		public IEnumerable<Linphone.ChatMessage> GetHistoryRange(int begin, int end)
		{
			IEnumerable<Linphone.ChatMessage> returnVal = MarshalBctbxList<Linphone.ChatMessage>(linphone_chat_room_get_history_range(nativePtr, begin, end), false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_history_range_events(IntPtr thiz, int begin, int end);

		/// <summary>
		/// Gets the partial list of events in the given range, sorted from oldest to most
		/// recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="begin">The first event of the range to be retrieved. History most
		/// recent event has index 0. </param>
		/// <param name="end">The last event of the range to be retrieved. History oldest
		/// event has index of history size - 1 </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.EventLog" /> objects. LinphoneEventLog  
		///  </returns>
		public IEnumerable<Linphone.EventLog> GetHistoryRangeEvents(int begin, int end)
		{
			IEnumerable<Linphone.EventLog> returnVal = MarshalBctbxList<Linphone.EventLog>(linphone_chat_room_get_history_range_events(nativePtr, begin, end), false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_history_range_message_events(IntPtr thiz, int begin, int end);

		/// <summary>
		/// Gets the partial list of chat message events in the given range, sorted from
		/// oldest to most recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="begin">The first event of the range to be retrieved. History most
		/// recent event has index 0. </param>
		/// <param name="end">The last event of the range to be retrieved. History oldest
		/// event has index of history size - 1 </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.EventLog" /> objects. LinphoneEventLog  
		///  </returns>
		public IEnumerable<Linphone.EventLog> GetHistoryRangeMessageEvents(int begin, int end)
		{
			IEnumerable<Linphone.EventLog> returnVal = MarshalBctbxList<Linphone.EventLog>(linphone_chat_room_get_history_range_message_events(nativePtr, begin, end), false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_has_been_left(IntPtr thiz);

		/// <summary>
		/// Return whether or not the chat room has been left. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the chat room has been left, false otherwise. </returns>
		public bool HasBeenLeft()
		{
			bool returnVal = linphone_chat_room_has_been_left(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_has_capability(IntPtr thiz, int mask);

		/// <summary>
		/// Check if a chat room has given capabilities. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="mask">a LinphoneChatRoomCapabilitiesMask mask </param>
		/// 
		/// 
		/// <returns>true if the mask matches, false otherwise </returns>
		public bool HasCapability(int mask)
		{
			bool returnVal = linphone_chat_room_has_capability(nativePtr, mask) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_leave(IntPtr thiz);

		/// <summary>
		/// Leave a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void Leave()
		{
			linphone_chat_room_leave(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_lime_available(IntPtr thiz);

		/// <summary>
		/// Returns wether lime is available for given peer or not. 
		/// <para>
		/// 
		/// 
		/// </para>
		/// </summary>
		public bool LimeAvailable()
		{
			bool returnVal = linphone_chat_room_lime_available(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_mark_as_read(IntPtr thiz);

		/// <summary>
		/// Mark all messages of the conversation as read. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void MarkAsRead()
		{
			linphone_chat_room_mark_as_read(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_notify_participant_device_registration(IntPtr thiz, IntPtr participantDevice);

		/// <summary>
		/// Notify the chatroom that a participant device has just registered. 
		/// <para>
		/// This function is meaningful only for server implementation of chatroom, and
		/// shall not by used by client applications. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="participantDevice">list of the participant devices to be used by
		/// the group chat room   </param>
		/// 
		public void NotifyParticipantDeviceRegistration(Linphone.Address participantDevice)
		{
			linphone_chat_room_notify_participant_device_registration(nativePtr, participantDevice != null ? participantDevice.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_receive_chat_message(IntPtr thiz, IntPtr message);

		/// <summary>
		/// Used to receive a chat message when using async mechanism with IM
		/// enchat_roomyption engine. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message"><see cref="Linphone.ChatMessage" /> object   </param>
		/// 
		public void ReceiveChatMessage(Linphone.ChatMessage message)
		{
			linphone_chat_room_receive_chat_message(nativePtr, message != null ? message.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_remove_participant(IntPtr thiz, IntPtr participant);

		/// <summary>
		/// Remove a participant of a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant">The participant to remove from the chat room  
		/// </param>
		/// 
		public void RemoveParticipant(Linphone.Participant participant)
		{
			linphone_chat_room_remove_participant(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_remove_participants(IntPtr thiz, IntPtr participants);

		/// <summary>
		/// Remove several participants of a chat room at once. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participants">A list of <see cref="Linphone.Participant" />
		/// objects. LinphoneParticipant    </param>
		/// 
		public void RemoveParticipants(IEnumerable<Linphone.Participant> participants)
		{
			linphone_chat_room_remove_participants(nativePtr, ObjectArrayToBctbxList<Linphone.Participant>(participants));
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_set_participant_admin_status(IntPtr thiz, IntPtr participant, char isAdmin);

		/// <summary>
		/// Change the admin status of a participant of a chat room (you need to be an
		/// admin yourself to do this). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant">The Participant for which to change the admin status 
		///  </param>
		/// <param name="isAdmin">A boolean value telling whether the participant should
		/// now be an admin or not </param>
		/// 
		public void SetParticipantAdminStatus(Linphone.Participant participant, bool isAdmin)
		{
			linphone_chat_room_set_participant_admin_status(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero, isAdmin ? (char)1 : (char)0);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_set_participant_devices(IntPtr thiz, IntPtr participantAddress, IntPtr deviceIdentities);

		/// <summary>
		/// Set the list of participant devices in the form of SIP URIs with GRUUs for a
		/// given participant. 
		/// <para>
		/// This function is meaningful only for server implementation of chatroom, and
		/// shall not by used by client applications. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="participantAddress">The participant address   </param>
		/// <param name="deviceIdentities">A list of <see
		/// cref="Linphone.ParticipantDeviceIdentity" /> objects.
		/// LinphoneParticipantDeviceIdentity  list of the participant devices to be used
		/// by the group chat room   </param>
		/// 
		public void SetParticipantDevices(Linphone.Address participantAddress, IEnumerable<Linphone.ParticipantDeviceIdentity> deviceIdentities)
		{
			linphone_chat_room_set_participant_devices(nativePtr, participantAddress != null ? participantAddress.nativePtr : IntPtr.Zero, ObjectArrayToBctbxList<Linphone.ParticipantDeviceIdentity>(deviceIdentities));
			
			
			
		}
	}
	/// <summary>
	/// Object defining parameters for a <see cref="Linphone.ChatRoom" />. 
	/// <para>
	/// Can be created with <see cref="Linphone.Core.CreateDefaultChatRoomParams()" />.
	/// You can use <see cref="Linphone.ChatRoomParams.IsValid()" /> to check if your
	/// configuration is valid or not.
	/// 
	/// If the <see cref="Linphone.ChatRoom" /> backend is
	/// LinphoneChatRoomBackendBasic, then no other parameter is required, but <see
	/// cref="Linphone.ChatMessage" /> sent and received won't benefit from all
	/// features a LinphoneChatRoomBackendFlexisipChat can offer like conversation with
	/// multiple participants and a subject, end-to-end encryption, ephemeral messages,
	/// etc... but this type is the only one that can interoperate with other SIP
	/// clients or with non-flexisip SIP proxies. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ChatRoomParams : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomBackend linphone_chat_room_params_get_backend(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_set_backend(IntPtr thiz, int backend);

		/// <summary>
		/// Get the backend implementation of the chat room associated with the given
		/// parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the LinphoneChatRoomBackend </returns>
		public Linphone.ChatRoomBackend Backend
		{
			get
			{
				return linphone_chat_room_params_get_backend(nativePtr);
			}
			set
			{
				linphone_chat_room_params_set_backend(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomEncryptionBackend linphone_chat_room_params_get_encryption_backend(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_set_encryption_backend(IntPtr thiz, int backend);

		/// <summary>
		/// Get the encryption implementation of the chat room associated with the given
		/// parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the LinphoneChatRoomEncryptionBackend </returns>
		public Linphone.ChatRoomEncryptionBackend EncryptionBackend
		{
			get
			{
				return linphone_chat_room_params_get_encryption_backend(nativePtr);
			}
			set
			{
				linphone_chat_room_params_set_encryption_backend(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_params_encryption_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_enable_encryption(IntPtr thiz, char encrypted);

		/// <summary>
		/// Get the encryption status of the chat room associated with the given
		/// parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if encryption is enabled, false otherwise </returns>
		public bool EncryptionEnabled
		{
			get
			{
				return linphone_chat_room_params_encryption_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_chat_room_params_enable_encryption(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_params_group_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_enable_group(IntPtr thiz, char group);

		/// <summary>
		/// Get the group chat status of the chat room associated with the given
		/// parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if group chat is enabled, false if one-to-one </returns>
		public bool GroupEnabled
		{
			get
			{
				return linphone_chat_room_params_group_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_chat_room_params_enable_group(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_params_is_valid(IntPtr thiz);

		/// <summary>
		/// Returns whether the given parameters are valid or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the given parameters are valid, false otherwise </returns>
		public bool IsValid
		{
			get
			{
				return linphone_chat_room_params_is_valid(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_params_rtt_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_enable_rtt(IntPtr thiz, char rtt);

		/// <summary>
		/// Get the real time text status of the chat room associated with the given
		/// parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if real time text is enabled, false otherwise </returns>
		public bool RttEnabled
		{
			get
			{
				return linphone_chat_room_params_rtt_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_chat_room_params_enable_rtt(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_params_get_subject(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_set_subject(IntPtr thiz, string subject);

		/// <summary>
		/// Get the subject of the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The subject.   </returns>
		public string Subject
		{
			get
			{
				IntPtr stringPtr = linphone_chat_room_params_get_subject(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_chat_room_params_set_subject(nativePtr, value);
				
			}
		}
	}
	/// <summary>
	/// TODO. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Conference : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_conference_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_remove_callbacks(IntPtr thiz, IntPtr cbs);

		~Conference() 
		{
			if (listener != null)
			{
				linphone_conference_remove_callbacks(nativePtr, listener.nativePtr);
			}
		}

		private ConferenceListener listener;

		public ConferenceListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_conference_cbs(linphone_factory_get());
					listener = fromNativePtr<ConferenceListener>(nativeListener, false);
					linphone_conference_add_callbacks(nativePtr, nativeListener);
					listener.register();
				}
				return listener;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_conference_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_conference_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Get the conference address of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The conference address of the conference.   </returns>
		public Linphone.Address ConferenceAddress
		{
			get
			{
				IntPtr ptr = linphone_conference_get_conference_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_conference_set_conference_address(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_core(IntPtr thiz);

		/// <summary>
		/// Returns core for a <see cref="Linphone.Conference" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>back pointer to <see cref="Linphone.Core" /> object.   Returns back
		/// pointer to <see cref="Linphone.Core" /> object. </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_conference_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_current_callbacks(IntPtr thiz);

		/// <summary>
		/// Gets the current LinphoneConferenceCbs. 
		/// <para>
		/// This is meant only to be called from a callback to be able to get the user_data
		/// associated with the LinphoneConferenceCbs that is calling the callback. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneConferenceCbs that has called the last callback.  
		/// </returns>
		public Linphone.ConferenceListener CurrentCallbacks
		{
			get
			{
				IntPtr ptr = linphone_conference_get_current_callbacks(nativePtr);
				Linphone.ConferenceListener obj = fromNativePtr<Linphone.ConferenceListener>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_current_params(IntPtr thiz);

		/// <summary>
		/// Get current parameters of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.ConferenceParams" /> .   </returns>
		public Linphone.ConferenceParams CurrentParams
		{
			get
			{
				IntPtr ptr = linphone_conference_get_current_params(nativePtr);
				Linphone.ConferenceParams obj = fromNativePtr<Linphone.ConferenceParams>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_ID(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_ID(IntPtr thiz, string conferenceId);

		/// <summary>
		/// Get the conference id as string. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the conference id   </returns>
		/// 
		/// deprecated : 10/07/2020 Use <see
		/// cref="Linphone.Conference.GetConferenceAddress()" /> instead. 
		public string Id
		{
			get
			{
				IntPtr stringPtr = linphone_conference_get_ID(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_conference_set_ID(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_me(IntPtr thiz);

		/// <summary>
		/// For a local audio video conference, this function returns the participant
		/// hosting the conference For a remote audio video conference, this function
		/// returns the focus of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Participant" /> .   </returns>
		public Linphone.Participant Me
		{
			get
			{
				IntPtr ptr = linphone_conference_get_me(nativePtr);
				Linphone.Participant obj = fromNativePtr<Linphone.Participant>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_get_participant_count(IntPtr thiz);

		/// <summary>
		/// Get number of participants. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the number of participants in a <see cref="Linphone.Conference" />
		/// </returns>
		public int ParticipantCount
		{
			get
			{
				return linphone_conference_get_participant_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_participant_list(IntPtr thiz);

		/// <summary>
		/// Get list of all participants of one conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Participant" /> objects.
		/// LinphoneParticipant    </returns>
		public IEnumerable<Linphone.Participant> ParticipantList
		{
			get
			{
				return MarshalBctbxList<Linphone.Participant>(linphone_conference_get_participant_list(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_participants(IntPtr thiz);

		/// <summary>
		/// Get URIs of all participants of one conference The returned bctbx_list_t
		/// contains URIs of all participant. 
		/// <para>
		/// That list must be freed after use and each URI must be unref with
		/// linphone_address_unref 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Address" /> objects. LinphoneAddress   
		/// </returns>
		/// 
		/// deprecated : 10/07/2020 Use <see
		/// cref="Linphone.Conference.GetParticipantList()" /> instead. 
		public IEnumerable<Linphone.Address> Participants
		{
			get
			{
				return MarshalBctbxList<Linphone.Address>(linphone_conference_get_participants(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_subject(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_subject(IntPtr thiz, string subject);

		/// <summary>
		/// Get the conference subject. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>conference subject.   </returns>
		public string Subject
		{
			get
			{
				IntPtr stringPtr = linphone_conference_get_subject(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_conference_set_subject(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_add_participant(IntPtr thiz, IntPtr call);

		/// <summary>
		/// Join an existing call to the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">a <see cref="Linphone.Call" /> that has to be added to the
		/// conference.   </param>
		/// 
		public void AddParticipant(Linphone.Call call)
		{
			int exception_result = linphone_conference_add_participant(nativePtr, call != null ? call.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddParticipant returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_add_participant_2(IntPtr thiz, IntPtr uri);

		/// <summary>
		/// Join a participant to the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">a <see cref="Linphone.Address" /> that has to be added to the
		/// conference.   </param>
		/// 
		public void AddParticipant(Linphone.Address uri)
		{
			int exception_result = linphone_conference_add_participant_2(nativePtr, uri != null ? uri.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddParticipant returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_find_participant(IntPtr thiz, IntPtr uri);

		/// <summary>
		/// Find a participant from a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">SIP URI of the participant to search.   </param>
		/// 
		/// 
		/// <returns>a pointer to the participant found or nullptr.   </returns>
		public Linphone.Participant FindParticipant(Linphone.Address uri)
		{
			IntPtr ptr = linphone_conference_find_participant(nativePtr, uri != null ? uri.nativePtr : IntPtr.Zero);
			Linphone.Participant returnVal = fromNativePtr<Linphone.Participant>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_invite_participants(IntPtr thiz, IntPtr addresses, IntPtr parameters);

		/// <summary>
		/// Invite participants to the conference, by supplying a list of <see
		/// cref="Linphone.Address" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="addresses">A list of <see cref="Linphone.Address" /> objects.
		/// LinphoneAddress    </param>
		/// <param name="parameters"><see cref="Linphone.CallParams" /> to use for inviting
		/// the participants.   </param>
		/// 
		public void InviteParticipants(IEnumerable<Linphone.Address> addresses, Linphone.CallParams parameters)
		{
			int exception_result = linphone_conference_invite_participants(nativePtr, ObjectArrayToBctbxList<Linphone.Address>(addresses), parameters != null ? parameters.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("InviteParticipants returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_ogl_render(IntPtr thiz);

		/// <summary>
		/// Call generic OpenGL render for a given conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void OglRender()
		{
			linphone_conference_ogl_render(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_preview_ogl_render(IntPtr thiz);

		/// <summary>
		/// Call generic OpenGL render preview for a given conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void PreviewOglRender()
		{
			linphone_conference_preview_ogl_render(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_remove_participant(IntPtr thiz, IntPtr uri);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">URI of the participant to remove   </param>
		/// 
		/// 
		/// <remarks>Warning : The passed participant uri must be one of those returned by
		/// <see cref="Linphone.Conference.GetParticipants()" /> </remarks> 
		/// 
		/// <returns>0 if succeeded, -1 if failed </returns>
		/// 
		/// deprecated : 10/07/2020 Use <see cref="Linphone.Conference.RemoveParticipant()"
		/// /> instead. 
		public void RemoveParticipant(Linphone.Address uri)
		{
			int exception_result = linphone_conference_remove_participant(nativePtr, uri != null ? uri.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("RemoveParticipant returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_remove_participant_2(IntPtr thiz, IntPtr participant);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant">participant to remove   </param>
		/// 
		/// 
		/// <remarks>Warning : The passed participant must be one of those returned by <see
		/// cref="Linphone.Conference.GetParticipantList()" /> </remarks> 
		/// 
		/// <remarks>Warning : This method may destroy the conference if the only remaining
		/// participant had an existing call to the local participant before the conference
		/// was created </remarks> 
		/// 
		/// <returns>0 if succeeded, -1 if failed </returns>
		public void RemoveParticipant(Linphone.Participant participant)
		{
			int exception_result = linphone_conference_remove_participant_2(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("RemoveParticipant returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_remove_participant_3(IntPtr thiz, IntPtr call);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">call to remove   </param>
		/// 
		/// 
		/// <returns>0 if succeeded, -1 if failed </returns>
		/// 
		/// deprecated : 10/07/2020 Use <see cref="Linphone.Conference.RemoveParticipant()"
		/// /> instead. 
		public void RemoveParticipant(Linphone.Call call)
		{
			int exception_result = linphone_conference_remove_participant_3(nativePtr, call != null ? call.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("RemoveParticipant returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_participant_admin_status(IntPtr thiz, IntPtr participant, char isAdmin);

		/// <summary>
		/// Change the admin status of a participant of a conference (you need to be an
		/// admin yourself to do this). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant">The Participant for which to change the admin status 
		///  </param>
		/// <param name="isAdmin">A boolean value telling whether the participant should
		/// now be an admin or not </param>
		/// 
		public void SetParticipantAdminStatus(Linphone.Participant participant, bool isAdmin)
		{
			linphone_conference_set_participant_admin_status(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero, isAdmin ? (char)1 : (char)0);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_terminate(IntPtr thiz);

		/// <summary>
		/// Terminates conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if the termination is successful, -1 otherwise. </returns>
		public int Terminate()
		{
			int returnVal = linphone_conference_terminate(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_update_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Update parameters of the conference. 
		/// <para>
		/// This is typically used enable or disable the video stream in the conference. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="parameters">the new parameters to apply.   </param>
		/// 
		public int UpdateParams(Linphone.ConferenceParams parameters)
		{
			int returnVal = linphone_conference_update_params(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			
			
			return returnVal;
		}
	}
	/// <summary>
	/// TODO. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ConferenceParams : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_local_participant_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_enable_local_participant(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether local participant has to enter the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if local participant is by default part of the conference, false
		/// otherwise </returns>
		public bool LocalParticipantEnabled
		{
			get
			{
				return linphone_conference_params_local_participant_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_conference_params_enable_local_participant(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_video_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_enable_video(IntPtr thiz, char enable);

		/// <summary>
		/// Check whether video will be enable at conference starting. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the video will be enable at conference starting, false
		/// otherwise </returns>
		public bool VideoEnabled
		{
			get
			{
				return linphone_conference_params_video_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_conference_params_enable_video(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_params_clone(IntPtr thiz);

		/// <summary>
		/// Clone a <see cref="Linphone.ConferenceParams" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>An allocated <see cref="Linphone.ConferenceParams" /> with the same
		/// parameters than params   </returns>
		public Linphone.ConferenceParams Clone()
		{
			IntPtr ptr = linphone_conference_params_clone(nativePtr);
			Linphone.ConferenceParams returnVal = fromNativePtr<Linphone.ConferenceParams>(ptr, false);
			
			return returnVal;
		}
	}
	/// <summary>
	/// This object is used to manipulate a configuration file. 
	/// <para>
	/// The format of the configuration file is a .ini like format:
	/// 
	/// 
	/// Various types can be used: strings and lists of strings, integers, floats,
	/// booleans (written as 0 or 1) and range of integers.
	/// 
	/// Usually a <see cref="Linphone.Core" /> is initialized using two <see
	/// cref="Linphone.Config" />, one default (where configuration changes through API
	/// calls will be saved) and one named 'factory' which is read-only and overwrites
	/// any setting that may exists in the default one.
	/// 
	/// It is also possible to use only one (either default or factory) or even none. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Config : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_new_from_buffer(string buffer);

		/// <summary>
		/// Instantiates a <see cref="Linphone.Config" /> object from a user provided
		/// buffer. 
		/// <para>
		/// The caller of this constructor owns a reference. linphone_config_unref must be
		/// called when this object is no longer needed.
		/// 
		/// </para>
		/// </summary>
		/// <param name="buffer">the buffer from which the <see cref="Linphone.Config" />
		/// will be retrieved. We expect the buffer to be null-terminated.   </param>
		/// 
		/// 
		/// <remarks>See : linphone_config_new_with_factory </remarks>
		/// 
		/// <remarks>See : linphone_config_new </remarks>
		/// 
		/// <returns>a <see cref="Linphone.Config" /> object   </returns>
		public static Linphone.Config NewFromBuffer(string buffer)
		{
			IntPtr ptr = linphone_config_new_from_buffer(buffer);
			Linphone.Config returnVal = fromNativePtr<Linphone.Config>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_new_with_factory(string configFilename, string factoryConfigFilename);

		/// <summary>
		/// Instantiates a <see cref="Linphone.Config" /> object from a user config file
		/// and a factory config file. 
		/// <para>
		/// The caller of this constructor owns a reference. linphone_config_unref must be
		/// called when this object is no longer needed.
		/// 
		/// </para>
		/// </summary>
		/// <param name="configFilename">the filename of the user config file to read to
		/// fill the instantiated <see cref="Linphone.Config" />   </param>
		/// <param name="factoryConfigFilename">the filename of the factory config file to
		/// read to fill the instantiated <see cref="Linphone.Config" />   </param>
		/// 
		/// 
		/// <remarks>See : linphone_config_new </remarks>
		/// 
		/// <returns>a <see cref="Linphone.Config" /> object  </returns>
		/// 
		/// The user config file is read first to fill the <see cref="Linphone.Config" />
		/// and then the factory config file is read. Therefore the configuration
		/// parameters defined in the user config file will be overwritten by the
		/// parameters defined in the factory config file. 
		public static Linphone.Config NewWithFactory(string configFilename, string factoryConfigFilename)
		{
			IntPtr ptr = linphone_config_new_with_factory(configFilename, factoryConfigFilename);
			Linphone.Config returnVal = fromNativePtr<Linphone.Config>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_get_sections_names_list(IntPtr thiz);

		/// <summary>
		/// Returns the list of sections' names in the LinphoneConfig. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of char * objects. char *  a null terminated static array of
		/// strings   </returns>
		public IEnumerable<string> SectionsNamesList
		{
			get
			{
				return MarshalStringArray(linphone_config_get_sections_names_list(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_clean_entry(IntPtr thiz, string section, string key);

		/// <summary>
		/// Removes entries for key,value in a section. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">the section for which to clean the key entry   </param>
		/// <param name="key">the key to clean   </param>
		/// 
		public void CleanEntry(string section, string key)
		{
			linphone_config_clean_entry(nativePtr, section, key);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_clean_section(IntPtr thiz, string section);

		/// <summary>
		/// Removes every pair of key,value in a section and remove the section. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">the section to clean   </param>
		/// 
		public void CleanSection(string section)
		{
			linphone_config_clean_section(nativePtr, section);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_dump(IntPtr thiz);

		/// <summary>
		/// Dumps the <see cref="Linphone.Config" /> as INI into a buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The buffer that contains the config dump   </returns>
		public string Dump()
		{
			IntPtr stringPtr = linphone_config_dump(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_dump_as_xml(IntPtr thiz);

		/// <summary>
		/// Dumps the <see cref="Linphone.Config" /> as XML into a buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The buffer that contains the XML dump   </returns>
		public string DumpAsXml()
		{
			IntPtr stringPtr = linphone_config_dump_as_xml(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_get_bool(IntPtr thiz, string section, string key, char defaultValue);

		/// <summary>
		/// Retrieves a configuration item as a boolean, given its section, key, and
		/// default value. 
		/// <para>
		/// The default boolean value is returned if the config item isn't found. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// 
		/// 
		/// <returns>the found value or default_value if not found. </returns>
		public bool GetBool(string section, string key, bool defaultValue)
		{
			bool returnVal = linphone_config_get_bool(nativePtr, section, key, defaultValue ? (char)1 : (char)0) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_config_get_default_float(IntPtr thiz, string section, string key, float defaultValue);

		/// <summary>
		/// Retrieves a default configuration item as a float, given its section, key, and
		/// default value. 
		/// <para>
		/// The default float value is returned if the config item isn't found. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the default value  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// 
		/// 
		/// <returns>the found default value or default_value if not found. </returns>
		public float GetDefaultFloat(string section, string key, float defaultValue)
		{
			float returnVal = linphone_config_get_default_float(nativePtr, section, key, defaultValue);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_get_default_int(IntPtr thiz, string section, string key, int defaultValue);

		/// <summary>
		/// Retrieves a default configuration item as an integer, given its section, key,
		/// and default value. 
		/// <para>
		/// The default integer value is returned if the config item isn't found. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the default value  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// 
		/// 
		/// <returns>the found default value or default_value if not found. </returns>
		public int GetDefaultInt(string section, string key, int defaultValue)
		{
			int returnVal = linphone_config_get_default_int(nativePtr, section, key, defaultValue);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_get_default_int64(IntPtr thiz, string section, string key, int defaultValue);

		/// <summary>
		/// Retrieves a default configuration item as a 64 bit integer, given its section,
		/// key, and default value. 
		/// <para>
		/// The default integer value is returned if the config item isn't found. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the default value  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// 
		/// 
		/// <returns>the found default value or default_value if not found. </returns>
		public int GetDefaultInt64(string section, string key, int defaultValue)
		{
			int returnVal = linphone_config_get_default_int64(nativePtr, section, key, defaultValue);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_get_default_string(IntPtr thiz, string section, string key, string defaultValue);

		/// <summary>
		/// Retrieves a default configuration item as a string, given its section, key, and
		/// default value. 
		/// <para>
		/// The default value string is returned if the config item isn't found. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the default value  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// 
		/// 
		/// <returns>the found default value or default_value if not found. </returns>
		public string GetDefaultString(string section, string key, string defaultValue)
		{
			IntPtr stringPtr = linphone_config_get_default_string(nativePtr, section, key, defaultValue);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_config_get_float(IntPtr thiz, string section, string key, float defaultValue);

		/// <summary>
		/// Retrieves a configuration item as a float, given its section, key, and default
		/// value. 
		/// <para>
		/// The default float value is returned if the config item isn't found. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// 
		/// 
		/// <returns>the found value or default_value if not found. </returns>
		public float GetFloat(string section, string key, float defaultValue)
		{
			float returnVal = linphone_config_get_float(nativePtr, section, key, defaultValue);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_get_int(IntPtr thiz, string section, string key, int defaultValue);

		/// <summary>
		/// Retrieves a configuration item as an integer, given its section, key, and
		/// default value. 
		/// <para>
		/// The default integer value is returned if the config item isn't found. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// 
		/// 
		/// <returns>the found value or default_value if not found. </returns>
		public int GetInt(string section, string key, int defaultValue)
		{
			int returnVal = linphone_config_get_int(nativePtr, section, key, defaultValue);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_get_int64(IntPtr thiz, string section, string key, int defaultValue);

		/// <summary>
		/// Retrieves a configuration item as a 64 bit integer, given its section, key, and
		/// default value. 
		/// <para>
		/// The default integer value is returned if the config item isn't found. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// 
		/// 
		/// <returns>the found value or default_value if not found. </returns>
		public int GetInt64(string section, string key, int defaultValue)
		{
			int returnVal = linphone_config_get_int64(nativePtr, section, key, defaultValue);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_get_keys_names_list(IntPtr thiz, string section);

		/// <summary>
		/// Returns the list of keys' names for a section in the LinphoneConfig. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section name   </param>
		/// 
		/// 
		/// <returns>A list of char * objects. char *  a null terminated static array of
		/// strings   </returns>
		public IEnumerable<string> GetKeysNamesList(string section)
		{
			IEnumerable<string> returnVal = MarshalStringArray(linphone_config_get_keys_names_list(nativePtr, section));
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_get_overwrite_flag_for_entry(IntPtr thiz, string section, string key);

		/// <summary>
		/// Retrieves the overwrite flag for a config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the overwrite flag  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve the overwrite
		/// flag from.   </param>
		/// 
		/// 
		/// <returns>true if overwrite flag is set, false otherwise. </returns>
		public bool GetOverwriteFlagForEntry(string section, string key)
		{
			bool returnVal = linphone_config_get_overwrite_flag_for_entry(nativePtr, section, key) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_get_overwrite_flag_for_section(IntPtr thiz, string section);

		/// <summary>
		/// Retrieves the overwrite flag for a config section. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the overwrite flag  
		/// </param>
		/// 
		/// 
		/// <returns>true if overwrite flag is set, false otherwise. </returns>
		public bool GetOverwriteFlagForSection(string section)
		{
			bool returnVal = linphone_config_get_overwrite_flag_for_section(nativePtr, section) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_get_range(IntPtr thiz, string section, string key, int min, int max, int defaultMin, int defaultMax);

		/// <summary>
		/// Retrieves a configuration item as a range, given its section, key, and default
		/// min and max values. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="min">The min value found or default_min   </param>
		/// <param name="max">The max value found or default_max   </param>
		/// <param name="defaultMin">the default min value to return if not found </param>
		/// <param name="defaultMax">the default max value to return if not found. </param>
		/// 
		/// 
		/// <returns>true if the value is successfully parsed as a range, false otherwise.
		/// If false is returned, min and max are filled respectively with default_min and
		/// default_max values. </returns>
		public bool GetRange(string section, string key, int min, int max, int defaultMin, int defaultMax)
		{
			bool returnVal = linphone_config_get_range(nativePtr, section, key, min, max, defaultMin, defaultMax) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_get_section_param_string(IntPtr thiz, string section, string key, string defaultValue);

		/// <summary>
		/// Retrieves a section parameter item as a string, given its section and key. 
		/// <para>
		/// The default value string is returned if the config item isn't found. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the default value  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="defaultValue">The default value to return if not found.   </param>
		/// 
		/// 
		/// <returns>the found default value or default_value if not found.   </returns>
		public string GetSectionParamString(string section, string key, string defaultValue)
		{
			IntPtr stringPtr = linphone_config_get_section_param_string(nativePtr, section, key, defaultValue);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_get_skip_flag_for_entry(IntPtr thiz, string section, string key);

		/// <summary>
		/// Retrieves the skip flag for a config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the skip flag  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve the skip flag
		/// from </param>
		/// 
		/// 
		/// <returns>true if skip flag is set, false otherwise. </returns>
		public bool GetSkipFlagForEntry(string section, string key)
		{
			bool returnVal = linphone_config_get_skip_flag_for_entry(nativePtr, section, key) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_get_skip_flag_for_section(IntPtr thiz, string section);

		/// <summary>
		/// Retrieves the skip flag for a config section. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the skip flag  
		/// </param>
		/// 
		/// 
		/// <returns>true if skip flag is set, false otherwise. </returns>
		public bool GetSkipFlagForSection(string section)
		{
			bool returnVal = linphone_config_get_skip_flag_for_section(nativePtr, section) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_get_string(IntPtr thiz, string section, string key, string defaultString);

		/// <summary>
		/// Retrieves a configuration item as a string, given its section, key, and default
		/// value. 
		/// <para>
		/// The default value string is returned if the config item isn't found. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="defaultString">The default value to return if not found.   </param>
		/// 
		/// 
		/// <returns>the found value or the default one if not found.   </returns>
		public string GetString(string section, string key, string defaultString)
		{
			IntPtr stringPtr = linphone_config_get_string(nativePtr, section, key, defaultString);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_get_string_list(IntPtr thiz, string section, string key, IntPtr defaultList);

		/// <summary>
		/// Retrieves a configuration item as a list of strings, given its section, key,
		/// and default value. 
		/// <para>
		/// The default value is returned if the config item is not found. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="defaultList">A list of const char * objects. const char *   
		/// </param>
		/// 
		/// 
		/// <returns>A list of const char * objects. const char *    </returns>
		public IEnumerable<string> GetStringList(string section, string key, IEnumerable<string> defaultList)
		{
			IEnumerable<string> returnVal = MarshalStringArray(linphone_config_get_string_list(nativePtr, section, key, StringArrayToBctbxList(defaultList)));
			CleanStringArrayPtrs();
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_has_entry(IntPtr thiz, string section, string key);

		/// <summary>
		/// Returns if a given section with a given key is present in the configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">to check if the given entry exists   </param>
		/// <param name="key">to check if it exists   </param>
		/// 
		/// 
		/// <returns>1 if it exists, 0 otherwise </returns>
		public int HasEntry(string section, string key)
		{
			int returnVal = linphone_config_has_entry(nativePtr, section, key);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_has_section(IntPtr thiz, string section);

		/// <summary>
		/// Returns if a given section is present in the configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">the section to check if exists   </param>
		/// 
		/// 
		/// <returns>1 if it exists, 0 otherwise </returns>
		public int HasSection(string section)
		{
			int returnVal = linphone_config_has_section(nativePtr, section);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_load_from_xml_file(IntPtr thiz, string filename);

		/// <summary>
		/// Reads a xml config file and fill the <see cref="Linphone.Config" /> with the
		/// read config dynamic values. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filename">The filename of the config file to read to fill the <see
		/// cref="Linphone.Config" />   </param>
		/// 
		public string LoadFromXmlFile(string filename)
		{
			IntPtr stringPtr = linphone_config_load_from_xml_file(nativePtr, filename);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_load_from_xml_string(IntPtr thiz, string buffer);

		/// <summary>
		/// Reads a xml config string and fill the <see cref="Linphone.Config" /> with the
		/// read config dynamic values. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="buffer">The string of the config file to fill the <see
		/// cref="Linphone.Config" />   </param>
		/// 
		/// 
		/// <returns>0 in case of success </returns>
		public void LoadFromXmlString(string buffer)
		{
			int exception_result = linphone_config_load_from_xml_string(nativePtr, buffer);
			if (exception_result != 0) throw new LinphoneException("LoadFromXmlString returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_read_file(IntPtr thiz, string filename);

		/// <summary>
		/// Reads a user config file and fill the <see cref="Linphone.Config" /> with the
		/// read config values. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filename">The filename of the config file to read to fill the <see
		/// cref="Linphone.Config" />   </param>
		/// 
		public void ReadFile(string filename)
		{
			int exception_result = linphone_config_read_file(nativePtr, filename);
			if (exception_result != 0) throw new LinphoneException("ReadFile returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_relative_file_exists(IntPtr thiz, string filename);

		/// <summary>
		/// Check if given file name exists relatively to the current location. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filename">The file name to check if exists   </param>
		/// 
		/// 
		/// <returns>true if file exists relative to the to the current location </returns>
		public bool RelativeFileExists(string filename)
		{
			bool returnVal = linphone_config_relative_file_exists(nativePtr, filename) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_reload(IntPtr thiz);

		/// <summary>
		/// Reload the config from the file. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void Reload()
		{
			linphone_config_reload(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_bool(IntPtr thiz, string section, string key, char val);

		/// <summary>
		/// Sets a boolean config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="val">the value to set </param>
		/// 
		public void SetBool(string section, string key, bool val)
		{
			linphone_config_set_bool(nativePtr, section, key, val ? (char)1 : (char)0);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_float(IntPtr thiz, string section, string key, float val);

		/// <summary>
		/// Sets a float config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="val">the value to set </param>
		/// 
		public void SetFloat(string section, string key, float val)
		{
			linphone_config_set_float(nativePtr, section, key, val);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_int(IntPtr thiz, string section, string key, int val);

		/// <summary>
		/// Sets an integer config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="val">the value to set </param>
		/// 
		public void SetInt(string section, string key, int val)
		{
			linphone_config_set_int(nativePtr, section, key, val);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_int64(IntPtr thiz, string section, string key, int val);

		/// <summary>
		/// Sets a 64 bits integer config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="val">the value to set </param>
		/// 
		public void SetInt64(string section, string key, int val)
		{
			linphone_config_set_int64(nativePtr, section, key, val);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_int_hex(IntPtr thiz, string section, string key, int val);

		/// <summary>
		/// Sets an integer config item, but store it as hexadecimal. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="val">the value to set </param>
		/// 
		public void SetIntHex(string section, string key, int val)
		{
			linphone_config_set_int_hex(nativePtr, section, key, val);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_overwrite_flag_for_entry(IntPtr thiz, string section, string key, char val);

		/// <summary>
		/// Sets the overwrite flag for a config item (used when dumping config as xml) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to set the overwrite flag  
		/// </param>
		/// <param name="key">The name of the configuration item to set the overwrite flag
		/// from   </param>
		/// <param name="val">The overwrite flag value to set </param>
		/// 
		public void SetOverwriteFlagForEntry(string section, string key, bool val)
		{
			linphone_config_set_overwrite_flag_for_entry(nativePtr, section, key, val ? (char)1 : (char)0);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_overwrite_flag_for_section(IntPtr thiz, string section, char val);

		/// <summary>
		/// Sets the overwrite flag for a config section (used when dumping config as xml) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to set the overwrite flag  
		/// </param>
		/// <param name="val">The overwrite flag value to set </param>
		/// 
		public void SetOverwriteFlagForSection(string section, bool val)
		{
			linphone_config_set_overwrite_flag_for_section(nativePtr, section, val ? (char)1 : (char)0);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_range(IntPtr thiz, string section, string key, int minValue, int maxValue);

		/// <summary>
		/// Sets a range config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="minValue">the min value to set </param>
		/// <param name="maxValue">the max value to set </param>
		/// 
		public void SetRange(string section, string key, int minValue, int maxValue)
		{
			linphone_config_set_range(nativePtr, section, key, minValue, maxValue);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_skip_flag_for_entry(IntPtr thiz, string section, string key, char val);

		/// <summary>
		/// Sets the skip flag for a config item (used when dumping config as xml) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to set the skip flag   </param>
		/// <param name="key">The name of the configuration item to set the skip flag from 
		///  </param>
		/// <param name="val">The skip flag value to set </param>
		/// 
		public void SetSkipFlagForEntry(string section, string key, bool val)
		{
			linphone_config_set_skip_flag_for_entry(nativePtr, section, key, val ? (char)1 : (char)0);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_skip_flag_for_section(IntPtr thiz, string section, char val);

		/// <summary>
		/// Sets the skip flag for a config section (used when dumping config as xml) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to set the skip flag   </param>
		/// <param name="val">The skip flag value to set </param>
		/// 
		public void SetSkipFlagForSection(string section, bool val)
		{
			linphone_config_set_skip_flag_for_section(nativePtr, section, val ? (char)1 : (char)0);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_string(IntPtr thiz, string section, string key, string val);

		/// <summary>
		/// Sets a string config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve   </param>
		/// <param name="val">The value to set   </param>
		/// 
		public void SetString(string section, string key, string val)
		{
			linphone_config_set_string(nativePtr, section, key, val);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_string_list(IntPtr thiz, string section, string key, IntPtr val);

		/// <summary>
		/// Sets a string list config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The name of the section to put the configuration item
		/// into   </param>
		/// <param name="key">The name of the configuration item to set   </param>
		/// <param name="val">A list of const char * objects. const char *  The value to
		/// set.   </param>
		/// 
		public void SetStringList(string section, string key, IEnumerable<string> val)
		{
			linphone_config_set_string_list(nativePtr, section, key, StringArrayToBctbxList(val));
			
			CleanStringArrayPtrs();
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_sync(IntPtr thiz);

		/// <summary>
		/// Writes the config file to disk. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, -1 otherwise </returns>
		public void Sync()
		{
			int exception_result = linphone_config_sync(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Sync returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_write_relative_file(IntPtr thiz, string filename, string data);

		/// <summary>
		/// Write a string in a file placed relatively with the Linphone configuration
		/// file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filename">Name of the file where to write data. The name is
		/// relative to the place of the config file   </param>
		/// <param name="data">String to write   </param>
		/// 
		public void WriteRelativeFile(string filename, string data)
		{
			linphone_config_write_relative_file(nativePtr, filename, data);
			
			
			
		}
	}
	/// <summary>
	/// This object holds data that can be embedded in a signaling message. 
	/// <para>
	/// Use <see cref="Linphone.Core.CreateContent()" /> to create it, and then you
	/// should set at least it's type and subtype and fill the buffer with your data.
	/// 
	/// A <see cref="Linphone.Content" /> can be multipart (contain other contents),
	/// have file information (name, path, size), be encrypted, have custom headers,
	/// etc...
	/// 
	/// It is mainly used to send information through a <see
	/// cref="Linphone.ChatMessage" />. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Content : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_content_get_buffer(IntPtr thiz);

		/// <summary>
		/// Get the content data buffer, usually a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The content data buffer.   </returns>
		public uint Buffer
		{
			get
			{
				return linphone_content_get_buffer(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_encoding(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_encoding(IntPtr thiz, string encoding);

		/// <summary>
		/// Get the encoding of the data buffer, for example "gzip". 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The encoding of the data buffer.   </returns>
		public string Encoding
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_encoding(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_encoding(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_file_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_file_path(IntPtr thiz, string filePath);

		/// <summary>
		/// Get the file transfer filepath set for this content (replace
		/// linphone_chat_message_get_file_transfer_filepath). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The file path set for this content if it has been set, null otherwise.
		///   </returns>
		public string FilePath
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_file_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_file_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_content_get_file_size(IntPtr thiz);

		/// <summary>
		/// Get the file size if content is either a FileContent or a FileTransferContent. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The represented file size. </returns>
		public long FileSize
		{
			get
			{
				return linphone_content_get_file_size(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_content_is_file(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this content contains a file. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if this content contains a file, false otherwise. </returns>
		public bool IsFile
		{
			get
			{
				return linphone_content_is_file(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_content_is_file_encrypted(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this content contains an encrypted file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>True is this content contains a file and this file is encrypted, false
		/// otherwise. </returns>
		public bool IsFileEncrypted
		{
			get
			{
				return linphone_content_is_file_encrypted(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_content_is_file_transfer(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this content is a file transfer. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if this content is a file transfer, false otherwise. </returns>
		public bool IsFileTransfer
		{
			get
			{
				return linphone_content_is_file_transfer(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_content_is_multipart(IntPtr thiz);

		/// <summary>
		/// Tell whether a content is a multipart content. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether the content is multipart or not.
		/// </returns>
		public bool IsMultipart
		{
			get
			{
				return linphone_content_is_multipart(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_content_is_text(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this content contains text. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if this content contains plain text, false otherwise. </returns>
		public bool IsText
		{
			get
			{
				return linphone_content_is_text(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_key(IntPtr thiz);

		/// <summary>
		/// Get the key associated with a RCS file transfer message if encrypted. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The key to encrypt/decrypt the file associated to this content.  
		/// </returns>
		public string Key
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_content_get_key_size(IntPtr thiz);

		/// <summary>
		/// Get the size of key associated with a RCS file transfer message if encrypted. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The key size in bytes </returns>
		public long KeySize
		{
			get
			{
				return linphone_content_get_key_size(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_name(IntPtr thiz, string name);

		/// <summary>
		/// Get the name associated with a RCS file transfer message. 
		/// <para>
		/// It is used to store the original filename of the file to be downloaded from
		/// server. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The name of the content.   </returns>
		public string Name
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_parts(IntPtr thiz);

		/// <summary>
		/// Get all the parts from a multipart content. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A A list of <see cref="Linphone.Content" /> objects. LinphoneContent 
		/// object holding the part if found, null otherwise.     </returns>
		public IEnumerable<Linphone.Content> Parts
		{
			get
			{
				return MarshalBctbxList<Linphone.Content>(linphone_content_get_parts(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_plain_file_path(IntPtr thiz);

		/// <summary>
		/// If the content is an encrypted file, generate a temporary plain copy of the
		/// file and returns its paths The caller is responsible to then delete this
		/// temporary copy and the returned string. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The file path set for this content if it has been set, null otherwise.
		/// </returns>
		public string PlainFilePath
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_plain_file_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_content_get_size(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_size(IntPtr thiz, long size);

		/// <summary>
		/// Get the content data buffer size, excluding null character despite null
		/// character is always set for convenience. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The content data buffer size. </returns>
		public long Size
		{
			get
			{
				return linphone_content_get_size(nativePtr);
			}
			set
			{
				linphone_content_set_size(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_string_buffer(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_string_buffer(IntPtr thiz, string buffer);

		/// <summary>
		/// Get the string content data buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The string content data buffer.   </returns>
		/// 
		/// deprecated : 2020-07-01. Use <see cref="Linphone.Content.GetUtf8Text()" />
		/// instead. 
		public string StringBuffer
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_string_buffer(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_string_buffer(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_subtype(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_subtype(IntPtr thiz, string subtype);

		/// <summary>
		/// Get the mime subtype of the content data. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The mime subtype of the content data, for example "html".   </returns>
		public string Subtype
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_subtype(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_subtype(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_type(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_type(IntPtr thiz, string type);

		/// <summary>
		/// Get the mime type of the content data. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The mime type of the content data, for example "application".  
		/// </returns>
		public string Type
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_type(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_type(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_utf8_text(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_utf8_text(IntPtr thiz, string buffer);

		/// <summary>
		/// Get the string content data buffer. 
		/// <para>
		/// Introduced in 01/07/2020 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The string content data buffer in UTF8.   </returns>
		public string Utf8Text
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_utf8_text(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_utf8_text(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_add_content_type_parameter(IntPtr thiz, string name, string val);

		/// <summary>
		/// Adds a parameter to the ContentType header. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the name of the parameter to add.   </param>
		/// <param name="val">the value of the parameter to add.   </param>
		/// 
		public void AddContentTypeParameter(string name, string val)
		{
			linphone_content_add_content_type_parameter(nativePtr, name, val);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_find_part_by_header(IntPtr thiz, string headerName, string headerValue);

		/// <summary>
		/// Find a part from a multipart content looking for a part header with a specified
		/// value. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">The name of the header to look for.   </param>
		/// <param name="headerValue">The value of the header to look for.   </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Content" /> object object the part if found,
		/// null otherwise.   </returns>
		public Linphone.Content FindPartByHeader(string headerName, string headerValue)
		{
			IntPtr ptr = linphone_content_find_part_by_header(nativePtr, headerName, headerValue);
			Linphone.Content returnVal = fromNativePtr<Linphone.Content>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_custom_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Get a custom header value of a content. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">The name of the header to get the value from.  
		/// </param>
		/// 
		/// 
		/// <returns>The value of the header if found, null otherwise.   </returns>
		public string GetCustomHeader(string headerName)
		{
			IntPtr stringPtr = linphone_content_get_custom_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_part(IntPtr thiz, int index);

		/// <summary>
		/// Get a part from a multipart content according to its index. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the part to get. </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Content" /> object holding the part if found,
		/// null otherwise.   </returns>
		public Linphone.Content GetPart(int index)
		{
			IntPtr ptr = linphone_content_get_part(nativePtr, index);
			Linphone.Content returnVal = fromNativePtr<Linphone.Content>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_buffer(IntPtr thiz, uint buffer, long size);

		/// <summary>
		/// Set the content data buffer, usually a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="buffer">The content data buffer.   </param>
		/// <param name="size">The size of the content data buffer. </param>
		/// 
		public void SetBuffer(uint buffer, long size)
		{
			linphone_content_set_buffer(nativePtr, buffer, size);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_key(IntPtr thiz, string key, long keyLength);

		/// <summary>
		/// Set the key associated with a RCS file transfer message if encrypted. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key to be used to encrypt/decrypt file associated to this
		/// content.   </param>
		/// <param name="keyLength">The lengh of the key. </param>
		/// 
		public void SetKey(string key, long keyLength)
		{
			linphone_content_set_key(nativePtr, key, keyLength);
			
			
			
		}
	}
	/// <summary>
	/// Main object to instanciate and on which to keep a reference. 
	/// <para>
	/// This object is the first object to instanciante, and will allow you to perform
	/// all kind of tasks. To create it, use either <see
	/// cref="Linphone.Factory.CreateCore()" /> or <see
	/// cref="Linphone.Factory.CreateCoreWithConfig()" />, see <see
	/// cref="Linphone.Config" /> for more information about factory and default
	/// config. On some platforms like Android or iOS you will need to give it the
	/// Context of your application.
	/// 
	/// Once the <see cref="Linphone.Core" /> is in state LinphoneGlobalReady, use <see
	/// cref="Linphone.Core.Start()" />. It will then go to state LinphoneGlobalOn and
	/// from that you can start using it for calls and chat messages. It is recommended
	/// to add a LinphoneCoreCbs listener using linphone_core_add_listener to it to
	/// monitor different events.
	/// 
	/// To be able to receive events from the network, you must schedule a call <see
	/// cref="Linphone.Core.Iterate()" /> often, like every 20ms. On Android & iOS <see
	/// cref="Linphone.Core.IsAutoIterateEnabled()" /> is enabled by default so you
	/// don't have to worry about that unless you disable it using <see
	/// cref="Linphone.Core.SetAutoIterateEnabled()" /> or by setting in the [misc]
	/// section of your configuration auto_iterate=0. </para>
	/// </summary>
	/// <remarks>Warning : Our API isn't thread-safe but also isn't blocking, so it is
	/// strongly recommend to always call our methods from the main thread.</remarks> 
	/// 
	/// Once you don't need it anymore, call <see cref="Linphone.Core.Stop()" /> and
	/// release the reference on it so it can gracefully shutdown. 
	[StructLayout(LayoutKind.Sequential)]
	public class Core : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_ms_factory(IntPtr thiz);

		public MediastreamerFactory MsFactory {
			get
			{
				IntPtr ptr = linphone_core_get_ms_factory(nativePtr);
				MediastreamerFactory factory = new MediastreamerFactory();
				factory.nativePtr = ptr;
				return factory;
			}
		}

		/// Get the native window handle of the video window.
		public string NativeVideoWindowIdString
		{
			get
			{
				return Marshal.PtrToStringUni(linphone_core_get_native_video_window_id(nativePtr));
			}
			set
			{
				IntPtr string_ptr_to_remove = linphone_core_get_native_video_window_id(nativePtr);
				IntPtr string_ptr = Marshal.StringToHGlobalUni(value);
				linphone_core_set_native_video_window_id(nativePtr, string_ptr);
				if(string_ptr_to_remove != IntPtr.Zero)
					Marshal.FreeHGlobal(string_ptr_to_remove);
			}
		}

		/// Get the native window handle of the video preview window.
		public string NativePreviewWindowIdString
		{
			get
			{
				return Marshal.PtrToStringUni(linphone_core_get_native_preview_window_id(nativePtr));
			}
			set
			{
				IntPtr string_ptr_to_remove = linphone_core_get_native_preview_window_id(nativePtr);
				IntPtr string_ptr = Marshal.StringToHGlobalUni(value);
				linphone_core_set_native_preview_window_id(nativePtr, string_ptr);
				if(string_ptr_to_remove != IntPtr.Zero)
					Marshal.FreeHGlobal(string_ptr_to_remove);
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct MSOglContextInfo
		{
			public System.IntPtr window;
			public System.UInt32 width;
			public System.UInt32 height;
			public System.IntPtr getProcAddress;
		};

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_native_video_window_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_native_video_window_id(IntPtr thiz, IntPtr windowId);

		/// <summary>
		/// Get the native window handle of the video window. On Windows UWP/WindowsStore, this is a SwapChainPanel. eg: LinphoneManager.Instance.Core.NativeVideoWindowId = panel; The rendering is automatically done by Linphone.
		/// </summary>
#if WINDOWS_UWP
		public Windows.UI.Xaml.Controls.SwapChainPanel NativeVideoWindowId
		{
			get
			{
				return (Windows.UI.Xaml.Controls.SwapChainPanel)Marshal.GetObjectForIUnknown(((MSOglContextInfo)Marshal.PtrToStructure<MSOglContextInfo>(linphone_core_get_native_video_window_id(nativePtr)) ).window);
			}
			set
			{
				MSOglContextInfo c;
				if (value != null)
					c.window = Marshal.GetIUnknownForObject(value);
				else
					c.window = IntPtr.Zero;
				c.getProcAddress = IntPtr.Zero;
				c.width = 0;
				c.height = 0;
				IntPtr pnt = Marshal.AllocHGlobal(Marshal.SizeOf(c));
				Marshal.StructureToPtr(c, pnt, false);
				IntPtr oldData = linphone_core_get_native_video_window_id(nativePtr);
				linphone_core_set_native_video_window_id(nativePtr, pnt);
				if (oldData != IntPtr.Zero){
					IntPtr window = ((MSOglContextInfo)Marshal.PtrToStructure<MSOglContextInfo>(oldData) ).window;
					if(window != IntPtr.Zero)
						Marshal.Release( window );
					Marshal.FreeHGlobal(oldData);
				}
			}
		}
#else
		public IntPtr NativeVideoWindowId
		{
			get
			{
				return linphone_core_get_native_video_window_id(nativePtr);
			}
			set
			{
				linphone_core_set_native_video_window_id(nativePtr, value);
			}
		}
#endif
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_native_preview_window_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_native_preview_window_id(IntPtr thiz, IntPtr windowId);

		/// <summary>
		/// Get the native window handle of the video preview window. On Windows UWP/WindowsStore, this is a SwapChainPanel. eg: LinphoneManager.Instance.Core.NativePreviewWindowId = panel; The rendering is automatically done by Linphone.
		/// </summary>
		///
#if WINDOWS_UWP
		public Windows.UI.Xaml.Controls.SwapChainPanel NativePreviewWindowId
		{
			get
			{
				return(Windows.UI.Xaml.Controls.SwapChainPanel) Marshal.GetObjectForIUnknown(((MSOglContextInfo)Marshal.PtrToStructure<MSOglContextInfo>(linphone_core_get_native_preview_window_id(nativePtr)) ).window);
			}
			set
			{
				MSOglContextInfo c;
				if (value != null)
					c.window = Marshal.GetIUnknownForObject(value);
				else
					c.window = IntPtr.Zero;
				c.getProcAddress = IntPtr.Zero;
				c.width = 0;
				c.height = 0;
				IntPtr pnt = Marshal.AllocHGlobal(Marshal.SizeOf(c));
				Marshal.StructureToPtr(c, pnt, false);
				IntPtr oldData = linphone_core_get_native_preview_window_id(nativePtr);
				linphone_core_set_native_preview_window_id(nativePtr, pnt);
				if (oldData != IntPtr.Zero){
					IntPtr window = ((MSOglContextInfo)Marshal.PtrToStructure<MSOglContextInfo>(oldData) ).window;
					if(window != IntPtr.Zero)
						Marshal.Release( window );
					Marshal.FreeHGlobal(oldData);
				}
			}
		}
#else
		public IntPtr NativePreviewWindowId
		{
			get
			{
				return linphone_core_get_native_preview_window_id(nativePtr);
			}
			set
			{
				linphone_core_set_native_preview_window_id(nativePtr, value);
			}
		}
#endif


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_core_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_remove_callbacks(IntPtr thiz, IntPtr cbs);

		~Core() 
		{
			if (listener != null)
			{
				linphone_core_remove_callbacks(nativePtr, listener.nativePtr);
			}
		}

		private CoreListener listener;

		public CoreListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_core_cbs(linphone_factory_get());
					listener = fromNativePtr<CoreListener>(nativeListener, false);
					linphone_core_add_callbacks(nativePtr, nativeListener);
					listener.register();
				}
				return listener;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_compress_log_collection();

		/// <summary>
		/// Compress the log collection in a single file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path of the compressed log collection file (to be freed calling
		/// ms_free()).   </returns>
		public static string CompressLogCollection()
		{
			IntPtr stringPtr = linphone_core_compress_log_collection();
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_log_collection(int state);

		/// <summary>
		/// Enable the linphone core log collection to upload logs on a server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="state">LinphoneLogCollectionState value telling whether to enable
		/// log collection or not. </param>
		/// 
		public static void EnableLogCollection(Linphone.LogCollectionState state)
		{
			linphone_core_enable_log_collection((int)state);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_core_get_log_collection_max_file_size();

		/// <summary>
		/// Get the max file size in bytes of the files used for log collection. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The max file size in bytes of the files used for log collection.  
		/// </returns>
		static public long LogCollectionMaxFileSize
		{
			get
			{
				return linphone_core_get_log_collection_max_file_size();
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_log_collection_path();

		/// <summary>
		/// Get the path where the log files will be written for log collection. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path where the log files will be written.   </returns>
		static public string LogCollectionPath
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_log_collection_path();
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_log_collection_prefix();

		/// <summary>
		/// Get the prefix of the filenames that will be used for log collection. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The prefix of the filenames used for log collection.   </returns>
		static public string LogCollectionPrefix
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_log_collection_prefix();
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_version();

		/// <summary>
		/// Returns liblinphone's version as a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the current version of the <see cref="Linphone.Core" />   </returns>
		static public string Version
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_version();
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.LogCollectionState linphone_core_log_collection_enabled();

		/// <summary>
		/// Tells whether the linphone core log collection is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The LinphoneLogCollectionState of the <see cref="Linphone.Core" /> log
		/// collection. </returns>
		public static Linphone.LogCollectionState LogCollectionEnabled()
		{
			Linphone.LogCollectionState returnVal = linphone_core_log_collection_enabled();
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reset_log_collection();

		/// <summary>
		/// Reset the log collection by removing the log files. 
		/// <para>
		/// </para>
		/// </summary>
		public static void ResetLogCollection()
		{
			linphone_core_reset_log_collection();
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_serialize_logs();

		/// <summary>
		/// Enable logs serialization (output logs from either the thread that creates the
		/// linphone core or the thread that calls <see cref="Linphone.Core.Iterate()" />). 
		/// <para>
		/// Must be called before creating the linphone core. 
		/// </para>
		/// </summary>
		public static void SerializeLogs()
		{
			linphone_core_serialize_logs();
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_log_collection_max_file_size(long size);

		/// <summary>
		/// Set the max file size in bytes of the files used for log collection. 
		/// <para>
		/// Warning: this function should only not be used to change size dynamically but
		/// instead only before calling </para>
		/// </summary>
		/// <remarks>See : linphone_core_enable_log_collection. If you increase max size on
		/// runtime, logs chronological order COULD be broken. </remarks>
		/// 
		/// <param name="size">The max file size in bytes of the files used for log
		/// collection. </param>
		/// 
		public static void SetLogCollectionMaxFileSize(long size)
		{
			linphone_core_set_log_collection_max_file_size(size);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_log_collection_path(string path);

		/// <summary>
		/// Set the path of a directory where the log files will be written for log
		/// collection. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="path">The path where the log files will be written.   </param>
		/// 
		public static void SetLogCollectionPath(string path)
		{
			linphone_core_set_log_collection_path(path);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_log_collection_prefix(string prefix);

		/// <summary>
		/// Set the prefix of the filenames that will be used for log collection. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="prefix">The prefix to use for the filenames for log collection.  
		/// </param>
		/// 
		public static void SetLogCollectionPrefix(string prefix)
		{
			linphone_core_set_log_collection_prefix(prefix);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_tunnel_available();

		/// <summary>
		/// True if tunnel support was compiled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if library was built with tunnel, false otherwise </returns>
		public static bool TunnelAvailable()
		{
			bool returnVal = linphone_core_tunnel_available() == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_upnp_available();

		/// <summary>
		/// Return the availability of uPnP. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if uPnP is available otherwise return false. </returns>
		public static bool UpnpAvailable()
		{
			bool returnVal = linphone_core_upnp_available() == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_vcard_supported();

		/// <summary>
		/// Tells whether VCARD support is builtin. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if VCARD is supported, false otherwise. </returns>
		public static bool VcardSupported()
		{
			bool returnVal = linphone_core_vcard_supported() == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_adaptive_rate_algorithm(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_adaptive_rate_algorithm(IntPtr thiz, string algorithm);

		/// <summary>
		/// Returns which adaptive rate algorithm is currently configured for future calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.Core.SetAdaptiveRateAlgorithm()" />
		/// </remarks>
		/// 
		/// <returns>the adaptive rate algorithm. Currently two values are supported:
		/// 'advanced', which is the default value, or 'basic'.   </returns>
		public string AdaptiveRateAlgorithm
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_adaptive_rate_algorithm(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_adaptive_rate_algorithm(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_adaptive_rate_control_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_adaptive_rate_control(IntPtr thiz, char enabled);

		/// <summary>
		/// Returns whether adaptive rate control is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.Core.EnableAdaptiveRateControl()"
		/// /></remarks>
		/// 
		/// <returns>true if adaptive rate control is enabled, false otherwise </returns>
		public bool AdaptiveRateControlEnabled
		{
			get
			{
				return linphone_core_adaptive_rate_control_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_adaptive_rate_control(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_audio_adaptive_jittcomp_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_audio_adaptive_jittcomp(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether the audio adaptive jitter compensation is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the audio adaptive jitter compensation is enabled, false
		/// otherwise. </returns>
		public bool AudioAdaptiveJittcompEnabled
		{
			get
			{
				return linphone_core_audio_adaptive_jittcomp_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_audio_adaptive_jittcomp(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_audio_devices(IntPtr thiz);

		/// <summary>
		/// Returns a list of audio devices, with only the first device for each type To
		/// have the list of all audio devices, use
		/// linphone_core_get_extended_audio_devices. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.AudioDevice" /> objects.
		/// LinphoneAudioDevice  A list with the first <see cref="Linphone.AudioDevice" />
		/// of each type   </returns>
		public IEnumerable<Linphone.AudioDevice> AudioDevices
		{
			get
			{
				return MarshalBctbxList<Linphone.AudioDevice>(linphone_core_get_audio_devices(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_audio_dscp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_audio_dscp(IntPtr thiz, int dscp);

		/// <summary>
		/// Get the DSCP field for outgoing audio streams. 
		/// <para>
		/// The DSCP defines the quality of service in IP packets. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current DSCP value </returns>
		public int AudioDscp
		{
			get
			{
				return linphone_core_get_audio_dscp(nativePtr);
			}
			set
			{
				linphone_core_set_audio_dscp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_audio_jittcomp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_audio_jittcomp(IntPtr thiz, int milliseconds);

		/// <summary>
		/// Returns the nominal audio jitter buffer size in milliseconds. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The nominal audio jitter buffer size in milliseconds </returns>
		public int AudioJittcomp
		{
			get
			{
				return linphone_core_get_audio_jittcomp(nativePtr);
			}
			set
			{
				linphone_core_set_audio_jittcomp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_audio_multicast_addr(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_audio_multicast_addr(IntPtr thiz, string ip);

		/// <summary>
		/// Use to get multicast address to be used for audio stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>an ipv4/6 multicast address or default value.   </returns>
		public string AudioMulticastAddr
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_audio_multicast_addr(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_audio_multicast_addr(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("AudioMulticastAddr setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_audio_multicast_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_audio_multicast(IntPtr thiz, char yesno);

		/// <summary>
		/// Use to get multicast state of audio stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if subsequent calls will propose multicast ip set by
		/// linphone_core_set_audio_multicast_addr </returns>
		public bool AudioMulticastEnabled
		{
			get
			{
				return linphone_core_audio_multicast_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_audio_multicast(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_audio_multicast_ttl(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_audio_multicast_ttl(IntPtr thiz, int ttl);

		/// <summary>
		/// Use to get multicast ttl to be used for audio stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a time to leave value </returns>
		public int AudioMulticastTtl
		{
			get
			{
				return linphone_core_get_audio_multicast_ttl(nativePtr);
			}
			set
			{
				int exception_result = linphone_core_set_audio_multicast_ttl(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("AudioMulticastTtl setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_audio_payload_types(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_audio_payload_types(IntPtr thiz, IntPtr payloadTypes);

		/// <summary>
		/// Return the list of the available audio payload types. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.PayloadType" /> objects.
		/// LinphonePayloadType  A freshly allocated list of the available payload types.
		/// The list must be destroyed with bctbx_list_free() after usage. The elements of
		/// the list haven't to be unref.   </returns>
		public IEnumerable<Linphone.PayloadType> AudioPayloadTypes
		{
			get
			{
				return MarshalBctbxList<Linphone.PayloadType>(linphone_core_get_audio_payload_types(nativePtr), true);
			}
			set
			{
				linphone_core_set_audio_payload_types(nativePtr, ObjectArrayToBctbxList<Linphone.PayloadType>(value));
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_audio_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_audio_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the UDP port used for audio streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The UDP port used for audio streaming </returns>
		public int AudioPort
		{
			get
			{
				return linphone_core_get_audio_port(nativePtr);
			}
			set
			{
				linphone_core_set_audio_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_audio_ports_range(IntPtr thiz);

		/// <summary>
		/// Get the audio port range from which is randomly chosen the UDP port used for
		/// audio streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Range" /> object     </returns>
		public Linphone.Range AudioPortsRange
		{
			get
			{
				IntPtr ptr = linphone_core_get_audio_ports_range(nativePtr);
				Linphone.Range obj = fromNativePtr<Linphone.Range>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_auth_info_list(IntPtr thiz);

		/// <summary>
		/// Returns an unmodifiable list of currently entered <see cref="Linphone.AuthInfo"
		/// />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.AuthInfo" /> objects. LinphoneAuthInfo  
		///  </returns>
		public IEnumerable<Linphone.AuthInfo> AuthInfoList
		{
			get
			{
				return MarshalBctbxList<Linphone.AuthInfo>(linphone_core_get_auth_info_list(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_auto_iterate_enabled(IntPtr thiz, char enable);

		/// <summary>
		/// Enable or disable the automatic schedule of <see cref="Linphone.Core.Iterate()"
		/// /> method on Android & iOS. 
		/// <para>
		/// If enabled, <see cref="Linphone.Core.Iterate()" /> will be called on the main
		/// thread every 20ms automatically. If disabled, it is the application that must
		/// do this job. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="enable">true to enable auto iterate, false to disable </param>
		/// 
		public bool AutoIterateEnabled
		{
			set
			{
				linphone_core_set_auto_iterate_enabled(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AVPFMode linphone_core_get_avpf_mode(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_avpf_mode(IntPtr thiz, int mode);

		/// <summary>
		/// Return AVPF enablement. 
		/// <para>
		/// See <see cref="Linphone.Core.SetAvpfMode()" /> . 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current LinphoneAVPFMode mode </returns>
		public Linphone.AVPFMode AvpfMode
		{
			get
			{
				return linphone_core_get_avpf_mode(nativePtr);
			}
			set
			{
				linphone_core_set_avpf_mode(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_avpf_rr_interval(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_avpf_rr_interval(IntPtr thiz, int interval);

		/// <summary>
		/// Return the avpf report interval in seconds. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current AVPF report interval in seconds </returns>
		public int AvpfRrInterval
		{
			get
			{
				return linphone_core_get_avpf_rr_interval(nativePtr);
			}
			set
			{
				linphone_core_set_avpf_rr_interval(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_logs(IntPtr thiz);

		/// <summary>
		/// Get the list of call logs (past calls). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.CallLog" /> objects. LinphoneCallLog   
		/// </returns>
		public IEnumerable<Linphone.CallLog> CallLogs
		{
			get
			{
				return MarshalBctbxList<Linphone.CallLog>(linphone_core_get_call_logs(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_logs_database_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_call_logs_database_path(IntPtr thiz, string path);

		/// <summary>
		/// Gets the database filename where call logs will be stored. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>filesystem path.   </returns>
		public string CallLogsDatabasePath
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_call_logs_database_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_call_logs_database_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_callkit_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_callkit(IntPtr thiz, char enabled);

		/// <summary>
		/// Special function to check if the callkit is enabled, False by default. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if callkit is enabled, false otherwise. </returns>
		public bool CallkitEnabled
		{
			get
			{
				return linphone_core_callkit_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_callkit(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_calls(IntPtr thiz);

		/// <summary>
		/// Gets the current list of calls. 
		/// <para>
		/// Note that this list is read-only and might be changed by the core after a
		/// function call to <see cref="Linphone.Core.Iterate()" />. Similarly the <see
		/// cref="Linphone.Call" /> objects inside it might be destroyed without prior
		/// notice. To hold references to <see cref="Linphone.Call" /> object into your
		/// program, you must use linphone_call_ref. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Call" /> objects. LinphoneCall   
		/// </returns>
		public IEnumerable<Linphone.Call> Calls
		{
			get
			{
				return MarshalBctbxList<Linphone.Call>(linphone_core_get_calls(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_calls_nb(IntPtr thiz);

		/// <summary>
		/// Get the number of Call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current number of calls </returns>
		public int CallsNb
		{
			get
			{
				return linphone_core_get_calls_nb(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_camera_sensor_rotation(IntPtr thiz);

		/// <summary>
		/// Get the camera sensor rotation. 
		/// <para>
		/// This is needed on some mobile platforms to get the number of degrees the camera
		/// sensor is rotated relative to the screen. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The camera sensor rotation in degrees (0 to 360) or -1 if it could not
		/// be retrieved </returns>
		public int CameraSensorRotation
		{
			get
			{
				return linphone_core_get_camera_sensor_rotation(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_capture_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_capture_device(IntPtr thiz, string devid);

		/// <summary>
		/// Gets the name of the currently assigned sound device for capture. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The name of the currently assigned sound device for capture.  
		/// </returns>
		public string CaptureDevice
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_capture_device(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_capture_device(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("CaptureDevice setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_chat_enabled(IntPtr thiz);

		/// <summary>
		/// Returns whether chat is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if chat is enabled, false otherwise </returns>
		public bool ChatEnabled
		{
			get
			{
				return linphone_core_chat_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_chat_rooms(IntPtr thiz);

		/// <summary>
		/// Returns an list of chat rooms. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.ChatRoom" /> objects. LinphoneChatRoom  
		///  </returns>
		public IEnumerable<Linphone.ChatRoom> ChatRooms
		{
			get
			{
				return MarshalBctbxList<Linphone.ChatRoom>(linphone_core_get_chat_rooms(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_conference(IntPtr thiz);

		/// <summary>
		/// Get a pointer on the internal conference object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A pointer on <see cref="Linphone.Conference" /> or null if no
		/// conference are going on.   </returns>
		public Linphone.Conference Conference
		{
			get
			{
				IntPtr ptr = linphone_core_get_conference(nativePtr);
				Linphone.Conference obj = fromNativePtr<Linphone.Conference>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_core_get_conference_local_input_volume(IntPtr thiz);

		/// <summary>
		/// Get the set input volume of the local participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A value inside [0.0 ; 1.0] </returns>
		public float ConferenceLocalInputVolume
		{
			get
			{
				return linphone_core_get_conference_local_input_volume(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_conference_server_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_conference_server(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether the conference server feature is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether the conference server feature is
		/// enabled or not </returns>
		public bool ConferenceServerEnabled
		{
			get
			{
				return linphone_core_conference_server_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_conference_server(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_conference_size(IntPtr thiz);

		/// <summary>
		/// Get the number of participant in the running conference. 
		/// <para>
		/// The local participant is included in the count only if it is in the conference. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The number of participant </returns>
		public int ConferenceSize
		{
			get
			{
				return linphone_core_get_conference_size(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_config(IntPtr thiz);

		/// <summary>
		/// Returns the config object used to manage the storage (config) file. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Config" /> object.   </returns>
		public Linphone.Config Config
		{
			get
			{
				IntPtr ptr = linphone_core_get_config(nativePtr);
				Linphone.Config obj = fromNativePtr<Linphone.Config>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConsolidatedPresence linphone_core_get_consolidated_presence(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_consolidated_presence(IntPtr thiz, int presence);

		/// <summary>
		/// Get my consolidated presence. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>My LinphoneConsolidatedPresence presence </returns>
		public Linphone.ConsolidatedPresence ConsolidatedPresence
		{
			get
			{
				return linphone_core_get_consolidated_presence(nativePtr);
			}
			set
			{
				linphone_core_set_consolidated_presence(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_current_call(IntPtr thiz);

		/// <summary>
		/// Gets the current call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current call or null if no call is running.   </returns>
		public Linphone.Call CurrentCall
		{
			get
			{
				IntPtr ptr = linphone_core_get_current_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_current_call_remote_address(IntPtr thiz);

		/// <summary>
		/// Get the remote address of the current call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The remote address of the current call or null if there is no current
		/// call.   </returns>
		public Linphone.Address CurrentCallRemoteAddress
		{
			get
			{
				IntPtr ptr = linphone_core_get_current_call_remote_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_current_callbacks(IntPtr thiz);

		/// <summary>
		/// Gets the current LinphoneCoreCbs. 
		/// <para>
		/// This is meant only to be called from a callback to be able to get the user_data
		/// associated with the LinphoneCoreCbs that is calling the callback. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the LinphoneCoreCbs that has called the last callback   </returns>
		public Linphone.CoreListener CurrentCallbacks
		{
			get
			{
				IntPtr ptr = linphone_core_get_current_callbacks(nativePtr);
				Linphone.CoreListener obj = fromNativePtr<Linphone.CoreListener>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_current_preview_video_definition(IntPtr thiz);

		/// <summary>
		/// Get the effective video definition provided by the camera for the captured
		/// video. 
		/// <para>
		/// When preview is disabled or not yet started this function returns a 0x0 video
		/// definition. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The captured <see cref="Linphone.VideoDefinition" />.  </returns>
		/// 
		/// <remarks>See : <see cref="Linphone.Core.SetPreviewVideoDefinition()" />
		/// </remarks>
		public Linphone.VideoDefinition CurrentPreviewVideoDefinition
		{
			get
			{
				IntPtr ptr = linphone_core_get_current_preview_video_definition(nativePtr);
				Linphone.VideoDefinition obj = fromNativePtr<Linphone.VideoDefinition>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_default_friend_list(IntPtr thiz);

		/// <summary>
		/// Retrieves the first list of <see cref="Linphone.Friend" /> from the core. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the first <see cref="Linphone.FriendList" /> object or null.  
		/// </returns>
		public Linphone.FriendList DefaultFriendList
		{
			get
			{
				IntPtr ptr = linphone_core_get_default_friend_list(nativePtr);
				Linphone.FriendList obj = fromNativePtr<Linphone.FriendList>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_default_input_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_default_input_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the default input audio device. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The default input audio device   </returns>
		public Linphone.AudioDevice DefaultInputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_core_get_default_input_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_default_input_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_default_output_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_default_output_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the default output audio device. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The default output audio device   </returns>
		public Linphone.AudioDevice DefaultOutputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_core_get_default_output_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_default_output_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_default_proxy_config(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_default_proxy_config(IntPtr thiz, IntPtr config);

		/// <summary>
		/// Returns the default proxy configuration, that is the one used to determine the
		/// current identity. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The default proxy configuration.   </returns>
		public Linphone.ProxyConfig DefaultProxyConfig
		{
			get
			{
				IntPtr ptr = linphone_core_get_default_proxy_config(nativePtr);
				Linphone.ProxyConfig obj = fromNativePtr<Linphone.ProxyConfig>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_default_proxy_config(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_default_video_display_filter(IntPtr thiz);

		/// <summary>
		/// Get the name of the default mediastreamer2 filter used for rendering video on
		/// the current platform. 
		/// <para>
		/// This is for advanced users of the library, mainly to expose mediastreamer video
		/// filter name and status. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The default video display filter.   </returns>
		public string DefaultVideoDisplayFilter
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_default_video_display_filter(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_delayed_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_delayed_timeout(IntPtr thiz, int seconds);

		/// <summary>
		/// Gets the delayed timeout See <see cref="Linphone.Core.SetDelayedTimeout()" />
		/// for details. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current delayed timeout in seconds </returns>
		public int DelayedTimeout
		{
			get
			{
				return linphone_core_get_delayed_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_delayed_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_device_rotation(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_device_rotation(IntPtr thiz, int rotation);

		/// <summary>
		/// Gets the current device orientation. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current device orientation</returns>
		/// 
		/// <remarks>See : <see cref="Linphone.Core.SetDeviceRotation()" /> </remarks>
		public int DeviceRotation
		{
			get
			{
				return linphone_core_get_device_rotation(nativePtr);
			}
			set
			{
				linphone_core_set_device_rotation(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_disable_record_on_mute(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_disable_record_on_mute(IntPtr thiz, char disable);

		/// <summary>
		/// Get whether the microphone will be completely deactivated when muted. 
		/// <para>
		/// Please refer to <see cref="Linphone.Core.SetDisableRecordOnMute()" />.
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>True if you wish to entirely stop the audio recording when muting the
		/// microphone. </returns>
		public bool DisableRecordOnMute
		{
			get
			{
				return linphone_core_get_disable_record_on_mute(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_disable_record_on_mute(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_dns_search_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_dns_search(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether DNS search (use of local domain if the fully qualified name did
		/// return results) is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if DNS search is enabled, false if disabled. </returns>
		public bool DnsSearchEnabled
		{
			get
			{
				return linphone_core_dns_search_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_dns_search(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_dns_servers(IntPtr thiz, IntPtr servers);

		/// <summary>
		/// Forces liblinphone to use the supplied list of dns servers, instead of system's
		/// ones. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="servers">A list of const char * objects. const char *  A list of
		/// strings containing the IP addresses of DNS servers to be used. Setting to null
		/// restores default behaviour, which is to use the DNS server list provided by the
		/// system. The list is copied internally.   </param>
		/// 
		public IEnumerable<string> DnsServers
		{
			set
			{
				linphone_core_set_dns_servers(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_dns_servers_app(IntPtr thiz, IntPtr servers);

		/// <summary>
		/// Forces liblinphone to use the supplied list of dns servers, instead of system's
		/// ones and set dns_set_by_app at true or false according to value of servers
		/// list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="servers">A list of const char * objects. const char *  A list of
		/// strings containing the IP addresses of DNS servers to be used. Setting to null
		/// restores default behaviour, which is to use the DNS server list provided by the
		/// system. The list is copied internally.   </param>
		/// 
		public IEnumerable<string> DnsServersApp
		{
			set
			{
				linphone_core_set_dns_servers_app(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_dns_set_by_app(IntPtr thiz);

		/// <summary>
		/// Tells if the DNS was set by an application. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if DNS was set by app, false otherwise. </returns>
		public bool DnsSetByApp
		{
			get
			{
				return linphone_core_get_dns_set_by_app(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_dns_srv_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_dns_srv(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether DNS SRV resolution is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if DNS SRV resolution is enabled, false if disabled. </returns>
		public bool DnsSrvEnabled
		{
			get
			{
				return linphone_core_dns_srv_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_dns_srv(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_download_bandwidth(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_download_bandwidth(IntPtr thiz, int bandwidth);

		/// <summary>
		/// Retrieve the maximum available download bandwidth. 
		/// <para>
		/// This value was set by <see cref="Linphone.Core.SetDownloadBandwidth()" />. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the download bandiwdth in kbits/s, 0 for infinite </returns>
		public int DownloadBandwidth
		{
			get
			{
				return linphone_core_get_download_bandwidth(nativePtr);
			}
			set
			{
				linphone_core_set_download_bandwidth(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_download_ptime(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_download_ptime(IntPtr thiz, int ptime);

		/// <summary>
		/// Get audio packetization time linphone expects to receive from peer. 
		/// <para>
		/// A value of zero means that ptime is not specified. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the download packetization time set </returns>
		public int DownloadPtime
		{
			get
			{
				return linphone_core_get_download_ptime(nativePtr);
			}
			set
			{
				linphone_core_set_download_ptime(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_echo_cancellation_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_echo_cancellation(IntPtr thiz, char enable);

		/// <summary>
		/// Returns true if echo cancellation is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether echo cancellation is enabled or
		/// disabled </returns>
		public bool EchoCancellationEnabled
		{
			get
			{
				return linphone_core_echo_cancellation_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_echo_cancellation(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_echo_canceller_filter_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_echo_canceller_filter_name(IntPtr thiz, string filtername);

		/// <summary>
		/// Get the name of the mediastreamer2 filter used for echo cancelling. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The name of the mediastreamer2 filter used for echo cancelling.  
		/// </returns>
		public string EchoCancellerFilterName
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_echo_canceller_filter_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_echo_canceller_filter_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_echo_limiter_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_echo_limiter(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether echo limiter is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the echo limiter is enabled, false otherwise. </returns>
		public bool EchoLimiterEnabled
		{
			get
			{
				return linphone_core_echo_limiter_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_echo_limiter(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_enable_sip_update(IntPtr thiz, int val);

		/// <summary>
		/// Enable or disable the UPDATE method support. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="val">Enable or disable it </param>
		/// 
		public int EnableSipUpdate
		{
			set
			{
				linphone_core_set_enable_sip_update(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_expected_bandwidth(IntPtr thiz, int bandwidth);

		/// <summary>
		/// Sets expected available upload bandwidth This is IP bandwidth, in kbit/s. 
		/// <para>
		/// This information is used by liblinphone together with remote side available
		/// bandwidth signaled in SDP messages to properly configure audio & video codec's
		/// output bitrate.
		/// 
		/// </para>
		/// </summary>
		/// <param name="bandwidth">the bandwidth in kbits/s, 0 for infinite </param>
		/// 
		public int ExpectedBandwidth
		{
			set
			{
				linphone_core_set_expected_bandwidth(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_extended_audio_devices(IntPtr thiz);

		/// <summary>
		/// Returns the list of all audio devices. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.AudioDevice" /> objects.
		/// LinphoneAudioDevice  A list of all <see cref="Linphone.AudioDevice" />  
		/// </returns>
		public IEnumerable<Linphone.AudioDevice> ExtendedAudioDevices
		{
			get
			{
				return MarshalBctbxList<Linphone.AudioDevice>(linphone_core_get_extended_audio_devices(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_file_transfer_server(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_file_transfer_server(IntPtr thiz, string serverUrl);

		/// <summary>
		/// Get the globaly set http file transfer server to be used for content type
		/// application/vnd.gsma.rcs-ft-http+xml. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>URL of the file server like
		/// https://file.linphone.org/upload.php.@xmlonly <maybenil >  </returns>
		public string FileTransferServer
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_file_transfer_server(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_file_transfer_server(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_friend_list_subscription(IntPtr thiz, char enable);

		/// <summary>
		/// Sets whether or not to start friend lists subscription when in foreground. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="enable">whether or not to enable the feature </param>
		/// 
		public bool FriendListSubscriptionEnabled
		{
			set
			{
				linphone_core_enable_friend_list_subscription(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_friends_database_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_friends_database_path(IntPtr thiz, string path);

		/// <summary>
		/// Gets the database filename where friends will be stored. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>filesystem path.   </returns>
		public string FriendsDatabasePath
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_friends_database_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_friends_database_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_friends_lists(IntPtr thiz);

		/// <summary>
		/// Retrieves the list of <see cref="Linphone.FriendList" /> from the core. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.FriendList" /> objects.
		/// LinphoneFriendList  a list of <see cref="Linphone.FriendList" />.   </returns>
		public IEnumerable<Linphone.FriendList> FriendsLists
		{
			get
			{
				return MarshalBctbxList<Linphone.FriendList>(linphone_core_get_friends_lists(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_guess_hostname(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_guess_hostname(IntPtr thiz, char enable);

		/// <summary>
		/// Returns true if hostname part of primary contact is guessed automatically. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if guess hostname enabled, false otherwise. </returns>
		public bool GuessHostname
		{
			get
			{
				return linphone_core_get_guess_hostname(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_guess_hostname(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_http_proxy_host(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_http_proxy_host(IntPtr thiz, string host);

		/// <summary>
		/// Get http proxy address to be used for signaling. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>hostname of IP adress of the http proxy (can be null to disable).  
		/// </returns>
		public string HttpProxyHost
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_http_proxy_host(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_http_proxy_host(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_http_proxy_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_http_proxy_port(IntPtr thiz, int port);

		/// <summary>
		/// Get http proxy port to be used for signaling. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>port of the http proxy. </returns>
		public int HttpProxyPort
		{
			get
			{
				return linphone_core_get_http_proxy_port(nativePtr);
			}
			set
			{
				linphone_core_set_http_proxy_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_identity(IntPtr thiz);

		/// <summary>
		/// Gets the default identity SIP address. 
		/// <para>
		/// This is an helper function. If no default proxy is set, this will return the
		/// primary contact ( see <see cref="Linphone.Core.GetPrimaryContact()" /> ). If a
		/// default proxy is set it returns the registered identity on the proxy. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The default identity SIP address.   </returns>
		public string Identity
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_identity(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_im_notif_policy(IntPtr thiz);

		/// <summary>
		/// Get the <see cref="Linphone.ImNotifPolicy" /> object controlling the instant
		/// messaging notifications. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.ImNotifPolicy" /> object.   </returns>
		public Linphone.ImNotifPolicy ImNotifPolicy
		{
			get
			{
				IntPtr ptr = linphone_core_get_im_notif_policy(nativePtr);
				Linphone.ImNotifPolicy obj = fromNativePtr<Linphone.ImNotifPolicy>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_in_call_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_in_call_timeout(IntPtr thiz, int seconds);

		/// <summary>
		/// Gets the in call timeout See <see cref="Linphone.Core.SetInCallTimeout()" />
		/// for details. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current in call timeout in seconds </returns>
		public int InCallTimeout
		{
			get
			{
				return linphone_core_get_in_call_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_in_call_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_inc_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_inc_timeout(IntPtr thiz, int seconds);

		/// <summary>
		/// Returns the incoming call timeout See <see cref="Linphone.Core.SetIncTimeout()"
		/// /> for details. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current incoming call timeout in seconds </returns>
		public int IncTimeout
		{
			get
			{
				return linphone_core_get_inc_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_inc_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_input_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_input_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the input audio device for the current call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The input audio device for the current or first call, null if there is
		/// no call.   </returns>
		public Linphone.AudioDevice InputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_core_get_input_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_input_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_ipv6_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_ipv6(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether IPv6 is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether IPv6 is enabled or not</returns>
		/// 
		/// <remarks>See : <see cref="Linphone.Core.EnableIpv6()" /> for more details on
		/// how IPv6 is supported in liblinphone. </remarks>
		public bool Ipv6Enabled
		{
			get
			{
				return linphone_core_ipv6_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_ipv6(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_auto_iterate_enabled(IntPtr thiz);

		/// <summary>
		/// Gets whether auto iterate is enabled or not (Android & iOS only). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if <see cref="Linphone.Core.Iterate()" /> is scheduled
		/// automatically, false otherwise </returns>
		public bool IsAutoIterateEnabled
		{
			get
			{
				return linphone_core_is_auto_iterate_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_echo_canceller_calibration_required(IntPtr thiz);

		/// <summary>
		/// Check whether the device is echo canceller calibration is required. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if it is required, false otherwise </returns>
		public bool IsEchoCancellerCalibrationRequired
		{
			get
			{
				return linphone_core_is_echo_canceller_calibration_required(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_friend_list_subscription_enabled(IntPtr thiz);

		/// <summary>
		/// Returns whether or not friend lists subscription are enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>whether or not the feature is enabled </returns>
		public bool IsFriendListSubscriptionEnabled
		{
			get
			{
				return linphone_core_is_friend_list_subscription_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_in_conference(IntPtr thiz);

		/// <summary>
		/// Indicates whether the local participant is part of a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : That function automatically fails in the case of conferences
		/// using a conferencet server (focus). If you use such a conference, you should
		/// use <see cref="Linphone.Conference.RemoveParticipant()" /> instead. </remarks> 
		/// 
		/// <returns>true if the local participant is in a conference, false otherwise.
		/// </returns>
		public bool IsInConference
		{
			get
			{
				return linphone_core_is_in_conference(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_incoming_invite_pending(IntPtr thiz);

		/// <summary>
		/// Tells whether there is an incoming invite pending. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean telling whether an incoming invite is pending or not.
		/// </returns>
		public bool IsIncomingInvitePending
		{
			get
			{
				return linphone_core_is_incoming_invite_pending(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_media_encryption_mandatory(IntPtr thiz);

		/// <summary>
		/// Check if the configured media encryption is mandatory or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if media encryption is mandatory; false otherwise. </returns>
		public bool IsMediaEncryptionMandatory
		{
			get
			{
				return linphone_core_is_media_encryption_mandatory(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_native_ringing_enabled(IntPtr thiz);

		/// <summary>
		/// Returns whether the native ringing is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>True if we use the native ringing, false otherwise </returns>
		public bool IsNativeRingingEnabled
		{
			get
			{
				return linphone_core_is_native_ringing_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_network_reachable(IntPtr thiz);

		/// <summary>
		/// return network state either as positioned by the application or by linphone
		/// itself. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if network is reachable, false otherwise </returns>
		public bool IsNetworkReachable
		{
			get
			{
				return linphone_core_is_network_reachable(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_push_notification_available(IntPtr thiz);

		/// <summary>
		/// Gets whether push notifications are available or not (Android & iOS only). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if push notifications are available, false otherwise </returns>
		public bool IsPushNotificationAvailable
		{
			get
			{
				return linphone_core_is_push_notification_available(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_push_notification_enabled(IntPtr thiz);

		/// <summary>
		/// Gets whether push notifications are enabled or not (Android & iOS only). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if push notifications are enabled, false otherwise </returns>
		public bool IsPushNotificationEnabled
		{
			get
			{
				return linphone_core_is_push_notification_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_sender_name_hidden_in_forward_message(IntPtr thiz);

		/// <summary>
		/// Returns whether or not sender name is hidden in forward message. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>whether or not the feature </returns>
		public bool IsSenderNameHiddenInForwardMessage
		{
			get
			{
				return linphone_core_is_sender_name_hidden_in_forward_message(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_keep_alive_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_keep_alive(IntPtr thiz, char enable);

		/// <summary>
		/// Is signaling keep alive enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether signaling keep alive is enabled
		/// </returns>
		public bool KeepAliveEnabled
		{
			get
			{
				return linphone_core_keep_alive_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_keep_alive(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_last_outgoing_call_log(IntPtr thiz);

		/// <summary>
		/// Get the latest outgoing call log. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The last outgoing call log if any.   </returns>
		public Linphone.CallLog LastOutgoingCallLog
		{
			get
			{
				IntPtr ptr = linphone_core_get_last_outgoing_call_log(nativePtr);
				Linphone.CallLog obj = fromNativePtr<Linphone.CallLog>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_lime_x3dh_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_lime_x3dh(IntPtr thiz, char enable);

		/// <summary>
		/// Tells wether LIME X3DH is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current lime state </returns>
		public bool LimeX3DhEnabled
		{
			get
			{
				return linphone_core_lime_x3dh_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_lime_x3dh(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_lime_x3dh_server_url(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_lime_x3dh_server_url(IntPtr thiz, string url);

		/// <summary>
		/// Get the x3dh server url. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The x3dh server url.   </returns>
		public string LimeX3DhServerUrl
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_lime_x3dh_server_url(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_lime_x3dh_server_url(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_linphone_specs(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_linphone_specs(IntPtr thiz, string specs);

		/// <summary>
		/// Get the linphone specs value telling what functionalities the linphone client
		/// supports. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The linphone specs telling what functionalities the linphone client
		/// supports  </returns>
		/// 
		/// deprecated : 07/02/2019 Use linphone_core_get_linphone_specs_list instead. 
		public string LinphoneSpecs
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_linphone_specs(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_linphone_specs(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_linphone_specs_list(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_linphone_specs_list(IntPtr thiz, IntPtr specs);

		/// <summary>
		/// Get the list of linphone specs string values representing what functionalities
		/// the linphone client supports. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of char * objects. char *  a list of supported specs. The list
		/// must be freed with bctbx_list_free() after usage   </returns>
		public IEnumerable<string> LinphoneSpecsList
		{
			get
			{
				return MarshalStringArray(linphone_core_get_linphone_specs_list(nativePtr));
			}
			set
			{
				linphone_core_set_linphone_specs_list(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_log_collection_upload_server_url(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_log_collection_upload_server_url(IntPtr thiz, string serverUrl);

		/// <summary>
		/// Gets the url of the server where to upload the collected log files. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The url of the server where to upload the collected log files.  
		/// </returns>
		public string LogCollectionUploadServerUrl
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_log_collection_upload_server_url(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_log_collection_upload_server_url(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_max_calls(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_max_calls(IntPtr thiz, int max);

		/// <summary>
		/// Get the maximum number of simultaneous calls Linphone core can manage at a
		/// time. 
		/// <para>
		/// All new call above this limit are declined with a busy answer 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>max number of simultaneous calls </returns>
		public int MaxCalls
		{
			get
			{
				return linphone_core_get_max_calls(nativePtr);
			}
			set
			{
				linphone_core_set_max_calls(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_max_size_for_auto_download_incoming_files(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_max_size_for_auto_download_incoming_files(IntPtr thiz, int size);

		/// <summary>
		/// Gets the size under which incoming files in chat messages will be downloaded
		/// automatically. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The size in bytes, -1 if autodownload feature is disabled, 0 to
		/// download them all no matter the size </returns>
		public int MaxSizeForAutoDownloadIncomingFiles
		{
			get
			{
				return linphone_core_get_max_size_for_auto_download_incoming_files(nativePtr);
			}
			set
			{
				linphone_core_set_max_size_for_auto_download_incoming_files(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_media_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_media_device(IntPtr thiz, string devid);

		/// <summary>
		/// Gets the name of the currently assigned sound device for media. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The name of the currently assigned sound device for capture.  
		/// </returns>
		public string MediaDevice
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_media_device(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_media_device(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("MediaDevice setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.MediaEncryption linphone_core_get_media_encryption(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_media_encryption(IntPtr thiz, int menc);

		/// <summary>
		/// Get the media encryption policy being used for RTP packets. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneMediaEncryption policy being used. </returns>
		public Linphone.MediaEncryption MediaEncryption
		{
			get
			{
				return linphone_core_get_media_encryption(nativePtr);
			}
			set
			{
				int exception_result = linphone_core_set_media_encryption(nativePtr, (int)value);
				if (exception_result != 0) throw new LinphoneException("MediaEncryption setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_media_encryption_mandatory(IntPtr thiz, char mandatory);

		/// <summary>
		/// Define whether the configured media encryption is mandatory, if it is and the
		/// negotation cannot result in the desired media encryption then the call will
		/// fail. 
		/// <para>
		/// If not an INVITE will be resent with encryption disabled. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="mandatory">true to set it mandatory; false otherwise. </param>
		/// 
		public bool MediaEncryptionMandatory
		{
			set
			{
				linphone_core_set_media_encryption_mandatory(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_media_network_reachable(IntPtr thiz, char reachable);

		/// <summary>
		/// This method is called by the application to notify the linphone core library
		/// when the media (RTP) network is reachable. 
		/// <para>
		/// This is for advanced usage, when SIP and RTP layers are required to use
		/// different interfaces. Most applications just need <see
		/// cref="Linphone.Core.SetNetworkReachable()" />.
		/// 
		/// </para>
		/// </summary>
		/// <param name="reachable">true if network is reachable, false otherwise </param>
		/// 
		public bool MediaNetworkReachable
		{
			set
			{
				linphone_core_set_media_network_reachable(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.MediaResourceMode linphone_core_get_media_resource_mode(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_media_resource_mode(IntPtr thiz, int mode);

		/// <summary>
		/// This function returns the media resource mode for this core. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The media resource mode </returns>
		public Linphone.MediaResourceMode MediaResourceMode
		{
			get
			{
				return linphone_core_get_media_resource_mode(nativePtr);
			}
			set
			{
				linphone_core_set_media_resource_mode(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_mic_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_mic(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether the microphone is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the microphone is enabled, false if disabled. </returns>
		public bool MicEnabled
		{
			get
			{
				return linphone_core_mic_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_mic(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_core_get_mic_gain_db(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_mic_gain_db(IntPtr thiz, float level);

		/// <summary>
		/// Get microphone gain in db. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current microphone gain </returns>
		public float MicGainDb
		{
			get
			{
				return linphone_core_get_mic_gain_db(nativePtr);
			}
			set
			{
				linphone_core_set_mic_gain_db(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_missed_calls_count(IntPtr thiz);

		/// <summary>
		/// Get the number of missed calls. 
		/// <para>
		/// Once checked, this counter can be reset with <see
		/// cref="Linphone.Core.ResetMissedCallsCount()" />. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The number of missed calls. </returns>
		public int MissedCallsCount
		{
			get
			{
				return linphone_core_get_missed_calls_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_mtu(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_mtu(IntPtr thiz, int mtu);

		/// <summary>
		/// Returns the maximum transmission unit size in bytes. 
		/// <para>
		/// </para>
		/// </summary>
		public int Mtu
		{
			get
			{
				return linphone_core_get_mtu(nativePtr);
			}
			set
			{
				linphone_core_set_mtu(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_nat_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_nat_address(IntPtr thiz, string addr);

		/// <summary>
		/// Get the public IP address of NAT being used. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The public IP address of NAT being used.   </returns>
		public string NatAddress
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_nat_address(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_nat_address(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_nat_policy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_nat_policy(IntPtr thiz, IntPtr policy);

		/// <summary>
		/// Get The policy that is used to pass through NATs/firewalls. 
		/// <para>
		/// It may be overridden by a NAT policy for a specific proxy config. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.NatPolicy" /> object in use.  </returns>
		/// 
		/// <remarks>See : <see cref="Linphone.ProxyConfig.GetNatPolicy()" /> </remarks>
		public Linphone.NatPolicy NatPolicy
		{
			get
			{
				IntPtr ptr = linphone_core_get_nat_policy(nativePtr);
				Linphone.NatPolicy obj = fromNativePtr<Linphone.NatPolicy>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_nat_policy(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_native_ringing_enabled(IntPtr thiz, char enable);

		/// <summary>
		/// Sets whether to use the native ringing (Android only). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="enable">True to enable native ringing, false otherwise </param>
		/// 
		public bool NativeRingingEnabled
		{
			set
			{
				linphone_core_set_native_ringing_enabled(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_network_reachable(IntPtr thiz, char reachable);

		/// <summary>
		/// This method is called by the application to notify the linphone core library
		/// when network is reachable. 
		/// <para>
		/// Calling this method with true trigger linphone to initiate a registration
		/// process for all proxies. Calling this method disables the automatic network
		/// detection mode. It means you must call this method after each network state
		/// changes.
		/// 
		/// </para>
		/// </summary>
		/// <param name="reachable">true if network is reachable, false otherwise </param>
		/// 
		public bool NetworkReachable
		{
			set
			{
				linphone_core_set_network_reachable(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_nortp_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_nortp_timeout(IntPtr thiz, int seconds);

		/// <summary>
		/// Gets the value of the no-rtp timeout. 
		/// <para>
		/// When no RTP or RTCP packets have been received for a while <see
		/// cref="Linphone.Core" /> will consider the call is broken (remote end crashed or
		/// disconnected from the network), and thus will terminate the call. The no-rtp
		/// timeout is the duration above which the call is considered broken. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The value of the no-rtp timeout in seconds </returns>
		public int NortpTimeout
		{
			get
			{
				return linphone_core_get_nortp_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_nortp_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_output_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_output_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the output audio device for the current call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The output audio device for the current or first call, null if there
		/// is no call.   </returns>
		public Linphone.AudioDevice OutputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_core_get_output_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_output_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_play_file(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_play_file(IntPtr thiz, string file);

		/// <summary>
		/// Get the wav file that is played when putting somebody on hold, or when files
		/// are used instead of soundcards (see <see cref="Linphone.Core.SetUseFiles()"
		/// />). 
		/// <para>
		/// The file is a 16 bit linear wav file. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the file that is played when putting somebody on hold.  
		/// </returns>
		public string PlayFile
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_play_file(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_play_file(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_playback_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_playback_device(IntPtr thiz, string devid);

		/// <summary>
		/// Gets the name of the currently assigned sound device for playback. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The name of the currently assigned sound device for playback.  
		/// </returns>
		public string PlaybackDevice
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_playback_device(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_playback_device(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("PlaybackDevice setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_core_get_playback_gain_db(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_playback_gain_db(IntPtr thiz, float level);

		/// <summary>
		/// Get playback gain in db before entering sound card. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current playback gain </returns>
		public float PlaybackGainDb
		{
			get
			{
				return linphone_core_get_playback_gain_db(nativePtr);
			}
			set
			{
				linphone_core_set_playback_gain_db(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_core_get_preferred_framerate(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_preferred_framerate(IntPtr thiz, float fps);

		/// <summary>
		/// Returns the preferred video framerate, previously set by <see
		/// cref="Linphone.Core.SetPreferredFramerate()" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>frame rate in number of frames per seconds. </returns>
		public float PreferredFramerate
		{
			get
			{
				return linphone_core_get_preferred_framerate(nativePtr);
			}
			set
			{
				linphone_core_set_preferred_framerate(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_preferred_video_definition(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_preferred_video_definition(IntPtr thiz, IntPtr videoDefinition);

		/// <summary>
		/// Get the preferred video definition for the stream that is captured and sent to
		/// the remote party. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The preferred <see cref="Linphone.VideoDefinition" />   </returns>
		public Linphone.VideoDefinition PreferredVideoDefinition
		{
			get
			{
				IntPtr ptr = linphone_core_get_preferred_video_definition(nativePtr);
				Linphone.VideoDefinition obj = fromNativePtr<Linphone.VideoDefinition>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_preferred_video_definition(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_preferred_video_definition_by_name(IntPtr thiz, string name);

		/// <summary>
		/// Sets the preferred video definition by its name. 
		/// <para>
		/// Call <see cref="Linphone.Factory.GetSupportedVideoDefinitions()" /> to have a
		/// list of supported video definitions.
		/// 
		/// </para>
		/// </summary>
		/// <param name="name">The name of the definition to set   </param>
		/// 
		public string PreferredVideoDefinitionByName
		{
			set
			{
				linphone_core_set_preferred_video_definition_by_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_presence_model(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_presence_model(IntPtr thiz, IntPtr presence);

		/// <summary>
		/// Get my presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.PresenceModel" /> object, or null if no presence
		/// model has been set.   </returns>
		public Linphone.PresenceModel PresenceModel
		{
			get
			{
				IntPtr ptr = linphone_core_get_presence_model(nativePtr);
				Linphone.PresenceModel obj = fromNativePtr<Linphone.PresenceModel>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_presence_model(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_preview_video_definition(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_preview_video_definition(IntPtr thiz, IntPtr videoDefinition);

		/// <summary>
		/// Get the definition of the captured video. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The captured <see cref="Linphone.VideoDefinition" /> if it was
		/// previously set by <see cref="Linphone.Core.SetPreviewVideoDefinition()" />,
		/// otherwise a 0x0 LinphoneVideoDefinition.   </returns>
		/// 
		/// <remarks>See : <see cref="Linphone.Core.SetPreviewVideoDefinition()" />
		/// </remarks>
		public Linphone.VideoDefinition PreviewVideoDefinition
		{
			get
			{
				IntPtr ptr = linphone_core_get_preview_video_definition(nativePtr);
				Linphone.VideoDefinition obj = fromNativePtr<Linphone.VideoDefinition>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_preview_video_definition(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_primary_contact(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_primary_contact(IntPtr thiz, string contact);

		/// <summary>
		/// Returns the default identity when no proxy configuration is used. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the primary contact identity   </returns>
		public string PrimaryContact
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_primary_contact(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_primary_contact(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("PrimaryContact setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_primary_contact_parsed(IntPtr thiz);

		/// <summary>
		/// Same as <see cref="Linphone.Core.GetPrimaryContact()" /> but the result is a
		/// <see cref="Linphone.Address" /> object instead of const char *. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Address" /> object.  </returns>
		/// 
		/// deprecated : 22/10/2018 Use <see
		/// cref="Linphone.Core.CreatePrimaryContactParsed()" /> instead. 
		public Linphone.Address PrimaryContactParsed
		{
			get
			{
				IntPtr ptr = linphone_core_get_primary_contact_parsed(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_provisioning_uri(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_provisioning_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Get provisioning URI. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the provisioning URI.   </returns>
		public string ProvisioningUri
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_provisioning_uri(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_provisioning_uri(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("ProvisioningUri setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_proxy_config_list(IntPtr thiz);

		/// <summary>
		/// Returns an unmodifiable list of entered proxy configurations. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.ProxyConfig" /> objects.
		/// LinphoneProxyConfig    </returns>
		public IEnumerable<Linphone.ProxyConfig> ProxyConfigList
		{
			get
			{
				return MarshalBctbxList<Linphone.ProxyConfig>(linphone_core_get_proxy_config_list(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_push_incoming_call_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_push_incoming_call_timeout(IntPtr thiz, int seconds);

		/// <summary>
		/// Returns the push incoming call timeout See <see
		/// cref="Linphone.Core.SetPushIncomingCallTimeout()" /> for details. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current push incoming call timeout in seconds </returns>
		public int PushIncomingCallTimeout
		{
			get
			{
				return linphone_core_get_push_incoming_call_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_push_incoming_call_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_push_notification_enabled(IntPtr thiz, char enable);

		/// <summary>
		/// Enable or disable push notifications on Android & iOS. 
		/// <para>
		/// If enabled, it will try to get the push token add configure each proxy config
		/// with push_notification_allowed set to true with push parameters. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="enable">true to enable push notifications, false to disable
		/// </param>
		/// 
		public bool PushNotificationEnabled
		{
			set
			{
				linphone_core_set_push_notification_enabled(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_qrcode_video_preview_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_qrcode_video_preview(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether QRCode is enabled in the preview. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether QRCode is enabled in the preview.
		/// </returns>
		public bool QrcodeVideoPreviewEnabled
		{
			get
			{
				return linphone_core_qrcode_video_preview_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_qrcode_video_preview(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_realtime_text_enabled(IntPtr thiz);

		/// <summary>
		/// Gets if realtime text is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if realtime text is enabled, false otherwise </returns>
		public bool RealtimeTextEnabled
		{
			get
			{
				return linphone_core_realtime_text_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_record_file(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_record_file(IntPtr thiz, string file);

		/// <summary>
		/// Get the wav file where incoming stream is recorded, when files are used instead
		/// of soundcards (see <see cref="Linphone.Core.SetUseFiles()" />). 
		/// <para>
		/// This feature is different from call recording (<see
		/// cref="Linphone.CallParams.SetRecordFile()" />) The file is a 16 bit linear wav
		/// file. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the file where incoming stream is recorded.   </returns>
		public string RecordFile
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_record_file(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_record_file(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_remote_ringback_tone(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_remote_ringback_tone(IntPtr thiz, string ring);

		/// <summary>
		/// Get the ring back tone played to far end during incoming calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the path to the remote ring back tone to be played.   </returns>
		public string RemoteRingbackTone
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_remote_ringback_tone(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_remote_ringback_tone(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_retransmission_on_nack_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_retransmission_on_nack(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether NACK context is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether NACK context is enabled or not
		/// </returns>
		public bool RetransmissionOnNackEnabled
		{
			get
			{
				return linphone_core_retransmission_on_nack_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_retransmission_on_nack(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_ring(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_ring(IntPtr thiz, string path);

		/// <summary>
		/// Returns the path to the wav file used for ringing. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the wav file used for ringing.   </returns>
		public string Ring
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_ring(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_ring(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_ring_during_incoming_early_media(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_ring_during_incoming_early_media(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether the ring play is enabled during an incoming early media call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public bool RingDuringIncomingEarlyMedia
		{
			get
			{
				return linphone_core_get_ring_during_incoming_early_media(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_ring_during_incoming_early_media(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_ringback(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_ringback(IntPtr thiz, string path);

		/// <summary>
		/// Returns the path to the wav file used for ringing back. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the wav file used for ringing back.   </returns>
		public string Ringback
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_ringback(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_ringback(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_ringer_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_ringer_device(IntPtr thiz, string devid);

		/// <summary>
		/// Gets the name of the currently assigned sound device for ringing. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The name of the currently assigned sound device for ringing.  
		/// </returns>
		public string RingerDevice
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_ringer_device(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_ringer_device(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("RingerDevice setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_root_ca(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_root_ca(IntPtr thiz, string path);

		/// <summary>
		/// Gets the path to a file or folder containing the trusted root CAs (PEM format) 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to a file or folder containing the trusted root CAs.  
		/// </returns>
		public string RootCa
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_root_ca(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_root_ca(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_root_ca_data(IntPtr thiz, string data);

		/// <summary>
		/// Sets the trusted root CAs (PEM format) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="data">The trusted root CAs as a string   </param>
		/// 
		public string RootCaData
		{
			set
			{
				linphone_core_set_root_ca_data(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_rtp_bundle_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_rtp_bundle(IntPtr thiz, char val);

		/// <summary>
		/// Returns whether RTP bundle mode (also known as Media Multiplexing) is enabled. 
		/// <para>
		/// See https://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-54 for
		/// more information. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a boolean indicating the enablement of rtp bundle mode. </returns>
		public bool RtpBundleEnabled
		{
			get
			{
				return linphone_core_rtp_bundle_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_rtp_bundle(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_sdp_200_ack_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_sdp_200_ack(IntPtr thiz, char enable);

		/// <summary>
		/// Media offer control param for SIP INVITE. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if INVITE has to be sent whitout SDP. </returns>
		public bool Sdp200AckEnabled
		{
			get
			{
				return linphone_core_sdp_200_ack_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_sdp_200_ack(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_self_view_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_self_view(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether video self view during call is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether self view is enabled </returns>
		/// 
		/// <remarks>See : <see cref="Linphone.Core.EnableSelfView()" /> for details.
		/// </remarks>
		public bool SelfViewEnabled
		{
			get
			{
				return linphone_core_self_view_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_self_view(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_sender_name_hidden_in_forward_message(IntPtr thiz, char enable);

		/// <summary>
		/// Enable whether or not to hide sender name in forward message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="enable">whether or not to enable the feature </param>
		/// 
		public bool SenderNameHiddenInForwardMessageEnabled
		{
			set
			{
				linphone_core_enable_sender_name_hidden_in_forward_message(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_session_expires_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_session_expires_enabled(IntPtr thiz, char enabled);

		/// <summary>
		/// Check if the Session Timers feature is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public bool SessionExpiresEnabled
		{
			get
			{
				return linphone_core_get_session_expires_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_session_expires_enabled(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_session_expires_min_value(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_session_expires_min_value(IntPtr thiz, int min);

		/// <summary>
		/// Returns the session expires min value, 90 by default. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public int SessionExpiresMinValue
		{
			get
			{
				return linphone_core_get_session_expires_min_value(nativePtr);
			}
			set
			{
				linphone_core_set_session_expires_min_value(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SessionExpiresRefresher linphone_core_get_session_expires_refresher_value(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_session_expires_refresher_value(IntPtr thiz, int refresher);

		/// <summary>
		/// Returns the session expires refresher value. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public Linphone.SessionExpiresRefresher SessionExpiresRefresherValue
		{
			get
			{
				return linphone_core_get_session_expires_refresher_value(nativePtr);
			}
			set
			{
				linphone_core_set_session_expires_refresher_value(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_session_expires_value(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_session_expires_value(IntPtr thiz, int expires);

		/// <summary>
		/// Returns the session expires value. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public int SessionExpiresValue
		{
			get
			{
				return linphone_core_get_session_expires_value(nativePtr);
			}
			set
			{
				linphone_core_set_session_expires_value(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_sip_dscp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_sip_dscp(IntPtr thiz, int dscp);

		/// <summary>
		/// Get the DSCP field for SIP signaling channel. 
		/// <para>
		/// The DSCP defines the quality of service in IP packets. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current DSCP value </returns>
		public int SipDscp
		{
			get
			{
				return linphone_core_get_sip_dscp(nativePtr);
			}
			set
			{
				linphone_core_set_sip_dscp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_sip_network_reachable(IntPtr thiz, char reachable);

		/// <summary>
		/// This method is called by the application to notify the linphone core library
		/// when the SIP network is reachable. 
		/// <para>
		/// This is for advanced usage, when SIP and RTP layers are required to use
		/// different interfaces. Most applications just need <see
		/// cref="Linphone.Core.SetNetworkReachable()" />.
		/// 
		/// </para>
		/// </summary>
		/// <param name="reachable">true if network is reachable, false otherwise </param>
		/// 
		public bool SipNetworkReachable
		{
			set
			{
				linphone_core_set_sip_network_reachable(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_sip_transport_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_sip_transport_timeout(IntPtr thiz, int timeoutMs);

		/// <summary>
		/// Get the SIP transport timeout. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The SIP transport timeout in milliseconds. </returns>
		public int SipTransportTimeout
		{
			get
			{
				return linphone_core_get_sip_transport_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_sip_transport_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_sound_devices_list(IntPtr thiz);

		/// <summary>
		/// Gets the list of the available sound devices. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of char * objects. char *  An unmodifiable array of strings
		/// contanining the names of the available sound devices that is null terminated.  
		/// </returns>
		public IEnumerable<string> SoundDevicesList
		{
			get
			{
				return MarshalStringArray(linphone_core_get_sound_devices_list(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_static_picture(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_static_picture(IntPtr thiz, string path);

		/// <summary>
		/// Get the path to the image file streamed when "Static picture" is set as the
		/// video device. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the image file streamed when "Static picture" is set as
		/// the video device.   </returns>
		public string StaticPicture
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_static_picture(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_static_picture(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("StaticPicture setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_core_get_static_picture_fps(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_static_picture_fps(IntPtr thiz, float fps);

		/// <summary>
		/// Get the frame rate for static picture. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The frame rate used for static picture. </returns>
		public float StaticPictureFps
		{
			get
			{
				return linphone_core_get_static_picture_fps(nativePtr);
			}
			set
			{
				int exception_result = linphone_core_set_static_picture_fps(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("StaticPictureFps setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_stun_server(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_stun_server(IntPtr thiz, string server);

		/// <summary>
		/// Get the STUN server address being used. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The STUN server address being used.   </returns>
		public string StunServer
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_stun_server(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_stun_server(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_supported_file_formats_list(IntPtr thiz);

		/// <summary>
		/// Returns a null terminated table of strings containing the file format extension
		/// supported for call recording. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of char * objects. char *  the supported formats, typically
		/// 'wav' and 'mkv'   </returns>
		public IEnumerable<string> SupportedFileFormatsList
		{
			get
			{
				return MarshalStringArray(linphone_core_get_supported_file_formats_list(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_supported_tag(IntPtr thiz, string tags);

		/// <summary>
		/// Set the supported tags. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public string SupportedTag
		{
			set
			{
				linphone_core_set_supported_tag(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_text_payload_types(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_text_payload_types(IntPtr thiz, IntPtr payloadTypes);

		/// <summary>
		/// Return the list of the available text payload types. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.PayloadType" /> objects.
		/// LinphonePayloadType  A freshly allocated list of the available payload types.
		/// The list must be destroyed with bctbx_list_free() after usage. The elements of
		/// the list haven't to be unref.   </returns>
		public IEnumerable<Linphone.PayloadType> TextPayloadTypes
		{
			get
			{
				return MarshalBctbxList<Linphone.PayloadType>(linphone_core_get_text_payload_types(nativePtr), true);
			}
			set
			{
				linphone_core_set_text_payload_types(nativePtr, ObjectArrayToBctbxList<Linphone.PayloadType>(value));
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_text_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_text_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the UDP port used for text streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The UDP port used for text streaming </returns>
		public int TextPort
		{
			get
			{
				return linphone_core_get_text_port(nativePtr);
			}
			set
			{
				linphone_core_set_text_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_text_ports_range(IntPtr thiz);

		/// <summary>
		/// Get the text port range from which is randomly chosen the UDP port used for
		/// text streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Range" /> object     </returns>
		public Linphone.Range TextPortsRange
		{
			get
			{
				IntPtr ptr = linphone_core_get_text_ports_range(nativePtr);
				Linphone.Range obj = fromNativePtr<Linphone.Range>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_tls_cert(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_tls_cert(IntPtr thiz, string tlsCert);

		/// <summary>
		/// Gets the TLS certificate. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the TLS certificate or null if not set yet.   </returns>
		public string TlsCert
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_tls_cert(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_tls_cert(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_tls_cert_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_tls_cert_path(IntPtr thiz, string tlsCertPath);

		/// <summary>
		/// Gets the path to the TLS certificate file. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the TLS certificate path or null if not set yet.   </returns>
		public string TlsCertPath
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_tls_cert_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_tls_cert_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_tls_key(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_tls_key(IntPtr thiz, string tlsKey);

		/// <summary>
		/// Gets the TLS key. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the TLS key or null if not set yet.   </returns>
		public string TlsKey
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_tls_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_tls_key(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_tls_key_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_tls_key_path(IntPtr thiz, string tlsKeyPath);

		/// <summary>
		/// Gets the path to the TLS key file. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the TLS key path or null if not set yet.   </returns>
		public string TlsKeyPath
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_tls_key_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_tls_key_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_transports(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_transports(IntPtr thiz, IntPtr transports);

		/// <summary>
		/// Retrieves the port configuration used for each transport (udp, tcp, tls). 
		/// <para>
		/// A zero value port for a given transport means the transport is not used. A
		/// value of LC_SIP_TRANSPORT_RANDOM (-1) means the port is to be chosen randomly
		/// by the system. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Transports" /> structure with the configured
		/// ports     </returns>
		public Linphone.Transports Transports
		{
			get
			{
				IntPtr ptr = linphone_core_get_transports(nativePtr);
				Linphone.Transports obj = fromNativePtr<Linphone.Transports>(ptr, true);
				return obj;
			}
			set
			{
				int exception_result = linphone_core_set_transports(nativePtr, value.nativePtr);
				if (exception_result != 0) throw new LinphoneException("Transports setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_transports_used(IntPtr thiz);

		/// <summary>
		/// Retrieves the real port number assigned for each sip transport (udp, tcp, tls). 
		/// <para>
		/// A zero value means that the transport is not activated. If
		/// LC_SIP_TRANSPORT_RANDOM was passed to linphone_core_set_sip_transports, the
		/// random port choosed by the system is returned. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Transports" /> structure with the ports being
		/// used     </returns>
		public Linphone.Transports TransportsUsed
		{
			get
			{
				IntPtr ptr = linphone_core_get_transports_used(nativePtr);
				Linphone.Transports obj = fromNativePtr<Linphone.Transports>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_tunnel(IntPtr thiz);

		/// <summary>
		/// get tunnel instance if available 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.Tunnel" /> or null if not available.   </returns>
		public Linphone.Tunnel Tunnel
		{
			get
			{
				IntPtr ptr = linphone_core_get_tunnel(nativePtr);
				Linphone.Tunnel obj = fromNativePtr<Linphone.Tunnel>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_unread_chat_message_count(IntPtr thiz);

		/// <summary>
		/// Return the global unread chat message count. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The global unread chat message count. </returns>
		public int UnreadChatMessageCount
		{
			get
			{
				return linphone_core_get_unread_chat_message_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_unread_chat_message_count_from_active_locals(IntPtr thiz);

		/// <summary>
		/// Return the unread chat message count for all active local address. 
		/// <para>
		/// (Primary contact + proxy configs.) 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The unread chat message count. </returns>
		public int UnreadChatMessageCountFromActiveLocals
		{
			get
			{
				return linphone_core_get_unread_chat_message_count_from_active_locals(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_upload_bandwidth(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_upload_bandwidth(IntPtr thiz, int bandwidth);

		/// <summary>
		/// Retrieve the maximum available upload bandwidth. 
		/// <para>
		/// This value was set by <see cref="Linphone.Core.SetUploadBandwidth()" />. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the upload bandiwdth in kbits/s, 0 for infinite </returns>
		public int UploadBandwidth
		{
			get
			{
				return linphone_core_get_upload_bandwidth(nativePtr);
			}
			set
			{
				linphone_core_set_upload_bandwidth(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_upload_ptime(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_upload_ptime(IntPtr thiz, int ptime);

		/// <summary>
		/// Set audio packetization time linphone will send (in absence of requirement from
		/// peer) A value of 0 stands for the current codec default packetization time. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the upload packetization time set </returns>
		public int UploadPtime
		{
			get
			{
				return linphone_core_get_upload_ptime(nativePtr);
			}
			set
			{
				linphone_core_set_upload_ptime(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_upnp_external_ipaddress(IntPtr thiz);

		/// <summary>
		/// Return the external ip address of router. 
		/// <para>
		/// In some cases the uPnP can have an external ip address but not a usable uPnP
		/// (state different of Ok).
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a null terminated string containing the external ip address. If the
		/// the external ip address is not available return null.   </returns>
		public string UpnpExternalIpaddress
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_upnp_external_ipaddress(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.UpnpState linphone_core_get_upnp_state(IntPtr thiz);

		/// <summary>
		/// Return the internal state of uPnP. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>an LinphoneUpnpState. </returns>
		public Linphone.UpnpState UpnpState
		{
			get
			{
				return linphone_core_get_upnp_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_use_files(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_use_files(IntPtr thiz, char yesno);

		/// <summary>
		/// Gets whether linphone is currently streaming audio from and to files, rather
		/// than using the soundcard. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value representing whether linphone is streaming audio from
		/// and to files or not. </returns>
		public bool UseFiles
		{
			get
			{
				return linphone_core_get_use_files(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_use_files(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_use_info_for_dtmf(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_use_info_for_dtmf(IntPtr thiz, char useInfo);

		/// <summary>
		/// Indicates whether SIP INFO is used to send digits. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether SIP INFO is used to send digits
		/// </returns>
		public bool UseInfoForDtmf
		{
			get
			{
				return linphone_core_get_use_info_for_dtmf(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_use_info_for_dtmf(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_use_rfc2833_for_dtmf(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_use_rfc2833_for_dtmf(IntPtr thiz, char useRfc2833);

		/// <summary>
		/// Indicates whether RFC2833 is used to send digits. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether RFC2833 is used to send digits
		/// </returns>
		public bool UseRfc2833ForDtmf
		{
			get
			{
				return linphone_core_get_use_rfc2833_for_dtmf(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_use_rfc2833_for_dtmf(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_user_agent(IntPtr thiz);

		/// <summary>
		/// Gets the user-agent as a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>liblinphone's user agent as a string.   </returns>
		public string UserAgent
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_user_agent(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_user_certificates_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_user_certificates_path(IntPtr thiz, string path);

		/// <summary>
		/// Get the path to the directory storing the user's certificates. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the directory storing the user's certificates.   </returns>
		public string UserCertificatesPath
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_user_certificates_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_user_certificates_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_activation_policy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_activation_policy(IntPtr thiz, IntPtr policy);

		/// <summary>
		/// Get the default policy for video. 
		/// <para>
		/// See <see cref="Linphone.Core.SetVideoActivationPolicy()" /> for more details. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The video policy being used   </returns>
		public Linphone.VideoActivationPolicy VideoActivationPolicy
		{
			get
			{
				IntPtr ptr = linphone_core_get_video_activation_policy(nativePtr);
				Linphone.VideoActivationPolicy obj = fromNativePtr<Linphone.VideoActivationPolicy>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_video_activation_policy(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_adaptive_jittcomp_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_video_adaptive_jittcomp(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether the video adaptive jitter compensation is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the video adaptive jitter compensation is enabled, false
		/// otherwise. </returns>
		public bool VideoAdaptiveJittcompEnabled
		{
			get
			{
				return linphone_core_video_adaptive_jittcomp_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_video_adaptive_jittcomp(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_capture_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_video_capture(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether video capture is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if video capture is enabled, false if disabled. </returns>
		public bool VideoCaptureEnabled
		{
			get
			{
				return linphone_core_video_capture_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_video_capture(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_video_device(IntPtr thiz, string id);

		/// <summary>
		/// Returns the name of the currently active video device. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The name of the currently active video device.   </returns>
		public string VideoDevice
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_video_device(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_video_device(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("VideoDevice setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_devices_list(IntPtr thiz);

		/// <summary>
		/// Gets the list of the available video capture devices. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of char * objects. char *  An unmodifiable array of strings
		/// contanining the names of the available video capture devices that is null
		/// terminated.   </returns>
		public IEnumerable<string> VideoDevicesList
		{
			get
			{
				return MarshalStringArray(linphone_core_get_video_devices_list(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_display_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_video_display(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether video display is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if video display is enabled, false if disabled. </returns>
		public bool VideoDisplayEnabled
		{
			get
			{
				return linphone_core_video_display_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_video_display(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_display_filter(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_display_filter(IntPtr thiz, string filterName);

		/// <summary>
		/// Get the name of the mediastreamer2 filter used for rendering video. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The currently selected video display filter.   </returns>
		public string VideoDisplayFilter
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_video_display_filter(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_video_display_filter(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_video_dscp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_dscp(IntPtr thiz, int dscp);

		/// <summary>
		/// Get the DSCP field for outgoing video streams. 
		/// <para>
		/// The DSCP defines the quality of service in IP packets. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current DSCP value </returns>
		public int VideoDscp
		{
			get
			{
				return linphone_core_get_video_dscp(nativePtr);
			}
			set
			{
				linphone_core_set_video_dscp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_enabled(IntPtr thiz);

		/// <summary>
		/// Returns true if either capture or display is enabled, false otherwise. 
		/// <para>
		/// same as ( linphone_core_video_capture_enabled |
		/// linphone_core_video_display_enabled )
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if either capture or display is enabled, false otherwise.
		/// </returns>
		public bool VideoEnabled
		{
			get
			{
				return linphone_core_video_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_video_jittcomp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_jittcomp(IntPtr thiz, int milliseconds);

		/// <summary>
		/// Returns the nominal video jitter buffer size in milliseconds. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The nominal video jitter buffer size in milliseconds </returns>
		public int VideoJittcomp
		{
			get
			{
				return linphone_core_get_video_jittcomp(nativePtr);
			}
			set
			{
				linphone_core_set_video_jittcomp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_multicast_addr(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_video_multicast_addr(IntPtr thiz, string ip);

		/// <summary>
		/// Use to get multicast address to be used for video stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>an ipv4/6 multicast address, or default value.   </returns>
		public string VideoMulticastAddr
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_video_multicast_addr(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_video_multicast_addr(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("VideoMulticastAddr setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_multicast_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_video_multicast(IntPtr thiz, char yesno);

		/// <summary>
		/// Use to get multicast state of video stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if subsequent calls will propose multicast ip set by
		/// linphone_core_set_video_multicast_addr </returns>
		public bool VideoMulticastEnabled
		{
			get
			{
				return linphone_core_video_multicast_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_video_multicast(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_video_multicast_ttl(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_video_multicast_ttl(IntPtr thiz, int ttl);

		/// <summary>
		/// Use to get multicast ttl to be used for video stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a time to leave value </returns>
		public int VideoMulticastTtl
		{
			get
			{
				return linphone_core_get_video_multicast_ttl(nativePtr);
			}
			set
			{
				int exception_result = linphone_core_set_video_multicast_ttl(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("VideoMulticastTtl setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_payload_types(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_payload_types(IntPtr thiz, IntPtr payloadTypes);

		/// <summary>
		/// Return the list of the available video payload types. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.PayloadType" /> objects.
		/// LinphonePayloadType  A freshly allocated list of the available payload types.
		/// The list must be destroyed with bctbx_list_free() after usage. The elements of
		/// the list haven't to be unref.   </returns>
		public IEnumerable<Linphone.PayloadType> VideoPayloadTypes
		{
			get
			{
				return MarshalBctbxList<Linphone.PayloadType>(linphone_core_get_video_payload_types(nativePtr), true);
			}
			set
			{
				linphone_core_set_video_payload_types(nativePtr, ObjectArrayToBctbxList<Linphone.PayloadType>(value));
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_video_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the UDP port used for video streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The UDP port used for video streaming </returns>
		public int VideoPort
		{
			get
			{
				return linphone_core_get_video_port(nativePtr);
			}
			set
			{
				linphone_core_set_video_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_ports_range(IntPtr thiz);

		/// <summary>
		/// Get the video port range from which is randomly chosen the UDP port used for
		/// video streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Range" /> object     </returns>
		public Linphone.Range VideoPortsRange
		{
			get
			{
				IntPtr ptr = linphone_core_get_video_ports_range(nativePtr);
				Linphone.Range obj = fromNativePtr<Linphone.Range>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_preset(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_preset(IntPtr thiz, string preset);

		/// <summary>
		/// Get the video preset used for video calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The name of the video preset used for video calls (can be null if the
		/// default video preset is used).   </returns>
		public string VideoPreset
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_video_preset(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_video_preset(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_preview_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_video_preview(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether video preview is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether video preview is enabled </returns>
		public bool VideoPreviewEnabled
		{
			get
			{
				return linphone_core_video_preview_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_video_preview(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_video_source_reuse(IntPtr thiz, char enable);

		/// <summary>
		/// Enable or disable video source reuse when switching from preview to actual
		/// video call. 
		/// <para>
		/// This source reuse is useful when you always display the preview, even before
		/// calls are initiated. By keeping the video source for the transition to a real
		/// video call, you will smooth out the source close/reopen cycle.
		/// 
		/// This function does not have any effect durfing calls. It just indicates the
		/// <see cref="Linphone.Core" /> to initiate future calls with video source reuse
		/// or not. Also, at the end of a video call, the source will be closed whatsoever
		/// for now. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="enable">true to enable video source reuse. false to disable it for
		/// subsequent calls. </param>
		/// 
		public bool VideoSourceReuseEnabled
		{
			set
			{
				linphone_core_enable_video_source_reuse(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_wifi_only_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_wifi_only(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether Wifi only mode is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : Only works for Android platform. </remarks> 
		/// 
		/// <returns>A boolean value telling whether Wifi only mode is enabled or not
		/// </returns>
		public bool WifiOnlyEnabled
		{
			get
			{
				return linphone_core_wifi_only_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_wifi_only(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_zrtp_cache_db(IntPtr thiz);

		/// <summary>
		/// Get a pointer to the sqlite db holding zrtp/lime cache. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>An sqlite3 pointer cast to a void one or null if cache is not
		/// available(not enabled at compile or access failed)   </returns>
		public IntPtr ZrtpCacheDb
		{
			get
			{
				return linphone_core_get_zrtp_cache_db(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_zrtp_secrets_file(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_zrtp_secrets_file(IntPtr thiz, string file);

		/// <summary>
		/// Get the path to the file storing the zrtp secrets cache. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the file storing the zrtp secrets cache.   </returns>
		public string ZrtpSecretsFile
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_zrtp_secrets_file(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_zrtp_secrets_file(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_activate_audio_session(IntPtr thiz, char actived);

		/// <summary>
		/// Special function to indicate if the audio session is activated. 
		/// <para>
		/// Must be called when ProviderDelegate of the callkit notifies that the audio
		/// session is activated or deactivated. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void ActivateAudioSession(bool actived)
		{
			linphone_core_activate_audio_session(nativePtr, actived ? (char)1 : (char)0);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_add_all_to_conference(IntPtr thiz);

		/// <summary>
		/// Add all current calls into the conference. 
		/// <para>
		/// If no conference is running a new internal conference context is created and
		/// all current calls are added to it. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if succeeded. Negative number if failed </returns>
		public void AddAllToConference()
		{
			int exception_result = linphone_core_add_all_to_conference(nativePtr);
			if (exception_result != 0) throw new LinphoneException("AddAllToConference returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_add_auth_info(IntPtr thiz, IntPtr info);

		/// <summary>
		/// Adds authentication information to the <see cref="Linphone.Core" />. 
		/// <para>
		/// That piece of information will be used during all SIP transactions that require
		/// authentication. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="info">The <see cref="Linphone.AuthInfo" /> to add.   </param>
		/// 
		public void AddAuthInfo(Linphone.AuthInfo info)
		{
			linphone_core_add_auth_info(nativePtr, info != null ? info.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_add_friend_list(IntPtr thiz, IntPtr list);

		/// <summary>
		/// Add a friend list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="list"><see cref="Linphone.FriendList" /> object   </param>
		/// 
		public void AddFriendList(Linphone.FriendList list)
		{
			linphone_core_add_friend_list(nativePtr, list != null ? list.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_add_linphone_spec(IntPtr thiz, string spec);

		/// <summary>
		/// Add the given linphone specs to the list of functionalities the linphone client
		/// supports. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="spec">The spec to add   </param>
		/// 
		public void AddLinphoneSpec(string spec)
		{
			linphone_core_add_linphone_spec(nativePtr, spec);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_add_proxy_config(IntPtr thiz, IntPtr config);

		/// <summary>
		/// Add a proxy configuration. 
		/// <para>
		/// This will start registration on the proxy, if registration is enabled. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="config">the <see cref="Linphone.ProxyConfig" /> to add   </param>
		/// 
		/// 
		/// <returns>0 if successful, -1 otherwise </returns>
		public void AddProxyConfig(Linphone.ProxyConfig config)
		{
			int exception_result = linphone_core_add_proxy_config(nativePtr, config != null ? config.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddProxyConfig returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_add_supported_tag(IntPtr thiz, string tag);

		/// <summary>
		/// This function controls signaling features supported by the core. 
		/// <para>
		/// They are typically included in a SIP Supported header. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="tag">The feature tag name   </param>
		/// 
		public void AddSupportedTag(string tag)
		{
			linphone_core_add_supported_tag(nativePtr, tag);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_add_to_conference(IntPtr thiz, IntPtr call);

		/// <summary>
		/// Add a participant to the conference. 
		/// <para>
		/// If no conference is going on a new internal conference context is created and
		/// the participant is added to it. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="call">The current call with the participant to add   </param>
		/// 
		/// 
		/// <returns>0 if succeeded. Negative number if failed </returns>
		public void AddToConference(Linphone.Call call)
		{
			int exception_result = linphone_core_add_to_conference(nativePtr, call != null ? call.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddToConference returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_audio_route_changed(IntPtr thiz);

		/// <summary>
		/// Special function to indicate if the audio route is changed. 
		/// <para>
		/// Must be called in the callback of AVAudioSessionRouteChangeNotification. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// deprecated : 07/01/2020 now handled in the linphone SDK directly 
		public void AudioRouteChanged()
		{
			linphone_core_audio_route_changed(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_check_for_update(IntPtr thiz, string currentVersion);

		/// <summary>
		/// Checks if a new version of the application is available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="currentVersion">The current version of the application   </param>
		/// 
		public void CheckForUpdate(string currentVersion)
		{
			linphone_core_check_for_update(nativePtr, currentVersion);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_clear_all_auth_info(IntPtr thiz);

		/// <summary>
		/// Clear all authentication information. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void ClearAllAuthInfo()
		{
			linphone_core_clear_all_auth_info(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_clear_call_logs(IntPtr thiz);

		/// <summary>
		/// Erase the call log. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void ClearCallLogs()
		{
			linphone_core_clear_call_logs(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_clear_proxy_config(IntPtr thiz);

		/// <summary>
		/// Erase all proxies from config. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void ClearProxyConfig()
		{
			linphone_core_clear_proxy_config(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_account_creator(IntPtr thiz, string xmlrpcUrl);

		/// <summary>
		/// Create a <see cref="Linphone.AccountCreator" /> and set Linphone Request
		/// callbacks. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="xmlrpcUrl">The URL to the XML-RPC server.   </param>
		/// 
		/// 
		/// <returns>The new <see cref="Linphone.AccountCreator" /> object.   </returns>
		public Linphone.AccountCreator CreateAccountCreator(string xmlrpcUrl)
		{
			IntPtr ptr = linphone_core_create_account_creator(nativePtr, xmlrpcUrl);
			Linphone.AccountCreator returnVal = fromNativePtr<Linphone.AccountCreator>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_address(IntPtr thiz, string address);

		/// <summary>
		/// Create a <see cref="Linphone.Address" /> object by parsing the user supplied
		/// address, given as a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">String containing the user supplied address   </param>
		/// 
		/// 
		/// <returns>The create <see cref="Linphone.Address" /> object   </returns>
		public Linphone.Address CreateAddress(string address)
		{
			IntPtr ptr = linphone_core_create_address(nativePtr, address);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_call_log(IntPtr thiz, IntPtr from, IntPtr to, int dir, int duration, long startTime, long connectedTime, int status, char videoEnabled, float quality);

		/// <summary>
		/// Creates a fake <see cref="Linphone.CallLog" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="from"><see cref="Linphone.Address" /> of caller   </param>
		/// <param name="to"><see cref="Linphone.Address" /> of callee   </param>
		/// <param name="dir">LinphoneCallDir of call </param>
		/// <param name="duration">call length in seconds </param>
		/// <param name="startTime">timestamp of call start time </param>
		/// <param name="connectedTime">timestamp of call connection </param>
		/// <param name="status">LinphoneCallStatus of call </param>
		/// <param name="videoEnabled">whether video was enabled or not for this call
		/// </param>
		/// <param name="quality">call quality </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.CallLog" /> object   </returns>
		public Linphone.CallLog CreateCallLog(Linphone.Address from, Linphone.Address to, Linphone.CallDir dir, int duration, long startTime, long connectedTime, Linphone.CallStatus status, bool videoEnabled, float quality)
		{
			IntPtr ptr = linphone_core_create_call_log(nativePtr, from != null ? from.nativePtr : IntPtr.Zero, to != null ? to.nativePtr : IntPtr.Zero, (int)dir, duration, startTime, connectedTime, (int)status, videoEnabled ? (char)1 : (char)0, quality);
			Linphone.CallLog returnVal = fromNativePtr<Linphone.CallLog>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_call_params(IntPtr thiz, IntPtr call);

		/// <summary>
		/// Create a <see cref="Linphone.CallParams" /> suitable for <see
		/// cref="Linphone.Core.InviteWithParams()" />,
		/// linphone_core_accept_call_with_params,
		/// linphone_core_accept_early_media_with_params, linphone_core_accept_call_update. 
		/// <para>
		/// The parameters are initialized according to the current <see
		/// cref="Linphone.Core" /> configuration and the current state of the
		/// LinphoneCall. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="call"><see cref="Linphone.Call" /> for which the parameters are to
		/// be build, or null in the case where the parameters are to be used for a new
		/// outgoing call.   </param>
		/// 
		/// 
		/// <returns>A new <see cref="Linphone.CallParams" /> object.   </returns>
		public Linphone.CallParams CreateCallParams(Linphone.Call call)
		{
			IntPtr ptr = linphone_core_create_call_params(nativePtr, call != null ? call.nativePtr : IntPtr.Zero);
			Linphone.CallParams returnVal = fromNativePtr<Linphone.CallParams>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_chat_room_2(IntPtr thiz, IntPtr parameters, string subject, IntPtr participants);

		/// <summary>
		/// Create a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The chat room creation parameters <see
		/// cref="Linphone.ChatRoomParams" />   </param>
		/// <param name="participants">A list of <see cref="Linphone.Address" /> objects.
		/// LinphoneAddress  The initial list of participants of the chat room   </param>
		/// 
		/// 
		/// <returns>The newly created chat room.   </returns>
		/// 
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()" />
		/// instead
		public Linphone.ChatRoom CreateChatRoom(Linphone.ChatRoomParams parameters, string subject, IEnumerable<Linphone.Address> participants)
		{
			IntPtr ptr = linphone_core_create_chat_room_2(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero, subject, ObjectArrayToBctbxList<Linphone.Address>(participants));
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_chat_room_3(IntPtr thiz, string subject, IntPtr participants);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="subject">The subject of the group chat room   </param>
		/// <param name="participants">A list of <see cref="Linphone.Address" /> objects.
		/// LinphoneAddress  The initial list of participants of the chat room   </param>
		/// 
		/// 
		/// <returns>The newly created chat room.   </returns>
		/// 
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()" />
		/// instead
		public Linphone.ChatRoom CreateChatRoom(string subject, IEnumerable<Linphone.Address> participants)
		{
			IntPtr ptr = linphone_core_create_chat_room_3(nativePtr, subject, ObjectArrayToBctbxList<Linphone.Address>(participants));
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_chat_room_6(IntPtr thiz, IntPtr parameters, IntPtr localAddr, IntPtr participants);

		/// <summary>
		/// Create a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The chat room creation parameters <see
		/// cref="Linphone.ChatRoomParams" />   </param>
		/// <param name="localAddr"><see cref="Linphone.Address" /> representing the local
		/// proxy configuration to use for the chat room creation or null   </param>
		/// <param name="participants">A list of <see cref="Linphone.Address" /> objects.
		/// LinphoneAddress  The initial list of participants of the chat room   </param>
		/// 
		/// 
		/// <returns>The newly created chat room or null.   </returns>
		public Linphone.ChatRoom CreateChatRoom(Linphone.ChatRoomParams parameters, Linphone.Address localAddr, IEnumerable<Linphone.Address> participants)
		{
			IntPtr ptr = linphone_core_create_chat_room_6(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, ObjectArrayToBctbxList<Linphone.Address>(participants));
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_chat_room_4(IntPtr thiz, IntPtr parameters, IntPtr localAddr, IntPtr participant);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The chat room creation parameters <see
		/// cref="Linphone.ChatRoomParams" />   </param>
		/// <param name="localAddr"><see cref="Linphone.Address" /> representing the local
		/// proxy configuration to use for the chat room creation   </param>
		/// <param name="participant"><see cref="Linphone.Address" /> representing the
		/// initial participant to add to the chat room   </param>
		/// 
		/// 
		/// <returns>The newly created chat room.   </returns>
		/// 
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()" />
		/// instead
		public Linphone.ChatRoom CreateChatRoom(Linphone.ChatRoomParams parameters, Linphone.Address localAddr, Linphone.Address participant)
		{
			IntPtr ptr = linphone_core_create_chat_room_4(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, participant != null ? participant.nativePtr : IntPtr.Zero);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_chat_room_5(IntPtr thiz, IntPtr participant);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant"><see cref="Linphone.Address" /> representing the
		/// initial participant to add to the chat room   </param>
		/// 
		/// 
		/// <returns>The newly created chat room.   </returns>
		/// 
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()" />
		/// instead
		public Linphone.ChatRoom CreateChatRoom(Linphone.Address participant)
		{
			IntPtr ptr = linphone_core_create_chat_room_5(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_chat_room(IntPtr thiz, IntPtr parameters, IntPtr localAddr, string subject, IntPtr participants);

		/// <summary>
		/// Create a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The chat room creation parameters <see
		/// cref="Linphone.ChatRoomParams" />   </param>
		/// <param name="localAddr"><see cref="Linphone.Address" /> representing the local
		/// proxy configuration to use for the chat room creation   </param>
		/// <param name="subject">The subject of the group chat room   </param>
		/// <param name="participants">A list of <see cref="Linphone.Address" /> objects.
		/// LinphoneAddress  The initial list of participants of the chat room   </param>
		/// 
		/// 
		/// <returns>The newly created chat room.   </returns>
		/// 
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()" />
		/// instead
		public Linphone.ChatRoom CreateChatRoom(Linphone.ChatRoomParams parameters, Linphone.Address localAddr, string subject, IEnumerable<Linphone.Address> participants)
		{
			IntPtr ptr = linphone_core_create_chat_room(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, subject, ObjectArrayToBctbxList<Linphone.Address>(participants));
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_client_group_chat_room(IntPtr thiz, string subject, char fallback);

		/// <summary>
		/// Create a client-side group chat room. 
		/// <para>
		/// When calling this function the chat room is only created at the client-side and
		/// is empty. You need to call <see cref="Linphone.ChatRoom.AddParticipants()" />
		/// to create at the server side and add participants to it. Also, the created chat
		/// room will not be a one-to-one chat room even if <see
		/// cref="Linphone.ChatRoom.AddParticipants()" /> is called with only one
		/// participant.
		/// 
		/// </para>
		/// </summary>
		/// <param name="subject">The subject of the group chat room   </param>
		/// <param name="fallback">Boolean value telling whether we should plan on being
		/// able to fallback to a basic chat room if the client-side group chat room
		/// creation fails </param>
		/// 
		/// 
		/// <returns>The newly created client-side group chat room.   </returns>
		/// 
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()" />
		/// instead
		public Linphone.ChatRoom CreateClientGroupChatRoom(string subject, bool fallback)
		{
			IntPtr ptr = linphone_core_create_client_group_chat_room(nativePtr, subject, fallback ? (char)1 : (char)0);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_client_group_chat_room_2(IntPtr thiz, string subject, char fallback, char encrypted);

		/// <summary>
		/// Create a client-side group chat room. 
		/// <para>
		/// When calling this function the chat room is only created at the client-side and
		/// is empty. You need to call <see cref="Linphone.ChatRoom.AddParticipants()" />
		/// to create at the server side and add participants to it. Also, the created chat
		/// room will not be a one-to-one chat room even if <see
		/// cref="Linphone.ChatRoom.AddParticipants()" /> is called with only one
		/// participant.
		/// 
		/// </para>
		/// </summary>
		/// <param name="subject">The subject of the group chat room   </param>
		/// <param name="fallback">Boolean value telling whether we should plan on being
		/// able to fallback to a basic chat room if the client-side group chat room
		/// creation fails </param>
		/// <param name="encrypted">Boolean value telling whether we should apply
		/// encryption or not on chat messages sent and received on this room. </param>
		/// 
		/// 
		/// <returns>The newly created client-side group chat room.   </returns>
		/// 
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()" />
		/// instead
		public Linphone.ChatRoom CreateClientGroupChatRoom(string subject, bool fallback, bool encrypted)
		{
			IntPtr ptr = linphone_core_create_client_group_chat_room_2(nativePtr, subject, fallback ? (char)1 : (char)0, encrypted ? (char)1 : (char)0);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_conference_params(IntPtr thiz);

		/// <summary>
		/// Create some default conference parameters for instanciating a a conference with
		/// <see cref="Linphone.Core.CreateConferenceWithParams()" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>conference parameters.   </returns>
		public Linphone.ConferenceParams CreateConferenceParams()
		{
			IntPtr ptr = linphone_core_create_conference_params(nativePtr);
			Linphone.ConferenceParams returnVal = fromNativePtr<Linphone.ConferenceParams>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_conference_with_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Create a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">Parameters of the conference. See <see
		/// cref="Linphone.ConferenceParams" />.   </param>
		/// 
		/// 
		/// <returns>A pointer on the freshly created conference. That object will be
		/// automatically freed by the core after calling <see
		/// cref="Linphone.Core.TerminateConference()" />.   </returns>
		public Linphone.Conference CreateConferenceWithParams(Linphone.ConferenceParams parameters)
		{
			IntPtr ptr = linphone_core_create_conference_with_params(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			Linphone.Conference returnVal = fromNativePtr<Linphone.Conference>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_config(IntPtr thiz, string filename);

		/// <summary>
		/// Create a <see cref="Linphone.Config" /> object from a user config file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filename">The filename of the config file to read to fill the
		/// instantiated <see cref="Linphone.Config" />   </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Config" /> object.   </returns>
		public Linphone.Config CreateConfig(string filename)
		{
			IntPtr ptr = linphone_core_create_config(nativePtr, filename);
			Linphone.Config returnVal = fromNativePtr<Linphone.Config>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_content(IntPtr thiz);

		/// <summary>
		/// Create a content with default values from Linphone core. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.Content" /> object with default values set  
		/// </returns>
		public Linphone.Content CreateContent()
		{
			IntPtr ptr = linphone_core_create_content(nativePtr);
			Linphone.Content returnVal = fromNativePtr<Linphone.Content>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_default_chat_room_params(IntPtr thiz);

		/// <summary>
		/// Creates and returns the default chat room parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.ChatRoomParams" /> object   </returns>
		public Linphone.ChatRoomParams CreateDefaultChatRoomParams()
		{
			IntPtr ptr = linphone_core_create_default_chat_room_params(nativePtr);
			Linphone.ChatRoomParams returnVal = fromNativePtr<Linphone.ChatRoomParams>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_friend(IntPtr thiz);

		/// <summary>
		/// Create a default LinphoneFriend. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The created <see cref="Linphone.Friend" /> object   </returns>
		public Linphone.Friend CreateFriend()
		{
			IntPtr ptr = linphone_core_create_friend(nativePtr);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_friend_list(IntPtr thiz);

		/// <summary>
		/// Create a new empty <see cref="Linphone.FriendList" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A new <see cref="Linphone.FriendList" /> object.   </returns>
		public Linphone.FriendList CreateFriendList()
		{
			IntPtr ptr = linphone_core_create_friend_list(nativePtr);
			Linphone.FriendList returnVal = fromNativePtr<Linphone.FriendList>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_friend_with_address(IntPtr thiz, string address);

		/// <summary>
		/// Create a <see cref="Linphone.Friend" /> from the given address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">A string containing the address to create the <see
		/// cref="Linphone.Friend" /> from   </param>
		/// 
		/// 
		/// <returns>The created <see cref="Linphone.Friend" /> object.   </returns>
		public Linphone.Friend CreateFriendWithAddress(string address)
		{
			IntPtr ptr = linphone_core_create_friend_with_address(nativePtr, address);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_info_message(IntPtr thiz);

		/// <summary>
		/// Creates an empty info message. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a new LinphoneInfoMessage.  </returns>
		/// 
		/// The info message can later be filled with information using <see
		/// cref="Linphone.InfoMessage.AddHeader()" /> or <see
		/// cref="Linphone.InfoMessage.SetContent()" />, and finally sent with
		/// linphone_core_send_info_message(). 
		public Linphone.InfoMessage CreateInfoMessage()
		{
			IntPtr ptr = linphone_core_create_info_message(nativePtr);
			Linphone.InfoMessage returnVal = fromNativePtr<Linphone.InfoMessage>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_local_player(IntPtr thiz, string soundCardName, string videoDisplayName, IntPtr windowId);

		/// <summary>
		/// Create an independent media file player. 
		/// <para>
		/// This player support WAVE and MATROSKA formats. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="soundCardName">Playback sound card. If null, the ringer sound card
		/// set in <see cref="Linphone.Core" /> will be used   </param>
		/// <param name="videoDisplayName">Video display. If null, the video display set in
		/// <see cref="Linphone.Core" /> will be used   </param>
		/// <param name="windowId">Id of the drawing window. Depend of video out   </param>
		/// 
		/// 
		/// <returns>A pointer on the new instance. null if failed.   </returns>
		public Linphone.Player CreateLocalPlayer(string soundCardName, string videoDisplayName, IntPtr windowId)
		{
			IntPtr ptr = linphone_core_create_local_player(nativePtr, soundCardName, videoDisplayName, windowId);
			Linphone.Player returnVal = fromNativePtr<Linphone.Player>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_magic_search(IntPtr thiz);

		/// <summary>
		/// Create a <see cref="Linphone.MagicSearch" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The created <see cref="Linphone.MagicSearch" /> object   </returns>
		public Linphone.MagicSearch CreateMagicSearch()
		{
			IntPtr ptr = linphone_core_create_magic_search(nativePtr);
			Linphone.MagicSearch returnVal = fromNativePtr<Linphone.MagicSearch>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_nat_policy(IntPtr thiz);

		/// <summary>
		/// Create a new <see cref="Linphone.NatPolicy" /> object with every policies being
		/// disabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A new <see cref="Linphone.NatPolicy" /> object.   </returns>
		public Linphone.NatPolicy CreateNatPolicy()
		{
			IntPtr ptr = linphone_core_create_nat_policy(nativePtr);
			Linphone.NatPolicy returnVal = fromNativePtr<Linphone.NatPolicy>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_nat_policy_from_config(IntPtr thiz, string reference);

		/// <summary>
		/// Create a new <see cref="Linphone.NatPolicy" /> by reading the config of a <see
		/// cref="Linphone.Core" /> according to the passed ref. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="reference">The reference of a NAT policy in the config of the <see
		/// cref="Linphone.Core" />   </param>
		/// 
		/// 
		/// <returns>A new <see cref="Linphone.NatPolicy" /> object.   </returns>
		public Linphone.NatPolicy CreateNatPolicyFromConfig(string reference)
		{
			IntPtr ptr = linphone_core_create_nat_policy_from_config(nativePtr, reference);
			Linphone.NatPolicy returnVal = fromNativePtr<Linphone.NatPolicy>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_notify(IntPtr thiz, IntPtr resource, string ev);

		/// <summary>
		/// Create an out-of-dialog notification, specifying the destination resource, the
		/// event name. 
		/// <para>
		/// The notification can be send with <see cref="Linphone.Event.Notify()" />. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="resource">the destination resource   </param>
		/// <param name="ev">the event name   </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Event" /> holding the context of the
		/// notification.   </returns>
		public Linphone.Event CreateNotify(Linphone.Address resource, string ev)
		{
			IntPtr ptr = linphone_core_create_notify(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, ev);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_one_shot_publish(IntPtr thiz, IntPtr resource, string ev);

		/// <summary>
		/// Create a publish context for a one-shot publish. 
		/// <para>
		/// After being created, the publish must be sent using <see
		/// cref="Linphone.Event.SendPublish()" />. The <see cref="Linphone.Event" /> is
		/// automatically terminated when the publish transaction is finished, either with
		/// success or failure. The application must not call <see
		/// cref="Linphone.Event.Terminate()" /> for such one-shot publish. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="resource">the resource uri for the event   </param>
		/// <param name="ev">the event name   </param>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Event" /> holding the context of the publish. 
		///  </returns>
		public Linphone.Event CreateOneShotPublish(Linphone.Address resource, string ev)
		{
			IntPtr ptr = linphone_core_create_one_shot_publish(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, ev);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_activity(IntPtr thiz, int acttype, string description);

		/// <summary>
		/// Create a <see cref="Linphone.PresenceActivity" /> with the given type and
		/// description. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="acttype">The LinphonePresenceActivityType to set for the activity.
		/// </param>
		/// <param name="description">An additional description of the activity to set for
		/// the activity. Can be null if no additional description is to be added.  
		/// </param>
		/// 
		/// 
		/// <returns>The created <see cref="Linphone.PresenceActivity" /> object.  
		/// </returns>
		public Linphone.PresenceActivity CreatePresenceActivity(Linphone.PresenceActivityType acttype, string description)
		{
			IntPtr ptr = linphone_core_create_presence_activity(nativePtr, (int)acttype, description);
			Linphone.PresenceActivity returnVal = fromNativePtr<Linphone.PresenceActivity>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_model(IntPtr thiz);

		/// <summary>
		/// Create a default LinphonePresenceModel. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The created <see cref="Linphone.PresenceModel" /> object.   </returns>
		public Linphone.PresenceModel CreatePresenceModel()
		{
			IntPtr ptr = linphone_core_create_presence_model(nativePtr);
			Linphone.PresenceModel returnVal = fromNativePtr<Linphone.PresenceModel>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_model_with_activity(IntPtr thiz, int acttype, string description);

		/// <summary>
		/// Create a <see cref="Linphone.PresenceModel" /> with the given activity type and
		/// activity description. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="acttype">The LinphonePresenceActivityType to set for the activity
		/// of the created model. </param>
		/// <param name="description">An additional description of the activity to set for
		/// the activity. Can be null if no additional description is to be added.  
		/// </param>
		/// 
		/// 
		/// <returns>The created <see cref="Linphone.PresenceModel" /> object.   </returns>
		public Linphone.PresenceModel CreatePresenceModelWithActivity(Linphone.PresenceActivityType acttype, string description)
		{
			IntPtr ptr = linphone_core_create_presence_model_with_activity(nativePtr, (int)acttype, description);
			Linphone.PresenceModel returnVal = fromNativePtr<Linphone.PresenceModel>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_model_with_activity_and_note(IntPtr thiz, int acttype, string description, string note, string lang);

		/// <summary>
		/// Create a <see cref="Linphone.PresenceModel" /> with the given activity type,
		/// activity description, note content and note language. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="acttype">The LinphonePresenceActivityType to set for the activity
		/// of the created model. </param>
		/// <param name="description">An additional description of the activity to set for
		/// the activity. Can be null if no additional description is to be added.  
		/// </param>
		/// <param name="note">The content of the note to be added to the created model.  
		/// </param>
		/// <param name="lang">The language of the note to be added to the created model.  
		/// </param>
		/// 
		/// 
		/// <returns>The created <see cref="Linphone.PresenceModel" /> object.   </returns>
		public Linphone.PresenceModel CreatePresenceModelWithActivityAndNote(Linphone.PresenceActivityType acttype, string description, string note, string lang)
		{
			IntPtr ptr = linphone_core_create_presence_model_with_activity_and_note(nativePtr, (int)acttype, description, note, lang);
			Linphone.PresenceModel returnVal = fromNativePtr<Linphone.PresenceModel>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_note(IntPtr thiz, string content, string lang);

		/// <summary>
		/// Create a <see cref="Linphone.PresenceNote" /> with the given content and
		/// language. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">The content of the note to be created.   </param>
		/// <param name="lang">The language of the note to be created.   </param>
		/// 
		/// 
		/// <returns>The created <see cref="Linphone.PresenceNote" /> object.   </returns>
		public Linphone.PresenceNote CreatePresenceNote(string content, string lang)
		{
			IntPtr ptr = linphone_core_create_presence_note(nativePtr, content, lang);
			Linphone.PresenceNote returnVal = fromNativePtr<Linphone.PresenceNote>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_person(IntPtr thiz, string id);

		/// <summary>
		/// Create a <see cref="Linphone.PresencePerson" /> with the given id. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="id">The id of the person to be created.   </param>
		/// 
		/// 
		/// <returns>The created <see cref="Linphone.PresencePerson" /> object.   </returns>
		public Linphone.PresencePerson CreatePresencePerson(string id)
		{
			IntPtr ptr = linphone_core_create_presence_person(nativePtr, id);
			Linphone.PresencePerson returnVal = fromNativePtr<Linphone.PresencePerson>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_service(IntPtr thiz, string id, int basicStatus, string contact);

		/// <summary>
		/// Create a <see cref="Linphone.PresenceService" /> with the given id, basic
		/// status and contact. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="id">The id of the service to be created.   </param>
		/// <param name="basicStatus">The basic status of the service to be created.
		/// </param>
		/// <param name="contact">A string containing a contact information corresponding
		/// to the service to be created.   </param>
		/// 
		/// 
		/// <returns>The created <see cref="Linphone.PresenceService" /> object.  
		/// </returns>
		public Linphone.PresenceService CreatePresenceService(string id, Linphone.PresenceBasicStatus basicStatus, string contact)
		{
			IntPtr ptr = linphone_core_create_presence_service(nativePtr, id, (int)basicStatus, contact);
			Linphone.PresenceService returnVal = fromNativePtr<Linphone.PresenceService>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_primary_contact_parsed(IntPtr thiz);

		/// <summary>
		/// Same as <see cref="Linphone.Core.GetPrimaryContact()" /> but the result is a
		/// <see cref="Linphone.Address" /> object instead of const char *. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Address" /> object.   </returns>
		public Linphone.Address CreatePrimaryContactParsed()
		{
			IntPtr ptr = linphone_core_create_primary_contact_parsed(nativePtr);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_proxy_config(IntPtr thiz);

		/// <summary>
		/// Create a proxy config with default values from Linphone core. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.ProxyConfig" /> with default values set  
		/// </returns>
		public Linphone.ProxyConfig CreateProxyConfig()
		{
			IntPtr ptr = linphone_core_create_proxy_config(nativePtr);
			Linphone.ProxyConfig returnVal = fromNativePtr<Linphone.ProxyConfig>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_publish(IntPtr thiz, IntPtr resource, string ev, int expires);

		/// <summary>
		/// Create a publish context for an event state. 
		/// <para>
		/// After being created, the publish must be sent using <see
		/// cref="Linphone.Event.SendPublish()" />. After expiry, the publication is
		/// refreshed unless it is terminated before. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="resource">the resource uri for the event   </param>
		/// <param name="ev">the event name   </param>
		/// <param name="expires">the lifetime of event being published, -1 if no
		/// associated duration, in which case it will not be refreshed. </param>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Event" /> holding the context of the publish. 
		///  </returns>
		public Linphone.Event CreatePublish(Linphone.Address resource, string ev, int expires)
		{
			IntPtr ptr = linphone_core_create_publish(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, ev, expires);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_subscribe_2(IntPtr thiz, IntPtr resource, IntPtr proxy, string ev, int expires);

		/// <summary>
		/// Create an outgoing subscription, specifying the destination resource, the event
		/// name, and an optional content body. 
		/// <para>
		/// If accepted, the subscription runs for a finite period, but is automatically
		/// renewed if not terminated before. Unlike <see cref="Linphone.Core.Subscribe()"
		/// /> the subscription isn't sent immediately. It will be send when calling <see
		/// cref="Linphone.Event.SendSubscribe()" />. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="resource">the destination resource   </param>
		/// <param name="proxy">the proxy configuration to use   </param>
		/// <param name="ev">the event name   </param>
		/// <param name="expires">the whished duration of the subscription </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Event" /> holding the context of the created
		/// subcription.   </returns>
		public Linphone.Event CreateSubscribe(Linphone.Address resource, Linphone.ProxyConfig proxy, string ev, int expires)
		{
			IntPtr ptr = linphone_core_create_subscribe_2(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, proxy != null ? proxy.nativePtr : IntPtr.Zero, ev, expires);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_subscribe(IntPtr thiz, IntPtr resource, string ev, int expires);

		/// <summary>
		/// Create an outgoing subscription, specifying the destination resource, the event
		/// name, and an optional content body. 
		/// <para>
		/// If accepted, the subscription runs for a finite period, but is automatically
		/// renewed if not terminated before. Unlike <see cref="Linphone.Core.Subscribe()"
		/// /> the subscription isn't sent immediately. It will be send when calling <see
		/// cref="Linphone.Event.SendSubscribe()" />. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="resource">the destination resource   </param>
		/// <param name="ev">the event name   </param>
		/// <param name="expires">the whished duration of the subscription </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Event" /> holding the context of the created
		/// subcription.   </returns>
		public Linphone.Event CreateSubscribe(Linphone.Address resource, string ev, int expires)
		{
			IntPtr ptr = linphone_core_create_subscribe(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, ev, expires);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_xml_rpc_session(IntPtr thiz, string url);

		/// <summary>
		/// Create a <see cref="Linphone.XmlRpcSession" /> for a given url. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="url">The URL to the XML-RPC server. Must be NON null.   </param>
		/// 
		/// 
		/// <returns>The new <see cref="Linphone.XmlRpcSession" /> object.   </returns>
		public Linphone.XmlRpcSession CreateXmlRpcSession(string url)
		{
			IntPtr ptr = linphone_core_create_xml_rpc_session(nativePtr, url);
			Linphone.XmlRpcSession returnVal = fromNativePtr<Linphone.XmlRpcSession>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_delete_chat_room(IntPtr thiz, IntPtr chatRoom);

		/// <summary>
		/// Removes a chatroom including all message history from the LinphoneCore. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">A <see cref="Linphone.ChatRoom" /> object   </param>
		/// 
		public void DeleteChatRoom(Linphone.ChatRoom chatRoom)
		{
			linphone_core_delete_chat_room(nativePtr, chatRoom != null ? chatRoom.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_disable_chat(IntPtr thiz, int denyReason);

		/// <summary>
		/// Inconditionnaly disable incoming chat messages. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="denyReason">the deny reason (LinphoneReasonNone has no effect).
		/// </param>
		/// 
		public void DisableChat(Linphone.Reason denyReason)
		{
			linphone_core_disable_chat(nativePtr, (int)denyReason);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_chat(IntPtr thiz);

		/// <summary>
		/// Enable reception of incoming chat messages. 
		/// <para>
		/// By default it is enabled but it can be disabled with <see
		/// cref="Linphone.Core.DisableChat()" />. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void EnableChat()
		{
			linphone_core_enable_chat(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_lime(IntPtr thiz, int enable);

		/// <summary>
		/// Tells to <see cref="Linphone.Core" /> to use Linphone Instant Messaging
		/// encryption. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="enable">The new lime state</param>
		/// 
		/// 
		/// deprecated : 04/02/2019 Use linphone_core_enable_lime_x3dh instead. 
		public void EnableLime(Linphone.LimeState enable)
		{
			linphone_core_enable_lime(nativePtr, (int)enable);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_ensure_registered(IntPtr thiz);

		/// <summary>
		/// Call this method when you receive a push notification (if you handle push
		/// notifications manually). 
		/// <para>
		/// It will ensure the proxy configs are correctly registered to the proxy server,
		/// so the call or the message will be correctly delivered. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void EnsureRegistered()
		{
			linphone_core_ensure_registered(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enter_background(IntPtr thiz);

		/// <summary>
		/// This method is called by the application to notify the linphone core library
		/// when it enters background mode. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void EnterBackground()
		{
			linphone_core_enter_background(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_enter_conference(IntPtr thiz);

		/// <summary>
		/// Join the local participant to the running conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if succeeded. Negative number if failed </returns>
		public void EnterConference()
		{
			int exception_result = linphone_core_enter_conference(nativePtr);
			if (exception_result != 0) throw new LinphoneException("EnterConference returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enter_foreground(IntPtr thiz);

		/// <summary>
		/// This method is called by the application to notify the linphone core library
		/// when it enters foreground mode. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void EnterForeground()
		{
			linphone_core_enter_foreground(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_file_format_supported(IntPtr thiz, string fmt);

		/// <summary>
		/// Returns whether a specific file format is supported. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>See : linphone_core_get_supported_file_formats </remarks>
		/// 
		/// <param name="fmt">The format extension (wav, mkv).   </param>
		/// 
		/// 
		/// <returns>true if the file format is supported, false otherwise </returns>
		public bool FileFormatSupported(string fmt)
		{
			bool returnVal = linphone_core_file_format_supported(nativePtr, fmt) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_auth_info(IntPtr thiz, string realm, string username, string sipDomain);

		/// <summary>
		/// Find authentication info matching realm, username, domain criteria. 
		/// <para>
		/// First of all, (realm,username) pair are searched. If multiple results (which
		/// should not happen because realm are supposed to be unique), then domain is
		/// added to the search. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="realm">the authentication 'realm' (optional)   </param>
		/// <param name="username">the SIP username to be authenticated (mandatory)  
		/// </param>
		/// <param name="sipDomain">the SIP domain name (optional)   </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.AuthInfo" /> if found.   </returns>
		public Linphone.AuthInfo FindAuthInfo(string realm, string username, string sipDomain)
		{
			IntPtr ptr = linphone_core_find_auth_info(nativePtr, realm, username, sipDomain);
			Linphone.AuthInfo returnVal = fromNativePtr<Linphone.AuthInfo>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_call_from_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Search from the list of current calls if a remote address match uri. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">which should match call remote uri   </param>
		/// 
		/// 
		/// <returns><see cref="Linphone.Call" /> or null is no match is found.   </returns>
		/// 
		/// deprecated : 27/10/2020. Use <see
		/// cref="Linphone.Core.GetCallByRemoteAddress2()" /> instead. 
		public Linphone.Call FindCallFromUri(string uri)
		{
			IntPtr ptr = linphone_core_find_call_from_uri(nativePtr, uri);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_call_log_from_call_id(IntPtr thiz, string callId);

		/// <summary>
		/// Get the call log matching the call id, or null if can't be found. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="callId">Call id of the call log to find   </param>
		/// 
		/// 
		/// <returns>A call log matching the call id if any.   </returns>
		public Linphone.CallLog FindCallLogFromCallId(string callId)
		{
			IntPtr ptr = linphone_core_find_call_log_from_call_id(nativePtr, callId);
			Linphone.CallLog returnVal = fromNativePtr<Linphone.CallLog>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_chat_room(IntPtr thiz, IntPtr peerAddr, IntPtr localAddr);

		/// <summary>
		/// Find a chat room. 
		/// <para>
		/// No reference is transfered to the application. The <see cref="Linphone.Core" />
		/// keeps a reference on the chat room. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="peerAddr">a linphone address.   </param>
		/// <param name="localAddr">a linphone address.   </param>
		/// 
		/// 
		/// <returns><see cref="Linphone.ChatRoom" /> where messaging can take place.  
		/// </returns>
		/// 
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.SearchChatRoom()" />
		/// instead
		public Linphone.ChatRoom FindChatRoom(Linphone.Address peerAddr, Linphone.Address localAddr)
		{
			IntPtr ptr = linphone_core_find_chat_room(nativePtr, peerAddr != null ? peerAddr.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_contacts_by_char(IntPtr thiz, string filter, char sipOnly);

		/// <summary>
		/// Retrieves a list of <see cref="Linphone.Address" /> sort and filter. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filter">Chars used for the filter*   </param>
		/// <param name="sipOnly">Only sip address or not </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Address" /> objects. LinphoneAddress  a
		/// list of filtered <see cref="Linphone.Address" /> + the <see
		/// cref="Linphone.Address" /> created with the filter.   </returns>
		public IEnumerable<Linphone.Address> FindContactsByChar(string filter, bool sipOnly)
		{
			IEnumerable<Linphone.Address> returnVal = MarshalBctbxList<Linphone.Address>(linphone_core_find_contacts_by_char(nativePtr, filter, sipOnly ? (char)1 : (char)0), true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_friend(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Search a <see cref="Linphone.Friend" /> by its address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">The <see cref="Linphone.Address" /> to use to search the
		/// friend.   </param>
		/// 
		/// 
		/// <returns>The <see cref="Linphone.Friend" /> object corresponding to the given
		/// address or null if not found.   </returns>
		public Linphone.Friend FindFriend(Linphone.Address address)
		{
			IntPtr ptr = linphone_core_find_friend(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_friend_by_phone_number(IntPtr thiz, string phoneNumber);

		/// <summary>
		/// Search a <see cref="Linphone.Friend" /> by its phone number. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">The phone number to use to search the friend.  
		/// </param>
		/// 
		/// 
		/// <returns>The <see cref="Linphone.Friend" /> object corresponding to the given
		/// phone number or null if not found.   </returns>
		public Linphone.Friend FindFriendByPhoneNumber(string phoneNumber)
		{
			IntPtr ptr = linphone_core_find_friend_by_phone_number(nativePtr, phoneNumber);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_friends(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Search all <see cref="Linphone.Friend" /> matching an address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">The address to use to search the friends.   </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Friend" /> objects. LinphoneFriend  a
		/// list of <see cref="Linphone.Friend" /> corresponding to the given address.  
		/// </returns>
		public IEnumerable<Linphone.Friend> FindFriends(Linphone.Address address)
		{
			IEnumerable<Linphone.Friend> returnVal = MarshalBctbxList<Linphone.Friend>(linphone_core_find_friends(nativePtr, address != null ? address.nativePtr : IntPtr.Zero), true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_one_to_one_chat_room_2(IntPtr thiz, IntPtr localAddr, IntPtr participantAddr, char encrypted);

		/// <summary>
		/// Find a one to one chat room. 
		/// <para>
		/// No reference is transfered to the application. The <see cref="Linphone.Core" />
		/// keeps a reference on the chat room. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="localAddr">a linphone address.   </param>
		/// <param name="participantAddr">a linphone address.   </param>
		/// <param name="encrypted">whether to look for an encrypted chat room or not
		/// </param>
		/// 
		/// 
		/// <returns><see cref="Linphone.ChatRoom" /> where messaging can take place.  
		/// </returns>
		/// 
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.SearchChatRoom()" />
		/// instead
		public Linphone.ChatRoom FindOneToOneChatRoom(Linphone.Address localAddr, Linphone.Address participantAddr, bool encrypted)
		{
			IntPtr ptr = linphone_core_find_one_to_one_chat_room_2(nativePtr, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, participantAddr != null ? participantAddr.nativePtr : IntPtr.Zero, encrypted ? (char)1 : (char)0);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_one_to_one_chat_room(IntPtr thiz, IntPtr localAddr, IntPtr participantAddr);

		/// <summary>
		/// Find a one to one chat room. 
		/// <para>
		/// No reference is transfered to the application. The <see cref="Linphone.Core" />
		/// keeps a reference on the chat room. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="localAddr">a linphone address.   </param>
		/// <param name="participantAddr">a linphone address.   </param>
		/// 
		/// 
		/// <returns><see cref="Linphone.ChatRoom" /> where messaging can take place.  
		/// </returns>
		/// 
		/// deprecated : 12/12/2018, use linphone_core_find_one_to_one_chat_room_2 instead
		public Linphone.ChatRoom FindOneToOneChatRoom(Linphone.Address localAddr, Linphone.Address participantAddr)
		{
			IntPtr ptr = linphone_core_find_one_to_one_chat_room(nativePtr, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, participantAddr != null ? participantAddr.nativePtr : IntPtr.Zero);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_by_callid(IntPtr thiz, string callId);

		/// <summary>
		/// Get the call by callid. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>call <see cref="Linphone.Call" />, return null if there is no call
		/// find.   </returns>
		public Linphone.Call GetCallByCallid(string callId)
		{
			IntPtr ptr = linphone_core_get_call_by_callid(nativePtr, callId);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_by_remote_address(IntPtr thiz, string remoteAddress);

		/// <summary>
		/// Get the call with the remote_address specified. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="remoteAddress">The remote address of the call that we want to get 
		///  </param>
		/// 
		/// 
		/// <returns>The call if it has been found, null otherwise.  </returns>
		/// 
		/// deprecated : 08/07/2020 use <see cref="Linphone.Core.GetCallByRemoteAddress2()"
		/// /> instead 
		public Linphone.Call GetCallByRemoteAddress(string remoteAddress)
		{
			IntPtr ptr = linphone_core_get_call_by_remote_address(nativePtr, remoteAddress);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_by_remote_address2(IntPtr thiz, IntPtr remoteAddress);

		/// <summary>
		/// Get the call with the specified <see cref="Linphone.Address" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="remoteAddress">the <see cref="Linphone.Address" /> for which the
		/// call remote address must match   </param>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Call" /> of the call if found.   </returns>
		public Linphone.Call GetCallByRemoteAddress2(Linphone.Address remoteAddress)
		{
			IntPtr ptr = linphone_core_get_call_by_remote_address2(nativePtr, remoteAddress != null ? remoteAddress.nativePtr : IntPtr.Zero);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_history_2(IntPtr thiz, IntPtr peerAddress, IntPtr localAddress);

		/// <summary>
		/// Get the list of call logs (past calls). 
		/// <para>
		/// At the contrary of linphone_core_get_call_logs, it is your responsibility to
		/// unref the logs and free this list once you are done using it. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="peerAddress">The remote <see cref="Linphone.Address" /> object.  
		/// </param>
		/// <param name="localAddress">The local <see cref="Linphone.Address" /> object  
		/// </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.CallLog" /> objects. LinphoneCallLog    
		///  </returns>
		public IEnumerable<Linphone.CallLog> GetCallHistory(Linphone.Address peerAddress, Linphone.Address localAddress)
		{
			IEnumerable<Linphone.CallLog> returnVal = MarshalBctbxList<Linphone.CallLog>(linphone_core_get_call_history_2(nativePtr, peerAddress != null ? peerAddress.nativePtr : IntPtr.Zero, localAddress != null ? localAddress.nativePtr : IntPtr.Zero), false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_history_for_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Get the list of call logs (past calls) that matches the given <see
		/// cref="Linphone.Address" />. 
		/// <para>
		/// At the contrary of linphone_core_get_call_logs, it is your responsibility to
		/// unref the logs and free this list once you are done using it. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address" /> object   </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.CallLog" /> objects. LinphoneCallLog    
		///  </returns>
		/// 
		/// deprecated : 29/10/2018 Use linphone_core_get_call_history_2 instead.
		public IEnumerable<Linphone.CallLog> GetCallHistoryForAddress(Linphone.Address address)
		{
			IEnumerable<Linphone.CallLog> returnVal = MarshalBctbxList<Linphone.CallLog>(linphone_core_get_call_history_for_address(nativePtr, address != null ? address.nativePtr : IntPtr.Zero), false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_chat_room_2(IntPtr thiz, IntPtr peerAddr, IntPtr localAddr);

		/// <summary>
		/// Get a chat room. 
		/// <para>
		/// If it does not exist yet, it will be created as a basic chat room. No reference
		/// is transfered to the application. The <see cref="Linphone.Core" /> keeps a
		/// reference on the chat room. </para>
		/// </summary>
		/// <remarks>Warning : This method is prone to errors, use <see
		/// cref="Linphone.Core.SearchChatRoom()" /> instead </remarks> 
		/// 
		/// <param name="peerAddr">a linphone address.   </param>
		/// <param name="localAddr">a linphone address.   </param>
		/// 
		/// 
		/// <returns><see cref="Linphone.ChatRoom" /> where messaging can take place.  
		/// </returns>
		/// 
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.SearchChatRoom()" />
		/// instead
		public Linphone.ChatRoom GetChatRoom(Linphone.Address peerAddr, Linphone.Address localAddr)
		{
			IntPtr ptr = linphone_core_get_chat_room_2(nativePtr, peerAddr != null ? peerAddr.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_chat_room(IntPtr thiz, IntPtr addr);

		/// <summary>
		/// Get a chat room whose peer is the supplied address. 
		/// <para>
		/// If it does not exist yet, it will be created as a basic chat room. No reference
		/// is transfered to the application. The <see cref="Linphone.Core" /> keeps a
		/// reference on the chat room. </para>
		/// </summary>
		/// <remarks>Warning : This method is prone to errors, use <see
		/// cref="Linphone.Core.SearchChatRoom()" /> instead </remarks> 
		/// 
		/// <param name="addr">a linphone address.   </param>
		/// 
		/// 
		/// <returns><see cref="Linphone.ChatRoom" /> where messaging can take place.  
		/// </returns>
		/// 
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.SearchChatRoom()" />
		/// instead
		public Linphone.ChatRoom GetChatRoom(Linphone.Address addr)
		{
			IntPtr ptr = linphone_core_get_chat_room(nativePtr, addr != null ? addr.nativePtr : IntPtr.Zero);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_chat_room_from_uri(IntPtr thiz, string to);

		/// <summary>
		/// Get a chat room for messaging from a sip uri like sip:joe@sip.linphone.org. 
		/// <para>
		/// If it does not exist yet, it will be created as a basic chat room. No reference
		/// is transfered to the application. The <see cref="Linphone.Core" /> keeps a
		/// reference on the chat room. </para>
		/// </summary>
		/// <remarks>Warning : This method is prone to errors, use <see
		/// cref="Linphone.Core.SearchChatRoom()" /> instead </remarks> 
		/// 
		/// <param name="to">The destination address for messages.   </param>
		/// 
		/// 
		/// <returns><see cref="Linphone.ChatRoom" /> where messaging can take place.  
		/// </returns>
		/// 
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.SearchChatRoom()" />
		/// instead
		public Linphone.ChatRoom GetChatRoomFromUri(string to)
		{
			IntPtr ptr = linphone_core_get_chat_room_from_uri(nativePtr, to);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_friend_by_ref_key(IntPtr thiz, string key);

		/// <summary>
		/// Search a <see cref="Linphone.Friend" /> by its reference key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The reference key to use to search the friend.   </param>
		/// 
		/// 
		/// <returns>The <see cref="Linphone.Friend" /> object corresponding to the given
		/// reference key.   </returns>
		public Linphone.Friend GetFriendByRefKey(string key)
		{
			IntPtr ptr = linphone_core_get_friend_by_ref_key(nativePtr, key);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_friend_list_by_name(IntPtr thiz, string name);

		/// <summary>
		/// Retrieves the list of <see cref="Linphone.Friend" /> from the core that has the
		/// given display name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the name of the list   </param>
		/// 
		/// 
		/// <returns>the first <see cref="Linphone.FriendList" /> object or null.  
		/// </returns>
		public Linphone.FriendList GetFriendListByName(string name)
		{
			IntPtr ptr = linphone_core_get_friend_list_by_name(nativePtr, name);
			Linphone.FriendList returnVal = fromNativePtr<Linphone.FriendList>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_payload_type(IntPtr thiz, string type, int rate, int channels);

		/// <summary>
		/// Get payload type from mime type and clock rate. 
		/// <para>
		/// This function searches in audio and video codecs for the given payload type
		/// name and clockrate. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="type">payload mime type (I.E SPEEX, PCMU, VP8)   </param>
		/// <param name="rate">can be LINPHONE_FIND_PAYLOAD_IGNORE_RATE </param>
		/// <param name="channels">number of channels, can be
		/// LINPHONE_FIND_PAYLOAD_IGNORE_CHANNELS </param>
		/// 
		/// 
		/// <returns>Returns null if not found. If a <see cref="Linphone.PayloadType" /> is
		/// returned, it must be released with linphone_payload_type_unref after using it. 
		///  </returns>
		/// 
		/// <remarks>Warning : The returned payload type is allocated as a floating
		/// reference i.e. the reference counter is initialized to 0. </remarks> 
		public Linphone.PayloadType GetPayloadType(string type, int rate, int channels)
		{
			IntPtr ptr = linphone_core_get_payload_type(nativePtr, type, rate, channels);
			Linphone.PayloadType returnVal = fromNativePtr<Linphone.PayloadType>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_proxy_config_by_idkey(IntPtr thiz, string idkey);

		/// <summary>
		/// Search for a <see cref="Linphone.ProxyConfig" /> by it's idkey. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="idkey">An arbitrary idkey string associated to a proxy
		/// configuration </param>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.ProxyConfig" /> object for the given idkey
		/// value, or null if none found   </returns>
		public Linphone.ProxyConfig GetProxyConfigByIdkey(string idkey)
		{
			IntPtr ptr = linphone_core_get_proxy_config_by_idkey(nativePtr, idkey);
			Linphone.ProxyConfig returnVal = fromNativePtr<Linphone.ProxyConfig>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_unread_chat_message_count_from_local(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Return the unread chat message count for a given local address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address" /> object.   </param>
		/// 
		/// 
		/// <returns>The unread chat message count. </returns>
		public int GetUnreadChatMessageCountFromLocal(Linphone.Address address)
		{
			int returnVal = linphone_core_get_unread_chat_message_count_from_local(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ZrtpPeerStatus linphone_core_get_zrtp_status(IntPtr thiz, string addr);

		/// <summary>
		/// Get the zrtp sas validation status for a peer uri. 
		/// <para>
		/// Once the SAS has been validated or rejected, the status will never return to
		/// Unknown (unless you delete your cache) 
		/// 
		/// </para>
		/// </summary>
		/// <param name="addr">the peer uri  </param>
		/// 
		/// 
		/// <returns>- LinphoneZrtpPeerStatusUnknown: this uri is not present in cache OR
		/// during calls with the active device, SAS never was validated or rejected
		/// </returns>
		public Linphone.ZrtpPeerStatus GetZrtpStatus(string addr)
		{
			Linphone.ZrtpPeerStatus returnVal = linphone_core_get_zrtp_status(nativePtr, addr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_has_builtin_echo_canceller(IntPtr thiz);

		/// <summary>
		/// Check whether the device has a hardware echo canceller. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if it does, false otherwise </returns>
		public bool HasBuiltinEchoCanceller()
		{
			bool returnVal = linphone_core_has_builtin_echo_canceller(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_has_crappy_opengl(IntPtr thiz);

		/// <summary>
		/// Check whether the device is flagged has crappy opengl. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if crappy opengl flag is set, false otherwise </returns>
		public bool HasCrappyOpengl()
		{
			bool returnVal = linphone_core_has_crappy_opengl(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_in_call(IntPtr thiz);

		/// <summary>
		/// Tells whether there is a call running. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether a call is currently running or not
		/// </returns>
		public bool InCall()
		{
			bool returnVal = linphone_core_in_call(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_interpret_url(IntPtr thiz, string url);

		/// <summary>
		/// Constructs a <see cref="Linphone.Address" /> from the given string if possible. 
		/// <para>
		/// In case of just a username, characters will be unescaped. If a phone number is
		/// detected, it will be flattened. sip: or sips: prefix will be added if not
		/// present. Finally, @domain will be added if not present using default proxy
		/// config. </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.ProxyConfig.NormalizeSipUri()" /> for
		/// documentation. </remarks>
		/// 
		/// <param name="url">the url to parse   </param>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Address" /> matching the url or null in case
		/// of failure.   </returns>
		public Linphone.Address InterpretUrl(string url)
		{
			IntPtr ptr = linphone_core_interpret_url(nativePtr, url);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_invite(IntPtr thiz, string url);

		/// <summary>
		/// Initiates an outgoing call. 
		/// <para>
		/// The application doesn't own a reference to the returned LinphoneCall object.
		/// Use linphone_call_ref to safely keep the LinphoneCall pointer valid within your
		/// application.
		/// 
		/// </para>
		/// </summary>
		/// <param name="url">The destination of the call (sip address, or phone number).  
		/// </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Call" /> object or null in case of failure.  
		/// </returns>
		public Linphone.Call Invite(string url)
		{
			IntPtr ptr = linphone_core_invite(nativePtr, url);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_invite_address(IntPtr thiz, IntPtr addr);

		/// <summary>
		/// Initiates an outgoing call given a destination <see cref="Linphone.Address" />
		/// The <see cref="Linphone.Address" /> can be constructed directly using
		/// linphone_address_new, or created by <see cref="Linphone.Core.InterpretUrl()"
		/// />. 
		/// <para>
		/// The application doesn't own a reference to the returned <see
		/// cref="Linphone.Call" /> object. Use linphone_call_ref to safely keep the <see
		/// cref="Linphone.Call" /> pointer valid within your application. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="addr">The destination of the call (sip address).   </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Call" /> object or null in case of failure.  
		/// </returns>
		public Linphone.Call InviteAddress(Linphone.Address addr)
		{
			IntPtr ptr = linphone_core_invite_address(nativePtr, addr != null ? addr.nativePtr : IntPtr.Zero);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_invite_address_with_params(IntPtr thiz, IntPtr addr, IntPtr parameters);

		/// <summary>
		/// Initiates an outgoing call given a destination <see cref="Linphone.Address" />
		/// The <see cref="Linphone.Address" /> can be constructed directly using
		/// linphone_address_new, or created by <see cref="Linphone.Core.InterpretUrl()"
		/// />. 
		/// <para>
		/// The application doesn't own a reference to the returned <see
		/// cref="Linphone.Call" /> object. Use linphone_call_ref to safely keep the <see
		/// cref="Linphone.Call" /> pointer valid within your application. If the proxy is
		/// not specified in parameters, the caller proxy will be automatically selected by
		/// finding what is the best to reach the destination of the call. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="addr">The destination of the call (sip address).   </param>
		/// <param name="parameters">Call parameters   </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Call" /> object or null in case of failure.  
		/// </returns>
		public Linphone.Call InviteAddressWithParams(Linphone.Address addr, Linphone.CallParams parameters)
		{
			IntPtr ptr = linphone_core_invite_address_with_params(nativePtr, addr != null ? addr.nativePtr : IntPtr.Zero, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_invite_with_params(IntPtr thiz, string url, IntPtr parameters);

		/// <summary>
		/// Initiates an outgoing call according to supplied call parameters The
		/// application doesn't own a reference to the returned <see cref="Linphone.Call"
		/// /> object. 
		/// <para>
		/// Use linphone_call_ref to safely keep the <see cref="Linphone.Call" /> pointer
		/// valid within your application. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="url">The destination of the call (sip address, or phone number).  
		/// </param>
		/// <param name="parameters">the <see cref="Linphone.CallParams" /> call parameters
		///   </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Call" /> object or null in case of failure.  
		/// </returns>
		public Linphone.Call InviteWithParams(string url, Linphone.CallParams parameters)
		{
			IntPtr ptr = linphone_core_invite_with_params(nativePtr, url, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_media_filter_supported(IntPtr thiz, string filtername);

		/// <summary>
		/// Checks if the given media filter is loaded and usable. 
		/// <para>
		/// This is for advanced users of the library, mainly to expose mediastreamer video
		/// filter status. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="filtername">the filter name   </param>
		/// 
		/// 
		/// <returns>true if the filter is loaded and usable, false otherwise </returns>
		public bool IsMediaFilterSupported(string filtername)
		{
			bool returnVal = linphone_core_is_media_filter_supported(nativePtr, filtername) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_iterate(IntPtr thiz);

		/// <summary>
		/// Main loop function. 
		/// <para>
		/// It is crucial that your application call it periodically.
		/// 
		/// <see cref="Linphone.Core.Iterate()" /> performs various backgrounds tasks:
		/// 
		/// </para>
		/// </summary>
		public void Iterate()
		{
			linphone_core_iterate(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_leave_conference(IntPtr thiz);

		/// <summary>
		/// Make the local participant leave the running conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if succeeded. Negative number if failed </returns>
		public void LeaveConference()
		{
			int exception_result = linphone_core_leave_conference(nativePtr);
			if (exception_result != 0) throw new LinphoneException("LeaveConference returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_lime_available(IntPtr thiz);

		/// <summary>
		/// Tells if lime is available. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// deprecated : 04/02/2019 Use linphone_core_lime_x3dh_available instead. 
		public bool LimeAvailable()
		{
			bool returnVal = linphone_core_lime_available(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.LimeState linphone_core_lime_enabled(IntPtr thiz);

		/// <summary>
		/// Returns the lime state. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current lime state</returns>
		/// 
		/// deprecated : 04/02/2019 Use linphone_core_lime_x3dh_enabled instead. 
		public Linphone.LimeState LimeEnabled()
		{
			Linphone.LimeState returnVal = linphone_core_lime_enabled(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_lime_x3dh_available(IntPtr thiz);

		/// <summary>
		/// Tells if LIME X3DH is available. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public bool LimeX3DhAvailable()
		{
			bool returnVal = linphone_core_lime_x3dh_available(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_load_config_from_xml(IntPtr thiz, string xmlUri);

		/// <summary>
		/// Update current config with the content of a xml config file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="xmlUri">the path to the xml file   </param>
		/// 
		public void LoadConfigFromXml(string xmlUri)
		{
			linphone_core_load_config_from_xml(nativePtr, xmlUri);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_media_encryption_supported(IntPtr thiz, int menc);

		/// <summary>
		/// Check if a media encryption type is supported. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="menc">LinphoneMediaEncryption </param>
		/// 
		/// 
		/// <returns>whether a media encryption scheme is supported by the <see
		/// cref="Linphone.Core" /> engine </returns>
		public bool MediaEncryptionSupported(Linphone.MediaEncryption menc)
		{
			bool returnVal = linphone_core_media_encryption_supported(nativePtr, (int)menc) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_migrate_logs_from_rc_to_db(IntPtr thiz);

		/// <summary>
		/// Migrates the call logs from the linphonerc to the database if not done yet. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void MigrateLogsFromRcToDb()
		{
			linphone_core_migrate_logs_from_rc_to_db(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_migrate_to_multi_transport(IntPtr thiz);

		/// <summary>
		/// Migrate configuration so that all SIP transports are enabled. 
		/// <para>
		/// Versions of linphone < 3.7 did not support using multiple SIP transport
		/// simultaneously. This function helps application to migrate the configuration so
		/// that all transports are enabled. Existing proxy configuration are added a
		/// transport parameter so that they continue using the unique transport that was
		/// set previously. This function must be used just after creating the core, before
		/// any call to <see cref="Linphone.Core.Iterate()" /> 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>1 if migration was done, 0 if not done because unnecessary or already
		/// done, -1 in case of error. </returns>
		public void MigrateToMultiTransport()
		{
			int exception_result = linphone_core_migrate_to_multi_transport(nativePtr);
			if (exception_result != 0) throw new LinphoneException("MigrateToMultiTransport returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_notify_all_friends(IntPtr thiz, IntPtr presence);

		/// <summary>
		/// Notify all friends that have subscribed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="presence"><see cref="Linphone.PresenceModel" /> to notify  
		/// </param>
		/// 
		public void NotifyAllFriends(Linphone.PresenceModel presence)
		{
			linphone_core_notify_all_friends(nativePtr, presence != null ? presence.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_notify_notify_presence_received(IntPtr thiz, IntPtr linphoneFriend);

		/// <summary>
		/// Notifies the upper layer that a presence status has been received by calling
		/// the appropriate callback if one has been set. 
		/// <para>
		/// This method is for advanced usage, where customization of the liblinphone's
		/// internal behavior is required. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend">the <see cref="Linphone.Friend" /> whose presence
		/// information has been received.   </param>
		/// 
		public void NotifyNotifyPresenceReceived(Linphone.Friend linphoneFriend)
		{
			linphone_core_notify_notify_presence_received(nativePtr, linphoneFriend != null ? linphoneFriend.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_notify_notify_presence_received_for_uri_or_tel(IntPtr thiz, IntPtr linphoneFriend, string uriOrTel, IntPtr presenceModel);

		/// <summary>
		/// Notifies the upper layer that a presence model change has been received for the
		/// uri or telephone number given as a parameter, by calling the appropriate
		/// callback if one has been set. 
		/// <para>
		/// This method is for advanced usage, where customization of the liblinphone's
		/// internal behavior is required. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend">the <see cref="Linphone.Friend" /> whose presence
		/// information has been received.   </param>
		/// <param name="uriOrTel">telephone number or sip uri   </param>
		/// <param name="presenceModel">the <see cref="Linphone.PresenceModel" /> that has
		/// been modified   </param>
		/// 
		public void NotifyNotifyPresenceReceivedForUriOrTel(Linphone.Friend linphoneFriend, string uriOrTel, Linphone.PresenceModel presenceModel)
		{
			linphone_core_notify_notify_presence_received_for_uri_or_tel(nativePtr, linphoneFriend != null ? linphoneFriend.nativePtr : IntPtr.Zero, uriOrTel, presenceModel != null ? presenceModel.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_pause_all_calls(IntPtr thiz);

		/// <summary>
		/// Pause all currently running calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 </returns>
		public void PauseAllCalls()
		{
			int exception_result = linphone_core_pause_all_calls(nativePtr);
			if (exception_result != 0) throw new LinphoneException("PauseAllCalls returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_play_dtmf(IntPtr thiz, sbyte dtmf, int durationMs);

		/// <summary>
		/// Plays a dtmf sound to the local user. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="dtmf">DTMF to play ['0'..'16'] | '#' | '#' </param>
		/// <param name="durationMs">Duration in ms, -1 means play until next further call
		/// to <see cref="Linphone.Core.StopDtmf()" /> </param>
		/// 
		public void PlayDtmf(sbyte dtmf, int durationMs)
		{
			linphone_core_play_dtmf(nativePtr, dtmf, durationMs);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_play_local(IntPtr thiz, string audiofile);

		/// <summary>
		/// Plays an audio file to the local user. 
		/// <para>
		/// This function works at any time, during calls, or when no calls are running. It
		/// doesn't request the underlying audio system to support multiple playback
		/// streams. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="audiofile">The path to an audio file in wav PCM 16 bit format  
		/// </param>
		/// 
		/// 
		/// <returns>0 on success, -1 on error </returns>
		public void PlayLocal(string audiofile)
		{
			int exception_result = linphone_core_play_local(nativePtr, audiofile);
			if (exception_result != 0) throw new LinphoneException("PlayLocal returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_preview_ogl_render(IntPtr thiz);

		/// <summary>
		/// Call generic OpenGL render for a given core. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void PreviewOglRender()
		{
			linphone_core_preview_ogl_render(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_publish(IntPtr thiz, IntPtr resource, string ev, int expires, IntPtr body);

		/// <summary>
		/// Publish an event state. 
		/// <para>
		/// This first create a <see cref="Linphone.Event" /> with <see
		/// cref="Linphone.Core.CreatePublish()" /> and calls <see
		/// cref="Linphone.Event.SendPublish()" /> to actually send it. After expiry, the
		/// publication is refreshed unless it is terminated before. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="resource">the resource uri for the event   </param>
		/// <param name="ev">the event name   </param>
		/// <param name="expires">the lifetime of event being published, -1 if no
		/// associated duration, in which case it will not be refreshed. </param>
		/// <param name="body">the actual published data   </param>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Event" /> holding the context of the publish. 
		///  </returns>
		public Linphone.Event Publish(Linphone.Address resource, string ev, int expires, Linphone.Content body)
		{
			IntPtr ptr = linphone_core_publish(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, ev, expires, body != null ? body.nativePtr : IntPtr.Zero);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_core_realtime_text_get_keepalive_interval(IntPtr thiz);

		/// <summary>
		/// Gets keep alive interval of real time text. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>keep alive interval of real time text. </returns>
		public uint RealtimeTextGetKeepaliveInterval()
		{
			uint returnVal = linphone_core_realtime_text_get_keepalive_interval(nativePtr);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_realtime_text_set_keepalive_interval(IntPtr thiz, uint interval);

		/// <summary>
		/// Set keep alive interval for real time text. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="interval">The keep alive interval of real time text, 25000 by
		/// default. </param>
		/// 
		public void RealtimeTextSetKeepaliveInterval(uint interval)
		{
			linphone_core_realtime_text_set_keepalive_interval(nativePtr, interval);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_refresh_registers(IntPtr thiz);

		/// <summary>
		/// force registration refresh to be initiated upon next iterate 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void RefreshRegisters()
		{
			linphone_core_refresh_registers(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reject_subscriber(IntPtr thiz, IntPtr linphoneFriend);

		/// <summary>
		/// Black list a friend. 
		/// <para>
		/// same as <see cref="Linphone.Friend.SetIncSubscribePolicy()" /> with
		/// LinphoneSPDeny policy; 
		/// 
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend"><see cref="Linphone.Friend" /> to reject   </param>
		/// 
		public void RejectSubscriber(Linphone.Friend linphoneFriend)
		{
			linphone_core_reject_subscriber(nativePtr, linphoneFriend != null ? linphoneFriend.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reload_ms_plugins(IntPtr thiz, string path);

		/// <summary>
		/// Reload mediastreamer2 plugins from specified directory. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="path">the path from where plugins are to be loaded, pass null to
		/// use default (compile-time determined) plugin directory.   </param>
		/// 
		public void ReloadMsPlugins(string path)
		{
			linphone_core_reload_ms_plugins(nativePtr, path);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reload_sound_devices(IntPtr thiz);

		/// <summary>
		/// Update detection of sound devices. 
		/// <para>
		/// Use this function when the application is notified of USB plug events, so that
		/// list of available hardwares for sound playback and capture is updated. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void ReloadSoundDevices()
		{
			linphone_core_reload_sound_devices(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reload_video_devices(IntPtr thiz);

		/// <summary>
		/// Update detection of camera devices. 
		/// <para>
		/// Use this function when the application is notified of USB plug events, so that
		/// list of available hardwares for video capture is updated. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void ReloadVideoDevices()
		{
			linphone_core_reload_video_devices(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_auth_info(IntPtr thiz, IntPtr info);

		/// <summary>
		/// Removes an authentication information object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="info">The <see cref="Linphone.AuthInfo" /> to remove.   </param>
		/// 
		public void RemoveAuthInfo(Linphone.AuthInfo info)
		{
			linphone_core_remove_auth_info(nativePtr, info != null ? info.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_call_log(IntPtr thiz, IntPtr callLog);

		/// <summary>
		/// Remove a specific call log from call history list. 
		/// <para>
		/// This function destroys the call log object. It must not be accessed anymore by
		/// the application after calling this function. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="callLog"><see cref="Linphone.CallLog" /> object to remove.  
		/// </param>
		/// 
		public void RemoveCallLog(Linphone.CallLog callLog)
		{
			linphone_core_remove_call_log(nativePtr, callLog != null ? callLog.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_friend_list(IntPtr thiz, IntPtr list);

		/// <summary>
		/// Removes a friend list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="list"><see cref="Linphone.FriendList" /> object   </param>
		/// 
		public void RemoveFriendList(Linphone.FriendList list)
		{
			linphone_core_remove_friend_list(nativePtr, list != null ? list.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_remove_from_conference(IntPtr thiz, IntPtr call);

		/// <summary>
		/// Remove a call from the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">a call that has been previously merged into the conference. 
		/// </param>
		/// 
		/// 
		/// After removing the remote participant belonging to the supplied call, the call
		/// becomes a normal call in paused state. If one single remote participant is left
		/// alone together with the local user in the conference after the removal, then
		/// the conference is automatically transformed into a simple call in
		/// StreamsRunning state. The conference's resources are then automatically
		/// destroyed.
		/// 
		/// In other words, unless <see cref="Linphone.Core.LeaveConference()" /> is
		/// explicitly called, the last remote participant of a conference is automatically
		/// put in a simple call in running state.
		/// 
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void RemoveFromConference(Linphone.Call call)
		{
			int exception_result = linphone_core_remove_from_conference(nativePtr, call != null ? call.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("RemoveFromConference returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_linphone_spec(IntPtr thiz, string spec);

		/// <summary>
		/// Remove the given linphone specs from the list of functionalities the linphone
		/// client supports. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="spec">The spec to remove   </param>
		/// 
		public void RemoveLinphoneSpec(string spec)
		{
			linphone_core_remove_linphone_spec(nativePtr, spec);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_proxy_config(IntPtr thiz, IntPtr config);

		/// <summary>
		/// Removes a proxy configuration. 
		/// <para>
		/// <see cref="Linphone.Core" /> will then automatically unregister and place the
		/// proxy configuration on a deleted list. For that reason, a removed proxy does
		/// NOT need to be freed. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="config">the <see cref="Linphone.ProxyConfig" /> to remove  
		/// </param>
		/// 
		public void RemoveProxyConfig(Linphone.ProxyConfig config)
		{
			linphone_core_remove_proxy_config(nativePtr, config != null ? config.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_supported_tag(IntPtr thiz, string tag);

		/// <summary>
		/// Remove a supported tag. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="tag">The tag to remove  </param>
		/// 
		/// 
		/// <remarks>See : <see cref="Linphone.Core.AddSupportedTag()" /> </remarks>
		public void RemoveSupportedTag(string tag)
		{
			linphone_core_remove_supported_tag(nativePtr, tag);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reset_missed_calls_count(IntPtr thiz);

		/// <summary>
		/// Reset the counter of missed calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void ResetMissedCallsCount()
		{
			linphone_core_reset_missed_calls_count(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_search_chat_room(IntPtr thiz, IntPtr parameters, IntPtr localAddr, IntPtr remoteAddr, IntPtr participants);

		/// <summary>
		/// Find a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The chat room parameters to match <see
		/// cref="Linphone.ChatRoomParams" /> or null   </param>
		/// <param name="localAddr"><see cref="Linphone.Address" /> representing the local
		/// proxy configuration or null   </param>
		/// <param name="remoteAddr"><see cref="Linphone.Address" /> to search for or null 
		///  </param>
		/// <param name="participants">A list of <see cref="Linphone.Address" /> objects.
		/// LinphoneAddress  The participants that must be present in the chat room to find
		///   </param>
		/// 
		/// 
		/// <returns>A matching chat room or null if none matches.   </returns>
		public Linphone.ChatRoom SearchChatRoom(Linphone.ChatRoomParams parameters, Linphone.Address localAddr, Linphone.Address remoteAddr, IEnumerable<Linphone.Address> participants)
		{
			IntPtr ptr = linphone_core_search_chat_room(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, remoteAddr != null ? remoteAddr.nativePtr : IntPtr.Zero, ObjectArrayToBctbxList<Linphone.Address>(participants));
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_search_conference(IntPtr thiz, IntPtr parameters, IntPtr localAddr, IntPtr remoteAddr, IntPtr participants);

		/// <summary>
		/// Find a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The conference parameters to match <see
		/// cref="Linphone.ConferenceParams" /> or null   </param>
		/// <param name="localAddr"><see cref="Linphone.Address" /> representing the local
		/// proxy configuration or null   </param>
		/// <param name="remoteAddr"><see cref="Linphone.Address" /> to search for or null 
		///  </param>
		/// <param name="participants">A list of <see cref="Linphone.Address" /> objects.
		/// LinphoneAddress  The participants that must be present in the chat room to find
		///   </param>
		/// 
		/// 
		/// <returns>A matching conference or null if none matches.   </returns>
		public Linphone.Conference SearchConference(Linphone.ConferenceParams parameters, Linphone.Address localAddr, Linphone.Address remoteAddr, IEnumerable<Linphone.Address> participants)
		{
			IntPtr ptr = linphone_core_search_conference(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, remoteAddr != null ? remoteAddr.nativePtr : IntPtr.Zero, ObjectArrayToBctbxList<Linphone.Address>(participants));
			Linphone.Conference returnVal = fromNativePtr<Linphone.Conference>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_audio_port_range(IntPtr thiz, int minPort, int maxPort);

		/// <summary>
		/// Sets the UDP port range from which to randomly select the port used for audio
		/// streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="minPort">The lower bound of the audio port range to use </param>
		/// <param name="maxPort">The upper bound of the audio port range to use </param>
		/// 
		public void SetAudioPortRange(int minPort, int maxPort)
		{
			linphone_core_set_audio_port_range(nativePtr, minPort, maxPort);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_call_error_tone(IntPtr thiz, int reason, string audiofile);

		/// <summary>
		/// Assign an audio file to be played locally upon call failure, for a given
		/// reason. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="reason">the LinphoneReason representing the failure error code.
		/// </param>
		/// <param name="audiofile">a wav file to be played when such call failure happens.
		///   </param>
		/// 
		public void SetCallErrorTone(Linphone.Reason reason, string audiofile)
		{
			linphone_core_set_call_error_tone(nativePtr, (int)reason, audiofile);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_qrcode_decode_rect(IntPtr thiz, int x, int y, int w, int h);

		/// <summary>
		/// Set the rectangle where the decoder will search a QRCode. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="x">axis </param>
		/// <param name="y">axis </param>
		/// <param name="w">width </param>
		/// <param name="h">height </param>
		/// 
		public void SetQrcodeDecodeRect(int x, int y, int w, int h)
		{
			linphone_core_set_qrcode_decode_rect(nativePtr, x, y, w, h);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_text_port_range(IntPtr thiz, int minPort, int maxPort);

		/// <summary>
		/// Sets the UDP port range from which to randomly select the port used for text
		/// streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="minPort">The lower bound of the text port range to use </param>
		/// <param name="maxPort">The upper bound of the text port range to use </param>
		/// 
		public void SetTextPortRange(int minPort, int maxPort)
		{
			linphone_core_set_text_port_range(nativePtr, minPort, maxPort);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_user_agent(IntPtr thiz, string name, string version);

		/// <summary>
		/// Set the user agent string used in SIP messages. 
		/// <para>
		/// Set the user agent string used in SIP messages as "[ua_name]/[version]". No
		/// slash character will be printed if null is given to "version". If null is given
		/// to "ua_name" and "version" both, the User-agent header will be empty.
		/// 
		/// This function should be called just after linphone_factory_create_core ideally. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="name">Name of the user agent.   </param>
		/// <param name="version">Version of the user agent.   </param>
		/// 
		public void SetUserAgent(string name, string version)
		{
			linphone_core_set_user_agent(nativePtr, name, version);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_port_range(IntPtr thiz, int minPort, int maxPort);

		/// <summary>
		/// Sets the UDP port range from which to randomly select the port used for video
		/// streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="minPort">The lower bound of the video port range to use </param>
		/// <param name="maxPort">The upper bound of the video port range to use </param>
		/// 
		public void SetVideoPortRange(int minPort, int maxPort)
		{
			linphone_core_set_video_port_range(nativePtr, minPort, maxPort);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_sound_device_can_capture(IntPtr thiz, string device);

		/// <summary>
		/// Tells whether a specified sound device can capture sound. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="device">the device name as returned by
		/// linphone_core_get_sound_devices   </param>
		/// 
		/// 
		/// <returns>A boolean value telling whether the specified sound device can capture
		/// sound </returns>
		/// 
		/// deprecated : 08/07/2020 use <see cref="Linphone.AudioDevice" /> API instead()
		public bool SoundDeviceCanCapture(string device)
		{
			bool returnVal = linphone_core_sound_device_can_capture(nativePtr, device) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_sound_device_can_playback(IntPtr thiz, string device);

		/// <summary>
		/// Tells whether a specified sound device can play sound. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="device">the device name as returned by
		/// linphone_core_get_sound_devices   </param>
		/// 
		/// 
		/// <returns>A boolean value telling whether the specified sound device can play
		/// sound </returns>
		/// 
		/// deprecated : 08/07/2020 use <see cref="Linphone.AudioDevice" /> API instead()
		public bool SoundDeviceCanPlayback(string device)
		{
			bool returnVal = linphone_core_sound_device_can_playback(nativePtr, device) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_sound_resources_locked(IntPtr thiz);

		/// <summary>
		/// Check if a call will need the sound resources in near future (typically an
		/// outgoing call that is awaiting response). 
		/// <para>
		/// In liblinphone, it is not possible to have two independant calls using sound
		/// device or camera at the same time. In order to prevent this situation, an
		/// application can use <see cref="Linphone.Core.SoundResourcesLocked()" /> to know
		/// whether it is possible at a given time to start a new outgoing call. When the
		/// function returns true, an application should not allow the user to start an
		/// outgoing call. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether a call will need the sound resources
		/// in near future </returns>
		public bool SoundResourcesLocked()
		{
			bool returnVal = linphone_core_sound_resources_locked(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_start(IntPtr thiz);

		/// <summary>
		/// Start a <see cref="Linphone.Core" /> object after it has been instantiated and
		/// not automatically started. 
		/// <para>
		/// Also re-initialize a <see cref="Linphone.Core" /> object that has been stopped
		/// using <see cref="Linphone.Core.Stop()" />. Must be called only if
		/// LinphoneGlobalState is either Ready of Off. State will changed to Startup,
		/// Configuring and then On.
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0: success, -1: global failure, -2: could not connect database
		/// </returns>
		public void Start()
		{
			int exception_result = linphone_core_start(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Start returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_start_conference_recording(IntPtr thiz, string path);

		/// <summary>
		/// Start recording the running conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="path">Path to the file where the recording will be written  
		/// </param>
		/// 
		/// 
		/// <returns>0 if succeeded. Negative number if failed </returns>
		public void StartConferenceRecording(string path)
		{
			int exception_result = linphone_core_start_conference_recording(nativePtr, path);
			if (exception_result != 0) throw new LinphoneException("StartConferenceRecording returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_start_echo_canceller_calibration(IntPtr thiz);

		/// <summary>
		/// Starts an echo calibration of the sound devices, in order to find adequate
		/// settings for the echo canceler automatically. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>LinphoneStatus whether calibration has started or not. </returns>
		public void StartEchoCancellerCalibration()
		{
			int exception_result = linphone_core_start_echo_canceller_calibration(nativePtr);
			if (exception_result != 0) throw new LinphoneException("StartEchoCancellerCalibration returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_start_echo_tester(IntPtr thiz, uint rate);

		/// <summary>
		/// Start the simulation of call to test the latency with an external device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="rate">Sound sample rate. </param>
		/// 
		/// 
		/// <returns>-1 in case of failure, 1 otherwise. </returns>
		public void StartEchoTester(uint rate)
		{
			int exception_result = linphone_core_start_echo_tester(nativePtr, rate);
			if (exception_result != 0) throw new LinphoneException("StartEchoTester returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_stop(IntPtr thiz);

		/// <summary>
		/// Stop a <see cref="Linphone.Core" /> object after it has been instantiated and
		/// started. 
		/// <para>
		/// If stopped, it can be started again using <see cref="Linphone.Core.Start()" />.
		/// Must be called only if LinphoneGlobalState is either On. State will changed to
		/// Shutdown and then Off.
		/// 
		/// </para>
		/// </summary>
		/// 
		public void Stop()
		{
			linphone_core_stop(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_stop_async(IntPtr thiz);

		/// <summary>
		/// Stop asynchronously a <see cref="Linphone.Core" /> object after it has been
		/// instantiated and started. 
		/// <para>
		/// State changes to Shutdown then <see cref="Linphone.Core.Iterate()" /> must be
		/// called to allow the Core to end asynchronous tasks (terminate call, etc.). When
		/// all tasks are finished, State will change to Off. Must be called only if
		/// LinphoneGlobalState is On. When LinphoneGlobalState is Off <see
		/// cref="Linphone.Core" /> can be started again using <see
		/// cref="Linphone.Core.Start()" />.
		/// 
		/// </para>
		/// </summary>
		/// 
		public void StopAsync()
		{
			linphone_core_stop_async(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_stop_conference_recording(IntPtr thiz);

		/// <summary>
		/// Stop recording the running conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if succeeded. Negative number if failed </returns>
		public void StopConferenceRecording()
		{
			int exception_result = linphone_core_stop_conference_recording(nativePtr);
			if (exception_result != 0) throw new LinphoneException("StopConferenceRecording returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_stop_dtmf(IntPtr thiz);

		/// <summary>
		/// Stops playing a dtmf started by <see cref="Linphone.Core.PlayDtmf()" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void StopDtmf()
		{
			linphone_core_stop_dtmf(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_stop_echo_tester(IntPtr thiz);

		/// <summary>
		/// Stop the simulation of call. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void StopEchoTester()
		{
			int exception_result = linphone_core_stop_echo_tester(nativePtr);
			if (exception_result != 0) throw new LinphoneException("StopEchoTester returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_stop_ringing(IntPtr thiz);

		/// <summary>
		/// Whenever the liblinphone is playing a ring to advertise an incoming call or
		/// ringback of an outgoing call, this function stops the ringing. 
		/// <para>
		/// Typical use is to stop ringing when the user requests to ignore the call. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void StopRinging()
		{
			linphone_core_stop_ringing(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_subscribe(IntPtr thiz, IntPtr resource, string ev, int expires, IntPtr body);

		/// <summary>
		/// Create an outgoing subscription, specifying the destination resource, the event
		/// name, and an optional content body. 
		/// <para>
		/// If accepted, the subscription runs for a finite period, but is automatically
		/// renewed if not terminated before. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="resource">the destination resource   </param>
		/// <param name="ev">the event name   </param>
		/// <param name="expires">the whished duration of the subscription </param>
		/// <param name="body">an optional body, may be null.   </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Event" /> holding the context of the created
		/// subcription.   </returns>
		public Linphone.Event Subscribe(Linphone.Address resource, string ev, int expires, Linphone.Content body)
		{
			IntPtr ptr = linphone_core_subscribe(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, ev, expires, body != null ? body.nativePtr : IntPtr.Zero);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_take_preview_snapshot(IntPtr thiz, string file);

		/// <summary>
		/// Take a photo of currently from capture device and write it into a jpeg file. 
		/// <para>
		/// Note that the snapshot is asynchronous, an application shall not assume that
		/// the file is created when the function returns.
		/// 
		/// </para>
		/// </summary>
		/// <param name="file">a path where to write the jpeg content.   </param>
		/// 
		/// 
		/// <returns>0 if successfull, -1 otherwise (typically if jpeg format is not
		/// supported). </returns>
		public void TakePreviewSnapshot(string file)
		{
			int exception_result = linphone_core_take_preview_snapshot(nativePtr, file);
			if (exception_result != 0) throw new LinphoneException("TakePreviewSnapshot returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_terminate_all_calls(IntPtr thiz);

		/// <summary>
		/// Terminates all the calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 </returns>
		public void TerminateAllCalls()
		{
			int exception_result = linphone_core_terminate_all_calls(nativePtr);
			if (exception_result != 0) throw new LinphoneException("TerminateAllCalls returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_terminate_conference(IntPtr thiz);

		/// <summary>
		/// Terminate the running conference. 
		/// <para>
		/// If it is a local conference, all calls inside it will become back separate
		/// calls and will be put in #LinphoneCallPaused state. If it is a conference
		/// involving a focus server, all calls inside the conference will be terminated. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if succeeded. Negative number if failed </returns>
		public void TerminateConference()
		{
			int exception_result = linphone_core_terminate_conference(nativePtr);
			if (exception_result != 0) throw new LinphoneException("TerminateConference returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_upload_log_collection(IntPtr thiz);

		/// <summary>
		/// Upload the log collection to the configured server url. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void UploadLogCollection()
		{
			linphone_core_upload_log_collection(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_use_preview_window(IntPtr thiz, char yesno);

		/// <summary>
		/// Tells the core to use a separate window for local camera preview video, instead
		/// of inserting local view within the remote video window. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="yesno">true to use a separate window, false to insert the preview
		/// in the remote video window. </param>
		/// 
		public void UsePreviewWindow(bool yesno)
		{
			linphone_core_use_preview_window(nativePtr, yesno ? (char)1 : (char)0);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_verify_server_certificates(IntPtr thiz, char yesno);

		/// <summary>
		/// Specify whether the tls server certificate must be verified when connecting to
		/// a SIP/TLS server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="yesno">A boolean value telling whether the tls server certificate
		/// must be verified </param>
		/// 
		public void VerifyServerCertificates(bool yesno)
		{
			linphone_core_verify_server_certificates(nativePtr, yesno ? (char)1 : (char)0);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_verify_server_cn(IntPtr thiz, char yesno);

		/// <summary>
		/// Specify whether the tls server certificate common name must be verified when
		/// connecting to a SIP/TLS server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="yesno">A boolean value telling whether the tls server certificate
		/// common name must be verified </param>
		/// 
		public void VerifyServerCn(bool yesno)
		{
			linphone_core_verify_server_cn(nativePtr, yesno ? (char)1 : (char)0);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_supported(IntPtr thiz);

		/// <summary>
		/// Test if video is supported. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the library was built with video support, false otherwise
		/// </returns>
		public bool VideoSupported()
		{
			bool returnVal = linphone_core_video_supported(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
	}
	/// <summary>
	/// Represents a dial plan. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class DialPlan : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_by_ccc(string ccc);

		/// <summary>
		/// Find best match for given CCC. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="ccc">The country calling code   </param>
		/// 
		/// 
		/// <returns>the matching dial plan, or a generic one if none found   </returns>
		public static Linphone.DialPlan ByCcc(string ccc)
		{
			IntPtr ptr = linphone_dial_plan_by_ccc(ccc);
			Linphone.DialPlan returnVal = fromNativePtr<Linphone.DialPlan>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_by_ccc_as_int(int ccc);

		/// <summary>
		/// Find best match for given CCC. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="ccc">the country calling code   </param>
		/// 
		/// 
		/// <returns>the matching dial plan, or a generic one if none found   </returns>
		public static Linphone.DialPlan ByCccAsInt(int ccc)
		{
			IntPtr ptr = linphone_dial_plan_by_ccc_as_int(ccc);
			Linphone.DialPlan returnVal = fromNativePtr<Linphone.DialPlan>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_get_all_list();

		/// <summary>
		/// Returns a list of all known dial plans. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of <see cref="Linphone.DialPlan" /> objects. LinphoneDialPlan 
		/// of all known dial plans   </returns>
		static public IEnumerable<Linphone.DialPlan> AllList
		{
			get
			{
				return MarshalBctbxList<Linphone.DialPlan>(linphone_dial_plan_get_all_list(), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_dial_plan_lookup_ccc_from_e164(string e164);

		/// <summary>
		/// Function to get call country code from an e164 number, ex: +33952650121 will
		/// return 33. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="e164">phone number   </param>
		/// 
		/// 
		/// <returns>call country code or -1 if not found </returns>
		public static int LookupCccFromE164(string e164)
		{
			int returnVal = linphone_dial_plan_lookup_ccc_from_e164(e164);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_dial_plan_lookup_ccc_from_iso(string iso);

		/// <summary>
		/// Function to get call country code from ISO 3166-1 alpha-2 code, ex: FR returns
		/// 33. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="iso">country code alpha2   </param>
		/// 
		/// 
		/// <returns>call country code or -1 if not found </returns>
		public static int LookupCccFromIso(string iso)
		{
			int returnVal = linphone_dial_plan_lookup_ccc_from_iso(iso);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_get_country(IntPtr thiz);

		/// <summary>
		/// Returns the country name of the dialplan. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the country name </returns>
		public string Country
		{
			get
			{
				IntPtr stringPtr = linphone_dial_plan_get_country(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_get_country_calling_code(IntPtr thiz);

		/// <summary>
		/// Returns the country calling code of the dialplan. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the country calling code   </returns>
		public string CountryCallingCode
		{
			get
			{
				IntPtr stringPtr = linphone_dial_plan_get_country_calling_code(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_get_international_call_prefix(IntPtr thiz);

		/// <summary>
		/// Returns the international call prefix of the dialplan. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the international call prefix   </returns>
		public string InternationalCallPrefix
		{
			get
			{
				IntPtr stringPtr = linphone_dial_plan_get_international_call_prefix(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_dial_plan_is_generic(IntPtr thiz);

		/// <summary>
		/// Return if given plan is generic. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if generic, false otherwise </returns>
		public bool IsGeneric
		{
			get
			{
				return linphone_dial_plan_is_generic(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_get_iso_country_code(IntPtr thiz);

		/// <summary>
		/// Returns the iso country code of the dialplan. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the iso country code   </returns>
		public string IsoCountryCode
		{
			get
			{
				IntPtr stringPtr = linphone_dial_plan_get_iso_country_code(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_dial_plan_get_national_number_length(IntPtr thiz);

		/// <summary>
		/// Returns the national number length of the dialplan. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the national number length </returns>
		public int NationalNumberLength
		{
			get
			{
				return linphone_dial_plan_get_national_number_length(nativePtr);
			}
		}
	}
	/// <summary>
	/// Object representing full details about a signaling error or status. 
	/// <para>
	/// All <see cref="Linphone.ErrorInfo" /> object returned by the liblinphone API
	/// are readonly and transcients. For safety they must be used immediately after
	/// obtaining them. Any other function call to the liblinphone may change their
	/// content or invalidate the pointer. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ErrorInfo : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_error_info_get_phrase(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_phrase(IntPtr thiz, string phrase);

		/// <summary>
		/// Get textual phrase from the error info. 
		/// <para>
		/// This is the text that is provided by the peer in the protocol (SIP). 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The error phrase   </returns>
		public string Phrase
		{
			get
			{
				IntPtr stringPtr = linphone_error_info_get_phrase(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_error_info_set_phrase(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_error_info_get_protocol(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_protocol(IntPtr thiz, string protocol);

		/// <summary>
		/// Get protocol from the error info. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The protocol.   </returns>
		public string Protocol
		{
			get
			{
				IntPtr stringPtr = linphone_error_info_get_protocol(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_error_info_set_protocol(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_error_info_get_protocol_code(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_protocol_code(IntPtr thiz, int code);

		/// <summary>
		/// Get the status code from the low level protocol (ex a SIP status code). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The status code </returns>
		public int ProtocolCode
		{
			get
			{
				return linphone_error_info_get_protocol_code(nativePtr);
			}
			set
			{
				linphone_error_info_set_protocol_code(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.Reason linphone_error_info_get_reason(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_reason(IntPtr thiz, int reason);

		/// <summary>
		/// Get reason code from the error info. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A LinphoneReason object </returns>
		public Linphone.Reason Reason
		{
			get
			{
				return linphone_error_info_get_reason(nativePtr);
			}
			set
			{
				linphone_error_info_set_reason(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_error_info_get_retry_after(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_retry_after(IntPtr thiz, int retryAfter);

		/// <summary>
		/// Get Retry-After delay second from the error info. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The Retry-After delay second </returns>
		public int RetryAfter
		{
			get
			{
				return linphone_error_info_get_retry_after(nativePtr);
			}
			set
			{
				linphone_error_info_set_retry_after(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_error_info_get_sub_error_info(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_sub_error_info(IntPtr thiz, IntPtr appendedErrorInfo);

		/// <summary>
		/// Get pointer to chained <see cref="Linphone.ErrorInfo" /> set in sub_ei. 
		/// <para>
		/// It corresponds to a Reason header in a received SIP response. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.ErrorInfo" /> pointer defined in the ei object.  
		/// </returns>
		public Linphone.ErrorInfo SubErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_error_info_get_sub_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
			set
			{
				linphone_error_info_set_sub_error_info(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_error_info_get_warnings(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_warnings(IntPtr thiz, string warnings);

		/// <summary>
		/// Provides additional information regarding the failure. 
		/// <para>
		/// With SIP protocol, the content of "Warning" headers are returned. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>More details about the failure.   </returns>
		public string Warnings
		{
			get
			{
				IntPtr stringPtr = linphone_error_info_get_warnings(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_error_info_set_warnings(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set(IntPtr thiz, string protocol, int reason, int code, string status, string warning);

		/// <summary>
		/// Assign information to a <see cref="Linphone.ErrorInfo" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="protocol">protocol name   </param>
		/// <param name="reason">reason from LinphoneReason enum </param>
		/// <param name="code">protocol code </param>
		/// <param name="status">description of the reason   </param>
		/// <param name="warning">warning message   </param>
		/// 
		public void Set(string protocol, Linphone.Reason reason, int code, string status, string warning)
		{
			linphone_error_info_set(nativePtr, protocol, (int)reason, code, status, warning);
			
			
			
		}
	}
	/// <summary>
	/// Object representing an event state, which is subcribed or published. 
	/// <para>
	/// </para>
	/// </summary>
	/// <remarks>See : <see cref="Linphone.Core.Publish()" /> </remarks>
	/// 
	/// <remarks>See : <see cref="Linphone.Core.Subscribe()" /> </remarks>
	[StructLayout(LayoutKind.Sequential)]
	public class Event : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_event_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_remove_callbacks(IntPtr thiz, IntPtr cbs);

		~Event() 
		{
			if (listener != null)
			{
				linphone_event_remove_callbacks(nativePtr, listener.nativePtr);
			}
		}

		private EventListener listener;

		public EventListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_event_cbs(linphone_factory_get());
					listener = fromNativePtr<EventListener>(nativeListener, false);
					linphone_event_add_callbacks(nativePtr, nativeListener);
					listener.register();
				}
				return listener;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_core(IntPtr thiz);

		/// <summary>
		/// Returns back pointer to the <see cref="Linphone.Core" /> that created this <see
		/// cref="Linphone.Event" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Core" /> object associated.   </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_event_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_current_callbacks(IntPtr thiz);

		/// <summary>
		/// Get the current LinphoneEventCbs object associated with a LinphoneEvent. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current LinphoneEventCbs object associated with the LinphoneEvent.
		///   </returns>
		public Linphone.EventListener CurrentCallbacks
		{
			get
			{
				IntPtr ptr = linphone_event_get_current_callbacks(nativePtr);
				Linphone.EventListener obj = fromNativePtr<Linphone.EventListener>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_error_info(IntPtr thiz);

		/// <summary>
		/// Get full details about an error occured. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.ErrorInfo" /> object.   </returns>
		public Linphone.ErrorInfo ErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_event_get_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_from(IntPtr thiz);

		/// <summary>
		/// Get the "from" address of the subscription. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the from <see cref="Linphone.Address" />.   </returns>
		public Linphone.Address From
		{
			get
			{
				IntPtr ptr = linphone_event_get_from(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_name(IntPtr thiz);

		/// <summary>
		/// Get the name of the event as specified in the event package RFC. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the event name.   </returns>
		public string Name
		{
			get
			{
				IntPtr stringPtr = linphone_event_get_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.PublishState linphone_event_get_publish_state(IntPtr thiz);

		/// <summary>
		/// Get publish state. 
		/// <para>
		/// If the event object was not created by a publish mechanism, LinphonePublishNone
		/// is returned. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the current LinphonePublishState </returns>
		public Linphone.PublishState PublishState
		{
			get
			{
				return linphone_event_get_publish_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.Reason linphone_event_get_reason(IntPtr thiz);

		/// <summary>
		/// Return reason code (in case of error state reached). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a LinphoneReason enum </returns>
		public Linphone.Reason Reason
		{
			get
			{
				return linphone_event_get_reason(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_remote_contact(IntPtr thiz);

		/// <summary>
		/// Get the "contact" address of the subscription. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The "contact" address of the subscription   </returns>
		public Linphone.Address RemoteContact
		{
			get
			{
				IntPtr ptr = linphone_event_get_remote_contact(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_resource(IntPtr thiz);

		/// <summary>
		/// Get the resource address of the subscription or publish. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the resource <see cref="Linphone.Address" />.   </returns>
		public Linphone.Address Resource
		{
			get
			{
				IntPtr ptr = linphone_event_get_resource(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SubscriptionDir linphone_event_get_subscription_dir(IntPtr thiz);

		/// <summary>
		/// Get subscription direction. 
		/// <para>
		/// If the object wasn't created by a subscription mechanism,
		/// LinphoneSubscriptionInvalidDir is returned. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the LinphoneSubscriptionDir </returns>
		public Linphone.SubscriptionDir SubscriptionDir
		{
			get
			{
				return linphone_event_get_subscription_dir(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SubscriptionState linphone_event_get_subscription_state(IntPtr thiz);

		/// <summary>
		/// Get subscription state. 
		/// <para>
		/// If the event object was not created by a subscription mechanism,
		/// LinphoneSubscriptionNone is returned. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the current LinphoneSubscriptionState </returns>
		public Linphone.SubscriptionState SubscriptionState
		{
			get
			{
				return linphone_event_get_subscription_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_to(IntPtr thiz);

		/// <summary>
		/// Get the "to" address of the subscription. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the "to" <see cref="Linphone.Address" />.   </returns>
		public Linphone.Address To
		{
			get
			{
				IntPtr ptr = linphone_event_get_to(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_accept_subscription(IntPtr thiz);

		/// <summary>
		/// Accept an incoming subcription. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, error code otherwise </returns>
		public void AcceptSubscription()
		{
			int exception_result = linphone_event_accept_subscription(nativePtr);
			if (exception_result != 0) throw new LinphoneException("AcceptSubscription returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_event_add_custom_header(IntPtr thiz, string name, string val);

		/// <summary>
		/// Add a custom header to an outgoing susbscription or publish. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">header's name   </param>
		/// <param name="val">the header's value.   </param>
		/// 
		public void AddCustomHeader(string name, string val)
		{
			linphone_event_add_custom_header(nativePtr, name, val);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_deny_subscription(IntPtr thiz, int reason);

		/// <summary>
		/// Deny an incoming subscription with given reason. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, error code otherwise </returns>
		public void DenySubscription(Linphone.Reason reason)
		{
			int exception_result = linphone_event_deny_subscription(nativePtr, (int)reason);
			if (exception_result != 0) throw new LinphoneException("DenySubscription returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_custom_header(IntPtr thiz, string name);

		/// <summary>
		/// Obtain the value of a given header for an incoming subscription. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">header's name   </param>
		/// 
		/// 
		/// <returns>the header's value or null if such header doesn't exist.   </returns>
		public string GetCustomHeader(string name)
		{
			IntPtr stringPtr = linphone_event_get_custom_header(nativePtr, name);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_notify(IntPtr thiz, IntPtr body);

		/// <summary>
		/// Send a notification. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="body">an optional body containing the actual notification data.  
		/// </param>
		/// 
		/// 
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void Notify(Linphone.Content body)
		{
			int exception_result = linphone_event_notify(nativePtr, body != null ? body.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("Notify returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_event_pause_publish(IntPtr thiz);

		/// <summary>
		/// Prevent an event from refreshing its publish. 
		/// <para>
		/// This is useful to let registrations to expire naturally (or) when the
		/// application wants to keep control on when refreshes are sent. The refreshing
		/// operations can be resumed with <see
		/// cref="Linphone.ProxyConfig.RefreshRegister()" />. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void PausePublish()
		{
			linphone_event_pause_publish(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_refresh_publish(IntPtr thiz);

		/// <summary>
		/// Refresh an outgoing publish keeping the same body. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void RefreshPublish()
		{
			int exception_result = linphone_event_refresh_publish(nativePtr);
			if (exception_result != 0) throw new LinphoneException("RefreshPublish returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_refresh_subscribe(IntPtr thiz);

		/// <summary>
		/// Refresh an outgoing subscription keeping the same body. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void RefreshSubscribe()
		{
			int exception_result = linphone_event_refresh_subscribe(nativePtr);
			if (exception_result != 0) throw new LinphoneException("RefreshSubscribe returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_event_remove_custom_header(IntPtr thiz, string name);

		/// <summary>
		/// Remove custom header to an outgoing susbscription or publish. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">header's name   </param>
		/// 
		public void RemoveCustomHeader(string name)
		{
			linphone_event_remove_custom_header(nativePtr, name);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_send_publish(IntPtr thiz, IntPtr body);

		/// <summary>
		/// Send a publish created by <see cref="Linphone.Core.CreatePublish()" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="body">the new data to be published   </param>
		/// 
		/// 
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void SendPublish(Linphone.Content body)
		{
			int exception_result = linphone_event_send_publish(nativePtr, body != null ? body.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("SendPublish returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_send_subscribe(IntPtr thiz, IntPtr body);

		/// <summary>
		/// Send a subscription previously created by <see
		/// cref="Linphone.Core.CreateSubscribe()" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="body">optional content to attach with the subscription.   </param>
		/// 
		/// 
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void SendSubscribe(Linphone.Content body)
		{
			int exception_result = linphone_event_send_subscribe(nativePtr, body != null ? body.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("SendSubscribe returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_event_terminate(IntPtr thiz);

		/// <summary>
		/// Terminate an incoming or outgoing subscription that was previously acccepted,
		/// or a previous publication. 
		/// <para>
		/// The <see cref="Linphone.Event" /> shall not be used anymore after this
		/// operation. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void Terminate()
		{
			linphone_event_terminate(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_update_publish(IntPtr thiz, IntPtr body);

		/// <summary>
		/// Update (refresh) a publish. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="body">the new data to be published   </param>
		/// 
		/// 
		/// <returns>0 if successful, error code otherwise </returns>
		public void UpdatePublish(Linphone.Content body)
		{
			int exception_result = linphone_event_update_publish(nativePtr, body != null ? body.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("UpdatePublish returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_update_subscribe(IntPtr thiz, IntPtr body);

		/// <summary>
		/// Update (refresh) an outgoing subscription, changing the body. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="body">an optional body to include in the subscription update, may
		/// be null.   </param>
		/// 
		/// 
		/// <returns>0 if successful, error code otherwise    </returns>
		public void UpdateSubscribe(Linphone.Content body)
		{
			int exception_result = linphone_event_update_subscribe(nativePtr, body != null ? body.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("UpdateSubscribe returned value" + exception_result);
			
			
		}
	}
	/// <summary>
	/// Object that represents an event that must be stored in database. 
	/// <para>
	/// For example, all chat related events are wrapped in an <see
	/// cref="Linphone.EventLog" />, and many callbacks use this kind of type as
	/// parameter.
	/// 
	/// Use <see cref="Linphone.EventLog.GetType()" /> to get the LinphoneEventLogType
	/// it refers to, and then you can use one of the accessor methods to get the
	/// underlying object, for example <see cref="Linphone.EventLog.GetChatMessage()"
	/// /> for a <see cref="Linphone.ChatMessage" />. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class EventLog : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_call(IntPtr thiz);

		/// <summary>
		/// Returns the call of a conference call event. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The conference <see cref="Linphone.Call" />.   </returns>
		public Linphone.Call Call
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_chat_message(IntPtr thiz);

		/// <summary>
		/// Returns the chat message of a conference chat message event. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The conference <see cref="Linphone.ChatMessage" />.   </returns>
		public Linphone.ChatMessage ChatMessage
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_chat_message(nativePtr);
				Linphone.ChatMessage obj = fromNativePtr<Linphone.ChatMessage>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_event_log_get_creation_time(IntPtr thiz);

		/// <summary>
		/// Returns the creation time of a event log. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The event creation time </returns>
		public long CreationTime
		{
			get
			{
				return linphone_event_log_get_creation_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_device_address(IntPtr thiz);

		/// <summary>
		/// Returns the device address of a conference participant device event. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The conference device <see cref="Linphone.Address" />.   </returns>
		public Linphone.Address DeviceAddress
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_device_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_log_get_ephemeral_message_lifetime(IntPtr thiz);

		/// <summary>
		/// Returns the ephemeral message lifetime of a conference ephemeral message event. 
		/// <para>
		/// Ephemeral lifetime means the time before an ephemeral message which has been
		/// viewed gets deleted. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The ephemeral message lifetime. </returns>
		public int EphemeralMessageLifetime
		{
			get
			{
				return linphone_event_log_get_ephemeral_message_lifetime(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_local_address(IntPtr thiz);

		/// <summary>
		/// Returns the local address of a conference event. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The local <see cref="Linphone.Address" />.   </returns>
		public Linphone.Address LocalAddress
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_local_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_event_log_get_notify_id(IntPtr thiz);

		/// <summary>
		/// Returns the notify id of a conference notified event. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The conference notify id. </returns>
		public uint NotifyId
		{
			get
			{
				return linphone_event_log_get_notify_id(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_participant_address(IntPtr thiz);

		/// <summary>
		/// Returns the participant address of a conference participant event. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The conference participant <see cref="Linphone.Address" />.  
		/// </returns>
		public Linphone.Address ParticipantAddress
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_participant_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_peer_address(IntPtr thiz);

		/// <summary>
		/// Returns the peer address of a conference event. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The peer <see cref="Linphone.Address" />.   </returns>
		public Linphone.Address PeerAddress
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_peer_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_security_event_faulty_device_address(IntPtr thiz);

		/// <summary>
		/// Returns the faulty device address of a conference security event. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The <see cref="Linphone.Address" /> of the faulty device.   </returns>
		public Linphone.Address SecurityEventFaultyDeviceAddress
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_security_event_faulty_device_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SecurityEventType linphone_event_log_get_security_event_type(IntPtr thiz);

		/// <summary>
		/// Returns the type of security event. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneSecurityEventType type. </returns>
		public Linphone.SecurityEventType SecurityEventType
		{
			get
			{
				return linphone_event_log_get_security_event_type(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_subject(IntPtr thiz);

		/// <summary>
		/// Returns the subject of a conference subject event. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The conference subject.   </returns>
		public string Subject
		{
			get
			{
				IntPtr stringPtr = linphone_event_log_get_subject(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.EventLogType linphone_event_log_get_type(IntPtr thiz);

		/// <summary>
		/// Returns the type of a event log. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneEventLogType type </returns>
		public Linphone.EventLogType Type
		{
			get
			{
				return linphone_event_log_get_type(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_event_log_delete_from_database(IntPtr thiz);

		/// <summary>
		/// Delete event log from database. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void DeleteFromDatabase()
		{
			linphone_event_log_delete_from_database(nativePtr);
			
			
			
		}
	}
	/// <summary>
	/// The factory is a singleton object devoted to the creation of all the objects of
	/// Liblinphone that cannot be created by <see cref="Linphone.Core" /> itself. 
	/// <para>
	/// It is also used to configure a few behaviors before creating the <see
	/// cref="Linphone.Core" />, like the logs verbosity or collection. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Factory : LinphoneObject
	{
#if  __ANDROID__
        static Factory()
        {
            Java.Lang.JavaSystem.LoadLibrary("c++_shared");
            Java.Lang.JavaSystem.LoadLibrary("bctoolbox");
            Java.Lang.JavaSystem.LoadLibrary("ortp");
            Java.Lang.JavaSystem.LoadLibrary("mediastreamer");
            Java.Lang.JavaSystem.LoadLibrary("linphone");
        }
#endif


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_clean();

		/// <summary>
		/// Clean the factory. 
		/// <para>
		/// This function is generally useless as the factory is unique per process,
		/// however calling this function at the end avoid getting reports from belle-sip
		/// leak detector about memory leaked in <see cref="Linphone.Factory.Get()" />. 
		/// </para>
		/// </summary>
		public static void Clean()
		{
			linphone_factory_clean();
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		/// <summary>
		/// Create the <see cref="Linphone.Factory" /> if that has not been done and return
		/// a pointer on it. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer on the <see cref="Linphone.Factory" />   </returns>
		static public Linphone.Factory Instance
		{
			get
			{
				IntPtr ptr = linphone_factory_get();
				Linphone.Factory obj = fromNativePtr<Linphone.Factory>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_data_resources_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_data_resources_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the directory where the data resources are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the directory where the data resources are located  
		/// </returns>
		public string DataResourcesDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_data_resources_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_data_resources_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_dial_plans(IntPtr thiz);

		/// <summary>
		/// Returns a bctbx_list_t of all DialPlans. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.DialPlan" /> objects. LinphoneDialPlan 
		/// a list of <see cref="Linphone.DialPlan" />   </returns>
		public IEnumerable<Linphone.DialPlan> DialPlans
		{
			get
			{
				return MarshalBctbxList<Linphone.DialPlan>(linphone_factory_get_dial_plans(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_image_resources_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_image_resources_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the directory where the image resources are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the directory where the image resources are located  
		/// </returns>
		public string ImageResourcesDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_image_resources_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_image_resources_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_factory_is_database_storage_available(IntPtr thiz);

		/// <summary>
		/// Indicates if the storage in database is available. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the database storage is available, false otherwise </returns>
		public bool IsDatabaseStorageAvailable
		{
			get
			{
				return linphone_factory_is_database_storage_available(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_factory_is_imdn_available(IntPtr thiz);

		/// <summary>
		/// Indicates if IMDN are available. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if IDMN are available </returns>
		public bool IsImdnAvailable
		{
			get
			{
				return linphone_factory_is_imdn_available(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_log_collection_path(IntPtr thiz, string path);

		/// <summary>
		/// Sets the log collection path. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="path">the path of the logs   </param>
		/// 
		public string LogCollectionPath
		{
			set
			{
				linphone_factory_set_log_collection_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_msplugins_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_msplugins_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the directory where the mediastreamer2 plugins are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the directory where the mediastreamer2 plugins are
		/// located, or null if it has not been set.   </returns>
		public string MspluginsDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_msplugins_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_msplugins_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_ring_resources_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_ring_resources_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the directory where the ring resources are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the directory where the ring resources are located  
		/// </returns>
		public string RingResourcesDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_ring_resources_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_ring_resources_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_sound_resources_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_sound_resources_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the directory where the sound resources are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the directory where the sound resources are located  
		/// </returns>
		public string SoundResourcesDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_sound_resources_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_sound_resources_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_supported_video_definitions(IntPtr thiz);

		/// <summary>
		/// Get the list of standard video definitions supported by Linphone. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.VideoDefinition" /> objects.
		/// LinphoneVideoDefinition    </returns>
		public IEnumerable<Linphone.VideoDefinition> SupportedVideoDefinitions
		{
			get
			{
				return MarshalBctbxList<Linphone.VideoDefinition>(linphone_factory_get_supported_video_definitions(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_top_resources_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_top_resources_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the top directory where the resources are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The path to the top directory where the resources are located  
		/// </returns>
		public string TopResourcesDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_top_resources_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_top_resources_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_address(IntPtr thiz, string addr);

		/// <summary>
		/// Parse a string holding a SIP URI and create the according <see
		/// cref="Linphone.Address" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="addr">A string holding the SIP URI to parse.   </param>
		/// 
		/// 
		/// <returns>A new <see cref="Linphone.Address" />.   </returns>
		public Linphone.Address CreateAddress(string addr)
		{
			IntPtr ptr = linphone_factory_create_address(nativePtr, addr);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_auth_info_2(IntPtr thiz, string username, string userid, string passwd, string ha1, string realm, string domain, string algorithm);

		/// <summary>
		/// Creates a <see cref="Linphone.AuthInfo" /> object. 
		/// <para>
		/// The object can be created empty, that is with all arguments set to null.
		/// Username, userid, password, realm and domain can be set later using specific
		/// methods. At the end, username and passwd (or ha1) are required. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="username">The username that needs to be authenticated   </param>
		/// <param name="userid">The userid used for authenticating (use null if you don't
		/// know what it is)   </param>
		/// <param name="passwd">The password in clear text   </param>
		/// <param name="ha1">The ha1-encrypted password if password is not given in clear
		/// text.   </param>
		/// <param name="realm">The authentication domain (which can be larger than the sip
		/// domain. Unfortunately many SIP servers don't use this parameter.   </param>
		/// <param name="domain">The SIP domain for which this authentication information
		/// is valid, if it has to be restricted for a single SIP domain.   </param>
		/// <param name="algorithm">The algorithm for encrypting password.   </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.AuthInfo" /> object. linphone_auth_info_destroy
		/// must be used to destroy it when no longer needed. The <see cref="Linphone.Core"
		/// /> makes a copy of <see cref="Linphone.AuthInfo" /> passed through <see
		/// cref="Linphone.Core.AddAuthInfo()" />.   </returns>
		public Linphone.AuthInfo CreateAuthInfo(string username, string userid, string passwd, string ha1, string realm, string domain, string algorithm)
		{
			IntPtr ptr = linphone_factory_create_auth_info_2(nativePtr, username, userid, passwd, ha1, realm, domain, algorithm);
			Linphone.AuthInfo returnVal = fromNativePtr<Linphone.AuthInfo>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_auth_info(IntPtr thiz, string username, string userid, string passwd, string ha1, string realm, string domain);

		/// <summary>
		/// Creates a <see cref="Linphone.AuthInfo" /> object. 
		/// <para>
		/// The object can be created empty, that is with all arguments set to null.
		/// Username, userid, password, realm and domain can be set later using specific
		/// methods. At the end, username and passwd (or ha1) are required. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="username">The username that needs to be authenticated   </param>
		/// <param name="userid">The userid used for authenticating (use null if you don't
		/// know what it is)   </param>
		/// <param name="passwd">The password in clear text   </param>
		/// <param name="ha1">The ha1-encrypted password if password is not given in clear
		/// text.   </param>
		/// <param name="realm">The authentication domain (which can be larger than the sip
		/// domain. Unfortunately many SIP servers don't use this parameter.   </param>
		/// <param name="domain">The SIP domain for which this authentication information
		/// is valid, if it has to be restricted for a single SIP domain.   </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.AuthInfo" /> object. linphone_auth_info_destroy
		/// must be used to destroy it when no longer needed. The <see cref="Linphone.Core"
		/// /> makes a copy of <see cref="Linphone.AuthInfo" /> passed through <see
		/// cref="Linphone.Core.AddAuthInfo()" />.   </returns>
		public Linphone.AuthInfo CreateAuthInfo(string username, string userid, string passwd, string ha1, string realm, string domain)
		{
			IntPtr ptr = linphone_factory_create_auth_info(nativePtr, username, userid, passwd, ha1, realm, domain);
			Linphone.AuthInfo returnVal = fromNativePtr<Linphone.AuthInfo>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_buffer(IntPtr thiz);

		/// <summary>
		/// Creates an object <see cref="Linphone.Buffer" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Buffer" />   </returns>
		public Linphone.Buffer CreateBuffer()
		{
			IntPtr ptr = linphone_factory_create_buffer(nativePtr);
			Linphone.Buffer returnVal = fromNativePtr<Linphone.Buffer>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_buffer_from_data(IntPtr thiz, uint data, long size);

		/// <summary>
		/// Creates an object <see cref="Linphone.Buffer" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="data">the data to set in the buffer   </param>
		/// <param name="size">the size of the data </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Buffer" />   </returns>
		public Linphone.Buffer CreateBufferFromData(uint data, long size)
		{
			IntPtr ptr = linphone_factory_create_buffer_from_data(nativePtr, data, size);
			Linphone.Buffer returnVal = fromNativePtr<Linphone.Buffer>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_buffer_from_string(IntPtr thiz, string data);

		/// <summary>
		/// Creates an object <see cref="Linphone.Buffer" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="data">the data to set in the buffer   </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Buffer" />   </returns>
		public Linphone.Buffer CreateBufferFromString(string data)
		{
			IntPtr ptr = linphone_factory_create_buffer_from_string(nativePtr, data);
			Linphone.Buffer returnVal = fromNativePtr<Linphone.Buffer>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_config(IntPtr thiz, string path);

		/// <summary>
		/// Creates an object <see cref="Linphone.Config" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="path">the path of the config   </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Config" />   </returns>
		public Linphone.Config CreateConfig(string path)
		{
			IntPtr ptr = linphone_factory_create_config(nativePtr, path);
			Linphone.Config returnVal = fromNativePtr<Linphone.Config>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_config_from_string(IntPtr thiz, string data);

		/// <summary>
		/// Creates an object <see cref="Linphone.Config" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="data">the config data   </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Config" />   </returns>
		public Linphone.Config CreateConfigFromString(string data)
		{
			IntPtr ptr = linphone_factory_create_config_from_string(nativePtr, data);
			Linphone.Config returnVal = fromNativePtr<Linphone.Config>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_config_with_factory(IntPtr thiz, string path, string factoryPath);

		/// <summary>
		/// Creates an object <see cref="Linphone.Config" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="path">the path of the config   </param>
		/// <param name="factoryPath">the path of the factory   </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Config" />   </returns>
		public Linphone.Config CreateConfigWithFactory(string path, string factoryPath)
		{
			IntPtr ptr = linphone_factory_create_config_with_factory(nativePtr, path, factoryPath);
			Linphone.Config returnVal = fromNativePtr<Linphone.Config>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_content(IntPtr thiz);

		/// <summary>
		/// Creates an object <see cref="Linphone.Content" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Content" />   </returns>
		public Linphone.Content CreateContent()
		{
			IntPtr ptr = linphone_factory_create_content(nativePtr);
			Linphone.Content returnVal = fromNativePtr<Linphone.Content>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_core_3(IntPtr thiz, string configPath, string factoryConfigPath, IntPtr systemContext);

		/// <summary>
		/// Instantiate a <see cref="Linphone.Core" /> object. 
		/// <para>
		/// The <see cref="Linphone.Core" /> object is the primary handle for doing all
		/// phone actions. It should be unique within your application. The <see
		/// cref="Linphone.Core" /> object is not started automatically, you need to call
		/// <see cref="Linphone.Core.Start()" /> to that effect. The returned <see
		/// cref="Linphone.Core" /> will be in LinphoneGlobalState Ready. Core ressources
		/// can be released using <see cref="Linphone.Core.Stop()" /> which is strongly
		/// encouraged on garbage collected languages. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="configPath">A path to a config file. If it does not exists it will
		/// be created. The config file is used to store all settings, proxies... so that
		/// all these settings become persistent over the life of the <see
		/// cref="Linphone.Core" /> object. It is allowed to set a null config file. In
		/// that case <see cref="Linphone.Core" /> will not store any settings.   </param>
		/// <param name="factoryConfigPath">A path to a read-only config file that can be
		/// used to store hard-coded preferences such as proxy settings or internal
		/// preferences. The settings in this factory file always override the ones in the
		/// normal config file. It is optional, use null if unneeded.   </param>
		/// <param name="systemContext">A pointer to a system object required by the core
		/// to operate. Currently it is required to pass an android Context on android,
		/// pass null on other platforms.   </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Core" /> object   </returns>
		/// 
		/// <remarks>See : linphone_core_new_with_config_3() </remarks>
		public Linphone.Core CreateCore(string configPath, string factoryConfigPath, IntPtr systemContext)
		{
			IntPtr ptr = linphone_factory_create_core_3(nativePtr, configPath, factoryConfigPath, systemContext);
			Linphone.Core returnVal = fromNativePtr<Linphone.Core>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_core_with_config_3(IntPtr thiz, IntPtr config, IntPtr systemContext);

		/// <summary>
		/// Instantiate a <see cref="Linphone.Core" /> object with a given LinphoneConfig. 
		/// <para>
		/// The <see cref="Linphone.Core" /> object is the primary handle for doing all
		/// phone actions. It should be unique within your application. The <see
		/// cref="Linphone.Core" /> object is not started automatically, you need to call
		/// <see cref="Linphone.Core.Start()" /> to that effect. The returned <see
		/// cref="Linphone.Core" /> will be in LinphoneGlobalState Ready. Core ressources
		/// can be released using <see cref="Linphone.Core.Stop()" /> which is strongly
		/// encouraged on garbage collected languages. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="config">A <see cref="Linphone.Config" /> object holding the
		/// configuration for the <see cref="Linphone.Core" /> to be instantiated.  
		/// </param>
		/// <param name="systemContext">A pointer to a system object required by the core
		/// to operate. Currently it is required to pass an android Context on android,
		/// pass null on other platforms.   </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Core" /> object   </returns>
		/// 
		/// <remarks>See : <see cref="Linphone.Factory.CreateCore()" /> </remarks>
		public Linphone.Core CreateCoreWithConfig(Linphone.Config config, IntPtr systemContext)
		{
			IntPtr ptr = linphone_factory_create_core_with_config_3(nativePtr, config != null ? config.nativePtr : IntPtr.Zero, systemContext);
			Linphone.Core returnVal = fromNativePtr<Linphone.Core>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_error_info(IntPtr thiz);

		/// <summary>
		/// Creates an object LinphoneErrorInfo. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.ErrorInfo" /> object.   </returns>
		public Linphone.ErrorInfo CreateErrorInfo()
		{
			IntPtr ptr = linphone_factory_create_error_info(nativePtr);
			Linphone.ErrorInfo returnVal = fromNativePtr<Linphone.ErrorInfo>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_participant_device_identity(IntPtr thiz, IntPtr address, string name);

		/// <summary>
		/// Create a <see cref="Linphone.ParticipantDeviceIdentity" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address" /> object.   </param>
		/// <param name="name">the name given to the device.   </param>
		/// 
		/// 
		/// <returns>A new <see cref="Linphone.ParticipantDeviceIdentity" />.   </returns>
		public Linphone.ParticipantDeviceIdentity CreateParticipantDeviceIdentity(Linphone.Address address, string name)
		{
			IntPtr ptr = linphone_factory_create_participant_device_identity(nativePtr, address != null ? address.nativePtr : IntPtr.Zero, name);
			Linphone.ParticipantDeviceIdentity returnVal = fromNativePtr<Linphone.ParticipantDeviceIdentity>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_range(IntPtr thiz);

		/// <summary>
		/// Creates an object LinphoneRange. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Range" /> object.   </returns>
		public Linphone.Range CreateRange()
		{
			IntPtr ptr = linphone_factory_create_range(nativePtr);
			Linphone.Range returnVal = fromNativePtr<Linphone.Range>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_transports(IntPtr thiz);

		/// <summary>
		/// Creates an object LinphoneTransports. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Transports" /> object.   </returns>
		public Linphone.Transports CreateTransports()
		{
			IntPtr ptr = linphone_factory_create_transports(nativePtr);
			Linphone.Transports returnVal = fromNativePtr<Linphone.Transports>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_tunnel_config(IntPtr thiz);

		/// <summary>
		/// Creates an object <see cref="Linphone.TunnelConfig" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.TunnelConfig" />   </returns>
		public Linphone.TunnelConfig CreateTunnelConfig()
		{
			IntPtr ptr = linphone_factory_create_tunnel_config(nativePtr);
			Linphone.TunnelConfig returnVal = fromNativePtr<Linphone.TunnelConfig>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_vcard(IntPtr thiz);

		/// <summary>
		/// Create an empty <see cref="Linphone.Vcard" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a new <see cref="Linphone.Vcard" />.   </returns>
		public Linphone.Vcard CreateVcard()
		{
			IntPtr ptr = linphone_factory_create_vcard(nativePtr);
			Linphone.Vcard returnVal = fromNativePtr<Linphone.Vcard>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_video_activation_policy(IntPtr thiz);

		/// <summary>
		/// Creates an object LinphoneVideoActivationPolicy. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.VideoActivationPolicy" /> object.   </returns>
		public Linphone.VideoActivationPolicy CreateVideoActivationPolicy()
		{
			IntPtr ptr = linphone_factory_create_video_activation_policy(nativePtr);
			Linphone.VideoActivationPolicy returnVal = fromNativePtr<Linphone.VideoActivationPolicy>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_video_definition(IntPtr thiz, uint width, uint height);

		/// <summary>
		/// Create a <see cref="Linphone.VideoDefinition" /> from a given width and height. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="width">The width of the created video definition </param>
		/// <param name="height">The height of the created video definition </param>
		/// 
		/// 
		/// <returns>A new <see cref="Linphone.VideoDefinition" /> object   </returns>
		public Linphone.VideoDefinition CreateVideoDefinition(uint width, uint height)
		{
			IntPtr ptr = linphone_factory_create_video_definition(nativePtr, width, height);
			Linphone.VideoDefinition returnVal = fromNativePtr<Linphone.VideoDefinition>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_video_definition_from_name(IntPtr thiz, string name);

		/// <summary>
		/// Create a <see cref="Linphone.VideoDefinition" /> from a given standard
		/// definition name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">The standard definition name of the video definition to
		/// create   </param>
		/// 
		/// 
		/// <returns>A new <see cref="Linphone.VideoDefinition" /> object   </returns>
		public Linphone.VideoDefinition CreateVideoDefinitionFromName(string name)
		{
			IntPtr ptr = linphone_factory_create_video_definition_from_name(nativePtr, name);
			Linphone.VideoDefinition returnVal = fromNativePtr<Linphone.VideoDefinition>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_enable_log_collection(IntPtr thiz, int state);

		/// <summary>
		/// Enables or disables log collection. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="state">the LinphoneLogCollectionState for log collection </param>
		/// 
		public void EnableLogCollection(Linphone.LogCollectionState state)
		{
			linphone_factory_enable_log_collection(nativePtr, (int)state);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_config_dir(IntPtr thiz, IntPtr context);

		/// <summary>
		/// Get the config path. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="context">used to compute path. Can be null. JavaPlatformHelper on
		/// Android and char *appGroupId on iOS with shared core.   </param>
		/// 
		/// 
		/// <returns>The config path   </returns>
		public string GetConfigDir(IntPtr context)
		{
			IntPtr stringPtr = linphone_factory_get_config_dir(nativePtr, context);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_data_dir(IntPtr thiz, IntPtr context);

		/// <summary>
		/// Get the data path. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="context">used to compute path. Can be null. JavaPlatformHelper on
		/// Android and char *appGroupId on iOS with shared core.   </param>
		/// 
		/// 
		/// <returns>The data path   </returns>
		public string GetDataDir(IntPtr context)
		{
			IntPtr stringPtr = linphone_factory_get_data_dir(nativePtr, context);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_download_dir(IntPtr thiz, IntPtr context);

		/// <summary>
		/// Get the download path. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="context">used to compute path. Can be null. JavaPlatformHelper on
		/// Android and char *appGroupId on iOS with shared core.   </param>
		/// 
		/// 
		/// <returns>The download path   </returns>
		public string GetDownloadDir(IntPtr context)
		{
			IntPtr stringPtr = linphone_factory_get_download_dir(nativePtr, context);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_factory_is_chatroom_backend_available(IntPtr thiz, int chatroomBackend);

		/// <summary>
		/// Indicates if the given LinphoneChatRoomBackend is available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatroomBackend">the LinphoneChatRoomBackend </param>
		/// 
		/// 
		/// <returns>true if the chatroom backend is available, false otherwise </returns>
		public bool IsChatroomBackendAvailable(Linphone.ChatRoomBackend chatroomBackend)
		{
			bool returnVal = linphone_factory_is_chatroom_backend_available(nativePtr, (int)chatroomBackend) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_vfs_encryption(IntPtr thiz, uint encryptionModule, uint secret, long secretSize);

		/// <summary>
		/// Select encryption module and set secret material to encrypt the files. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="encryptionModule">One of the available encryption module for VFS,
		/// pick in the LINPHONE_VFS_ENCRYPTION_* list if set to _UNSET, default bctoolbox
		/// VFS is switch to Standard one </param>
		/// <param name="secret">the secret material used to encrypt the files, can be null
		/// for the _PLAIN module   </param>
		/// <param name="secretSize">size of the secret </param>
		/// 
		public void SetVfsEncryption(uint encryptionModule, uint secret, long secretSize)
		{
			linphone_factory_set_vfs_encryption(nativePtr, encryptionModule, secret, secretSize);
			
			
			
		}
	}
	/// <summary>
	/// This object is used to store a SIP address. 
	/// <para>
	/// <see cref="Linphone.Friend" /> is mainly used to implement an adressbook
	/// feature, and are used as data for the <see cref="Linphone.MagicSearch" />
	/// object. If your proxy supports it, you can also use it to subscribe to presence
	/// information.
	/// 
	/// The objects are stored in a <see cref="Linphone.FriendList" /> which are in
	/// turn stored inside the <see cref="Linphone.Core" />. They can be stored inside
	/// a database if the path to it is configured, otherwise they will be lost after
	/// the <see cref="Linphone.Core" /> is destroyed.
	/// 
	/// Thanks to the vCard plugin, you can also store more information like phone
	/// numbers, organization, etc... 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Friend : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_new_from_vcard(IntPtr vcard);

		/// <summary>
		/// Contructor same as linphone_friend_new + <see
		/// cref="Linphone.Friend.SetAddress()" /> 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="vcard">a <see cref="Linphone.Vcard" /> object   </param>
		/// 
		/// 
		/// <returns>a new <see cref="Linphone.Friend" /> with vCard initialized    
		/// </returns>
		public static Linphone.Friend NewFromVcard(Linphone.Vcard vcard)
		{
			IntPtr ptr = linphone_friend_new_from_vcard(vcard != null ? vcard.nativePtr : IntPtr.Zero);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_set_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Get address of this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Note : the <see cref="Linphone.Address" /> object returned is hold by
		/// the LinphoneFriend, however calling several time this function may return
		/// different objects. </remarks>
		/// 
		/// <returns>the <see cref="Linphone.Address" />.   </returns>
		public Linphone.Address Address
		{
			get
			{
				IntPtr ptr = linphone_friend_get_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				int exception_result = linphone_friend_set_address(nativePtr, value.nativePtr);
				if (exception_result != 0) throw new LinphoneException("Address setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_addresses(IntPtr thiz);

		/// <summary>
		/// Returns a list of <see cref="Linphone.Address" /> for this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Address" /> objects. LinphoneAddress   
		/// </returns>
		public IEnumerable<Linphone.Address> Addresses
		{
			get
			{
				return MarshalBctbxList<Linphone.Address>(linphone_friend_get_addresses(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_get_capabilities(IntPtr thiz);

		/// <summary>
		/// Returns the capabilities associated to this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>an int representing the capabilities of the friend </returns>
		public int Capabilities
		{
			get
			{
				return linphone_friend_get_capabilities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConsolidatedPresence linphone_friend_get_consolidated_presence(IntPtr thiz);

		/// <summary>
		/// Get the consolidated presence of a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneConsolidatedPresence of the friend </returns>
		public Linphone.ConsolidatedPresence ConsolidatedPresence
		{
			get
			{
				return linphone_friend_get_consolidated_presence(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_core(IntPtr thiz);

		/// <summary>
		/// Returns the <see cref="Linphone.Core" /> object managing this friend, if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Core" /> object associated.   </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_friend_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SubscribePolicy linphone_friend_get_inc_subscribe_policy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_set_inc_subscribe_policy(IntPtr thiz, int policy);

		/// <summary>
		/// get current subscription policy for this <see cref="Linphone.Friend" /> 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the LinphoneSubscribePolicy enum </returns>
		public Linphone.SubscribePolicy IncSubscribePolicy
		{
			get
			{
				return linphone_friend_get_inc_subscribe_policy(nativePtr);
			}
			set
			{
				int exception_result = linphone_friend_set_inc_subscribe_policy(nativePtr, (int)value);
				if (exception_result != 0) throw new LinphoneException("IncSubscribePolicy setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_is_presence_received(IntPtr thiz);

		/// <summary>
		/// Tells whether we already received presence information for a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if presence information has been received for the friend, false
		/// otherwise. </returns>
		public bool IsPresenceReceived
		{
			get
			{
				return linphone_friend_is_presence_received(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_set_name(IntPtr thiz, string name);

		/// <summary>
		/// Get the display name for this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The display name of this friend.   </returns>
		public string Name
		{
			get
			{
				IntPtr stringPtr = linphone_friend_get_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_friend_set_name(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Name setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_phone_numbers(IntPtr thiz);

		/// <summary>
		/// Returns a list of phone numbers for this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of const char * objects. const char *    </returns>
		public IEnumerable<string> PhoneNumbers
		{
			get
			{
				return MarshalStringArray(linphone_friend_get_phone_numbers(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_presence_model(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_presence_model(IntPtr thiz, IntPtr presence);

		/// <summary>
		/// Get the presence model of a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.PresenceModel" /> object, or null if the friend
		/// do not have presence information (in which case he is considered offline).  
		/// </returns>
		public Linphone.PresenceModel PresenceModel
		{
			get
			{
				IntPtr ptr = linphone_friend_get_presence_model(nativePtr);
				Linphone.PresenceModel obj = fromNativePtr<Linphone.PresenceModel>(ptr, true);
				return obj;
			}
			set
			{
				linphone_friend_set_presence_model(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_ref_key(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_ref_key(IntPtr thiz, string key);

		/// <summary>
		/// Get the reference key of a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The reference key of the friend.   </returns>
		public string RefKey
		{
			get
			{
				IntPtr stringPtr = linphone_friend_get_ref_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_set_ref_key(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_subscribes_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_enable_subscribes(IntPtr thiz, char enable);

		/// <summary>
		/// get subscription flag value 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>returns true is subscription is activated for this friend </returns>
		public bool SubscribesEnabled
		{
			get
			{
				return linphone_friend_subscribes_enabled(nativePtr) != 0;
			}
			set
			{
				int exception_result = linphone_friend_enable_subscribes(nativePtr, value ? (char)1 : (char)0);
				if (exception_result != 0) throw new LinphoneException("SubscribesEnabled setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SubscriptionState linphone_friend_get_subscription_state(IntPtr thiz);

		/// <summary>
		/// Get subscription state of a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the LinphoneSubscriptionState enum </returns>
		public Linphone.SubscriptionState SubscriptionState
		{
			get
			{
				return linphone_friend_get_subscription_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_vcard(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_vcard(IntPtr thiz, IntPtr vcard);

		/// <summary>
		/// Returns the vCard object associated to this friend, if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Vcard" /> or null.   </returns>
		public Linphone.Vcard Vcard
		{
			get
			{
				IntPtr ptr = linphone_friend_get_vcard(nativePtr);
				Linphone.Vcard obj = fromNativePtr<Linphone.Vcard>(ptr, true);
				return obj;
			}
			set
			{
				linphone_friend_set_vcard(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_add_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Adds an address in this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address" /> object   </param>
		/// 
		public void AddAddress(Linphone.Address address)
		{
			linphone_friend_add_address(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_add_phone_number(IntPtr thiz, string phoneNumber);

		/// <summary>
		/// Adds a phone number in this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">number to add   </param>
		/// 
		public void AddPhoneNumber(string phoneNumber)
		{
			linphone_friend_add_phone_number(nativePtr, phoneNumber);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_create_vcard(IntPtr thiz, string name);

		/// <summary>
		/// Creates a vCard object associated to this friend if there isn't one yet and if
		/// the full name is available, either by the parameter or the one in the friend's
		/// SIP URI. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">The full name of the friend or null to use the one from the
		/// friend's SIP URI   </param>
		/// 
		/// 
		/// <returns>true if the vCard has been created, false if it wasn't possible (for
		/// exemple if name and the friend's SIP URI are null or if the friend's SIP URI
		/// doesn't have a display name), or if there is already one vcard </returns>
		public bool CreateVcard(string name)
		{
			bool returnVal = linphone_friend_create_vcard(nativePtr, name) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_done(IntPtr thiz);

		/// <summary>
		/// Commits modification made to the friend configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void Done()
		{
			linphone_friend_done(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_edit(IntPtr thiz);

		/// <summary>
		/// Starts editing a friend configuration. 
		/// <para>
		/// Because friend configuration must be consistent, applications MUST call <see
		/// cref="Linphone.Friend.Edit()" /> before doing any attempts to modify friend
		/// configuration (such as address  or subscription policy and so on). Once the
		/// modifications are done, then the application must call <see
		/// cref="Linphone.Friend.Done()" /> to commit the changes. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void Edit()
		{
			linphone_friend_edit(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_friend_get_capability_version(IntPtr thiz, int capability);

		/// <summary>
		/// Returns the version of a friend's capbility. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">LinphoneFriendCapability object </param>
		/// 
		/// 
		/// <returns>the version of a friend's capbility. </returns>
		public float GetCapabilityVersion(Linphone.FriendCapability capability)
		{
			float returnVal = linphone_friend_get_capability_version(nativePtr, (int)capability);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_presence_model_for_uri_or_tel(IntPtr thiz, string uriOrTel);

		/// <summary>
		/// Get the presence model for a specific SIP URI or phone number of a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uriOrTel">The SIP URI or phone number for which to get the
		/// presence model   </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.PresenceModel" /> object, or null if the friend
		/// do not have presence information for this SIP URI or phone number.   </returns>
		public Linphone.PresenceModel GetPresenceModelForUriOrTel(string uriOrTel)
		{
			IntPtr ptr = linphone_friend_get_presence_model_for_uri_or_tel(nativePtr, uriOrTel);
			Linphone.PresenceModel returnVal = fromNativePtr<Linphone.PresenceModel>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_has_capability(IntPtr thiz, int capability);

		/// <summary>
		/// Returns whether or not a friend has a capbility. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">LinphoneFriendCapability object </param>
		/// 
		/// 
		/// <returns>whether or not a friend has a capbility </returns>
		public bool HasCapability(Linphone.FriendCapability capability)
		{
			bool returnVal = linphone_friend_has_capability(nativePtr, (int)capability) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_has_capability_with_version(IntPtr thiz, int capability, float version);

		/// <summary>
		/// Returns whether or not a friend has a capbility with a given version. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">LinphoneFriendCapability object </param>
		/// <param name="version">the version to test </param>
		/// 
		/// 
		/// <returns>whether or not a friend has a capbility with a given version or -1.0
		/// if friend has not capability. </returns>
		public bool HasCapabilityWithVersion(Linphone.FriendCapability capability, float version)
		{
			bool returnVal = linphone_friend_has_capability_with_version(nativePtr, (int)capability, version) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_has_capability_with_version_or_more(IntPtr thiz, int capability, float version);

		/// <summary>
		/// Returns whether or not a friend has a capbility with a given version or more. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">LinphoneFriendCapability object </param>
		/// <param name="version">the version to test </param>
		/// 
		/// 
		/// <returns>whether or not a friend has a capbility with a given version or more.
		/// </returns>
		public bool HasCapabilityWithVersionOrMore(Linphone.FriendCapability capability, float version)
		{
			bool returnVal = linphone_friend_has_capability_with_version_or_more(nativePtr, (int)capability, version) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_has_phone_number(IntPtr thiz, string phoneNumber);

		/// <summary>
		/// Returns whether a friend contains the given phone number. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">the phone number to search for   </param>
		/// 
		/// 
		/// <returns>true if found, false otherwise </returns>
		public bool HasPhoneNumber(string phoneNumber)
		{
			bool returnVal = linphone_friend_has_phone_number(nativePtr, phoneNumber) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_in_list(IntPtr thiz);

		/// <summary>
		/// Check that the given friend is in a friend list. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the friend is in a friend list, false otherwise. </returns>
		public bool InList()
		{
			bool returnVal = linphone_friend_in_list(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_remove(IntPtr thiz);

		/// <summary>
		/// Removes a friend from it's friend list and from the rc if exists. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void Remove()
		{
			linphone_friend_remove(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_remove_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Removes an address in this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address" /> object   </param>
		/// 
		public void RemoveAddress(Linphone.Address address)
		{
			linphone_friend_remove_address(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_remove_phone_number(IntPtr thiz, string phoneNumber);

		/// <summary>
		/// Removes a phone number in this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">number to remove   </param>
		/// 
		public void RemovePhoneNumber(string phoneNumber)
		{
			linphone_friend_remove_phone_number(nativePtr, phoneNumber);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_save(IntPtr thiz, IntPtr core);

		/// <summary>
		/// Saves a friend either in database if configured, otherwise in linphonerc. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the linphone core   </param>
		/// 
		public void Save(Linphone.Core core)
		{
			linphone_friend_save(nativePtr, core != null ? core.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_presence_model_for_uri_or_tel(IntPtr thiz, string uriOrTel, IntPtr presence);

		/// <summary>
		/// Set the presence model for a specific SIP URI or phone number of a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uriOrTel">The SIP URI or phone number for which to set the
		/// presence model   </param>
		/// <param name="presence">The <see cref="Linphone.PresenceModel" /> object to set 
		///  </param>
		/// 
		public void SetPresenceModelForUriOrTel(string uriOrTel, Linphone.PresenceModel presence)
		{
			linphone_friend_set_presence_model_for_uri_or_tel(nativePtr, uriOrTel, presence != null ? presence.nativePtr : IntPtr.Zero);
			
			
			
		}
	}
	/// <summary>
	/// This object representing a list of <see cref="Linphone.Friend" />. 
	/// <para>
	/// You can use it to store contacts locally or synchronize them through CardDAV
	/// protocol. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class FriendList : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_friend_list_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_remove_callbacks(IntPtr thiz, IntPtr cbs);

		~FriendList() 
		{
			if (listener != null)
			{
				linphone_friend_list_remove_callbacks(nativePtr, listener.nativePtr);
			}
		}

		private FriendListListener listener;

		public FriendListListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_friend_list_cbs(linphone_factory_get());
					listener = fromNativePtr<FriendListListener>(nativeListener, false);
					linphone_friend_list_add_callbacks(nativePtr, nativeListener);
					listener.register();
				}
				return listener;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_core(IntPtr thiz);

		/// <summary>
		/// Returns the <see cref="Linphone.Core" /> object attached to this
		/// LinphoneFriendList. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Core" /> object   </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_friend_list_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_current_callbacks(IntPtr thiz);

		/// <summary>
		/// Get the current LinphoneFriendListCbs object associated with a
		/// LinphoneFriendList. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current LinphoneFriendListCbs object associated with the
		/// LinphoneFriendList.   </returns>
		public Linphone.FriendListListener CurrentCallbacks
		{
			get
			{
				IntPtr ptr = linphone_friend_list_get_current_callbacks(nativePtr);
				Linphone.FriendListListener obj = fromNativePtr<Linphone.FriendListListener>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_display_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_set_display_name(IntPtr thiz, string displayName);

		/// <summary>
		/// Get the display name of the friend list. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The display name of the friend list.   </returns>
		public string DisplayName
		{
			get
			{
				IntPtr stringPtr = linphone_friend_list_get_display_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_list_set_display_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_friends(IntPtr thiz);

		/// <summary>
		/// Retrieves the list of <see cref="Linphone.Friend" /> from this
		/// LinphoneFriendList. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Friend" /> objects. LinphoneFriend  a
		/// list of <see cref="Linphone.Friend" />   </returns>
		public IEnumerable<Linphone.Friend> Friends
		{
			get
			{
				return MarshalBctbxList<Linphone.Friend>(linphone_friend_list_get_friends(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_list_is_subscription_bodyless(IntPtr thiz);

		/// <summary>
		/// Get wheter the subscription of the friend list is bodyless or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Wheter the subscription of the friend list is bodyless or not.
		/// </returns>
		public bool IsSubscriptionBodyless
		{
			get
			{
				return linphone_friend_list_is_subscription_bodyless(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_rls_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_set_rls_address(IntPtr thiz, IntPtr rlsAddr);

		/// <summary>
		/// Get the RLS (Resource List Server) URI associated with the friend list to
		/// subscribe to these friends presence. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The RLS URI as <see cref="Linphone.Address" /> associated with the
		/// friend list.   </returns>
		public Linphone.Address RlsAddress
		{
			get
			{
				IntPtr ptr = linphone_friend_list_get_rls_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_friend_list_set_rls_address(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_rls_uri(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_set_rls_uri(IntPtr thiz, string rlsUri);

		/// <summary>
		/// Get the RLS (Resource List Server) URI associated with the friend list to
		/// subscribe to these friends presence. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The RLS URI associated with the friend list.   </returns>
		/// 
		/// deprecated : 27/10/2020. Use <see cref="Linphone.FriendList.GetRlsAddress()" />
		/// instead. 
		public string RlsUri
		{
			get
			{
				IntPtr stringPtr = linphone_friend_list_get_rls_uri(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_list_set_rls_uri(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_set_subscription_bodyless(IntPtr thiz, char bodyless);

		/// <summary>
		/// Set wheter the subscription of the friend list is bodyless or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="bodyless">boolean telling if the subscription of the friend list
		/// is bodyless or not. </param>
		/// 
		public bool SubscriptionBodyless
		{
			set
			{
				linphone_friend_list_set_subscription_bodyless(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_list_subscriptions_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_enable_subscriptions(IntPtr thiz, char enabled);

		/// <summary>
		/// Gets whether subscription to NOTIFYes of all friends list are enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Whether subscriptions are enabled or not </returns>
		public bool SubscriptionsEnabled
		{
			get
			{
				return linphone_friend_list_subscriptions_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_friend_list_enable_subscriptions(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_uri(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_set_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Get the URI associated with the friend list. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The URI associated with the friend list.   </returns>
		public string Uri
		{
			get
			{
				IntPtr stringPtr = linphone_friend_list_get_uri(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_list_set_uri(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.FriendListStatus linphone_friend_list_add_friend(IntPtr thiz, IntPtr linphoneFriend);

		/// <summary>
		/// Add a friend to a friend list. 
		/// <para>
		/// If or when a remote CardDAV server will be attached to the list, the friend
		/// will be sent to the server. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend"><see cref="Linphone.Friend" /> object to add to
		/// the friend list.   </param>
		/// 
		/// 
		/// <returns>LinphoneFriendListOK if successfully added,
		/// LinphoneFriendListInvalidFriend if the friend is not valid. </returns>
		public Linphone.FriendListStatus AddFriend(Linphone.Friend linphoneFriend)
		{
			Linphone.FriendListStatus returnVal = linphone_friend_list_add_friend(nativePtr, linphoneFriend != null ? linphoneFriend.nativePtr : IntPtr.Zero);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.FriendListStatus linphone_friend_list_add_local_friend(IntPtr thiz, IntPtr linphoneFriend);

		/// <summary>
		/// Add a friend to a friend list. 
		/// <para>
		/// The friend will never be sent to a remote CardDAV server. Warning!
		/// #LinphoneFriends added this way will be removed on the next synchronization,
		/// and the callback contact_deleted will be called. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend"><see cref="Linphone.Friend" /> object to add to
		/// the friend list.   </param>
		/// 
		/// 
		/// <returns>LinphoneFriendListOK if successfully added,
		/// LinphoneFriendListInvalidFriend if the friend is not valid. </returns>
		public Linphone.FriendListStatus AddLocalFriend(Linphone.Friend linphoneFriend)
		{
			Linphone.FriendListStatus returnVal = linphone_friend_list_add_local_friend(nativePtr, linphoneFriend != null ? linphoneFriend.nativePtr : IntPtr.Zero);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_export_friends_as_vcard4_file(IntPtr thiz, string vcardFile);

		/// <summary>
		/// Creates and export <see cref="Linphone.Friend" /> objects from <see
		/// cref="Linphone.FriendList" /> to a file using vCard 4 format. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="vcardFile">the path to a file that will contain the vCards  
		/// </param>
		/// 
		public void ExportFriendsAsVcard4File(string vcardFile)
		{
			linphone_friend_list_export_friends_as_vcard4_file(nativePtr, vcardFile);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_find_friend_by_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Find a friend in the friend list using a LinphoneAddress. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address" /> object of the friend we
		/// want to search for.   </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Friend" /> if found, null otherwise.   </returns>
		public Linphone.Friend FindFriendByAddress(Linphone.Address address)
		{
			IntPtr ptr = linphone_friend_list_find_friend_by_address(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_find_friend_by_phone_number(IntPtr thiz, string phoneNumber);

		/// <summary>
		/// Find a friend in the friend list using a phone number. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">a string of the phone number for which we want to
		/// find a friend.   </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Friend" /> if found, null otherwise.   </returns>
		public Linphone.Friend FindFriendByPhoneNumber(string phoneNumber)
		{
			IntPtr ptr = linphone_friend_list_find_friend_by_phone_number(nativePtr, phoneNumber);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_find_friend_by_ref_key(IntPtr thiz, string refKey);

		/// <summary>
		/// Find a friend in the friend list using a ref key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="refKey">The ref key string of the friend we want to search for.  
		/// </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Friend" /> if found, null otherwise.   </returns>
		public Linphone.Friend FindFriendByRefKey(string refKey)
		{
			IntPtr ptr = linphone_friend_list_find_friend_by_ref_key(nativePtr, refKey);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_find_friend_by_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Find a friend in the friend list using an URI string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">A string containing the URI of the friend we want to search
		/// for.   </param>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.Friend" /> if found, null otherwise.   </returns>
		public Linphone.Friend FindFriendByUri(string uri)
		{
			IntPtr ptr = linphone_friend_list_find_friend_by_uri(nativePtr, uri);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_find_friends_by_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Find all friends in the friend list using a LinphoneAddress. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address" /> object of the friends we
		/// want to search for.   </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Friend" /> objects. LinphoneFriend  as a
		/// list of <see cref="Linphone.Friend" /> if found, null otherwise.   </returns>
		public IEnumerable<Linphone.Friend> FindFriendsByAddress(Linphone.Address address)
		{
			IEnumerable<Linphone.Friend> returnVal = MarshalBctbxList<Linphone.Friend>(linphone_friend_list_find_friends_by_address(nativePtr, address != null ? address.nativePtr : IntPtr.Zero), true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_find_friends_by_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Find all friends in the friend list using an URI string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">A string containing the URI of the friends we want to search
		/// for.   </param>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Friend" /> objects. LinphoneFriend  as a
		/// list of <see cref="Linphone.Friend" /> if found, null otherwise.   </returns>
		public IEnumerable<Linphone.Friend> FindFriendsByUri(string uri)
		{
			IEnumerable<Linphone.Friend> returnVal = MarshalBctbxList<Linphone.Friend>(linphone_friend_list_find_friends_by_uri(nativePtr, uri), true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_list_import_friends_from_vcard4_buffer(IntPtr thiz, string vcardBuffer);

		/// <summary>
		/// Creates and adds <see cref="Linphone.Friend" /> objects to <see
		/// cref="Linphone.FriendList" /> from a buffer that contains the vCard(s) to
		/// parse. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="vcardBuffer">the buffer that contains the vCard(s) to parse  
		/// </param>
		/// 
		/// 
		/// <returns>the amount of linphone friends created </returns>
		public int ImportFriendsFromVcard4Buffer(string vcardBuffer)
		{
			int returnVal = linphone_friend_list_import_friends_from_vcard4_buffer(nativePtr, vcardBuffer);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_list_import_friends_from_vcard4_file(IntPtr thiz, string vcardFile);

		/// <summary>
		/// Creates and adds <see cref="Linphone.Friend" /> objects to <see
		/// cref="Linphone.FriendList" /> from a file that contains the vCard(s) to parse. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="vcardFile">the path to a file that contains the vCard(s) to parse 
		///  </param>
		/// 
		/// 
		/// <returns>the amount of linphone friends created </returns>
		public int ImportFriendsFromVcard4File(string vcardFile)
		{
			int returnVal = linphone_friend_list_import_friends_from_vcard4_file(nativePtr, vcardFile);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_notify_presence(IntPtr thiz, IntPtr presence);

		/// <summary>
		/// Notify our presence to all the friends in the friend list that have subscribed
		/// to our presence directly (not using a RLS). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="presence"><see cref="Linphone.PresenceModel" /> object.   </param>
		/// 
		public void NotifyPresence(Linphone.PresenceModel presence)
		{
			linphone_friend_list_notify_presence(nativePtr, presence != null ? presence.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.FriendListStatus linphone_friend_list_remove_friend(IntPtr thiz, IntPtr linphoneFriend);

		/// <summary>
		/// Remove a friend from a friend list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend"><see cref="Linphone.Friend" /> object to remove
		/// from the friend list.   </param>
		/// 
		/// 
		/// <returns>LinphoneFriendListOK if removed successfully,
		/// LinphoneFriendListNonExistentFriend if the friend is not in the list. </returns>
		public Linphone.FriendListStatus RemoveFriend(Linphone.Friend linphoneFriend)
		{
			Linphone.FriendListStatus returnVal = linphone_friend_list_remove_friend(nativePtr, linphoneFriend != null ? linphoneFriend.nativePtr : IntPtr.Zero);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_synchronize_friends_from_server(IntPtr thiz);

		/// <summary>
		/// Starts a CardDAV synchronization using value set using
		/// linphone_friend_list_set_uri. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void SynchronizeFriendsFromServer()
		{
			linphone_friend_list_synchronize_friends_from_server(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_update_dirty_friends(IntPtr thiz);

		/// <summary>
		/// Goes through all the <see cref="Linphone.Friend" /> that are dirty and does a
		/// CardDAV PUT to update the server. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void UpdateDirtyFriends()
		{
			linphone_friend_list_update_dirty_friends(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_update_revision(IntPtr thiz, int revision);

		/// <summary>
		/// Sets the revision from the last synchronization. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="revision">The revision </param>
		/// 
		public void UpdateRevision(int revision)
		{
			linphone_friend_list_update_revision(nativePtr, revision);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_update_subscriptions(IntPtr thiz);

		/// <summary>
		/// Update presence subscriptions for the entire list. 
		/// <para>
		/// Calling this function is necessary when list subscriptions are enabled, ie when
		/// a RLS presence server is used. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void UpdateSubscriptions()
		{
			linphone_friend_list_update_subscriptions(nativePtr);
			
			
			
		}
	}
	/// <summary>
	/// Object representing a chain of protocol headers. 
	/// <para>
	/// It provides read/write access to the headers of the underlying protocol. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Headers : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_headers_add(IntPtr thiz, string name, string val);

		/// <summary>
		/// Add given header name and corresponding value. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the header's name   </param>
		/// <param name="val">the header's value   </param>
		/// 
		public void Add(string name, string val)
		{
			linphone_headers_add(nativePtr, name, val);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_headers_get_value(IntPtr thiz, string headerName);

		/// <summary>
		/// Search for a given header name and return its value. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the header's value or null if not found.   </returns>
		public string GetValue(string headerName)
		{
			IntPtr stringPtr = linphone_headers_get_value(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_headers_remove(IntPtr thiz, string name);

		/// <summary>
		/// Add given header name and corresponding value. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the header's name   </param>
		/// 
		public void Remove(string name)
		{
			linphone_headers_remove(nativePtr, name);
			
			
			
		}
	}
	/// <summary>
	/// Policy to use to send/receive instant messaging composing/delivery/display
	/// notifications. 
	/// <para>
	/// The sending of this information is done as in the RFCs 3994 (is_composing) and
	/// 5438 (imdn delivered/displayed). 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ImNotifPolicy : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_recv_imdn_delivered(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_recv_imdn_delivered(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether imdn delivered notifications are being notified when received. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether imdn delivered notifications are being
		/// notified when received. </returns>
		public bool RecvImdnDelivered
		{
			get
			{
				return linphone_im_notif_policy_get_recv_imdn_delivered(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_recv_imdn_delivered(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_recv_imdn_displayed(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_recv_imdn_displayed(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether imdn displayed notifications are being notified when received. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether imdn displayed notifications are being
		/// notified when received. </returns>
		public bool RecvImdnDisplayed
		{
			get
			{
				return linphone_im_notif_policy_get_recv_imdn_displayed(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_recv_imdn_displayed(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_recv_is_composing(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_recv_is_composing(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether is_composing notifications are being notified when received. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether is_composing notifications are being
		/// notified when received. </returns>
		public bool RecvIsComposing
		{
			get
			{
				return linphone_im_notif_policy_get_recv_is_composing(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_recv_is_composing(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_send_imdn_delivered(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_send_imdn_delivered(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether imdn delivered notifications are being sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether imdn delivered notifications are being
		/// sent. </returns>
		public bool SendImdnDelivered
		{
			get
			{
				return linphone_im_notif_policy_get_send_imdn_delivered(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_send_imdn_delivered(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_send_imdn_displayed(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_send_imdn_displayed(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether imdn displayed notifications are being sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether imdn displayed notifications are being
		/// sent. </returns>
		public bool SendImdnDisplayed
		{
			get
			{
				return linphone_im_notif_policy_get_send_imdn_displayed(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_send_imdn_displayed(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_send_is_composing(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_send_is_composing(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether is_composing notifications are being sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether is_composing notifications are being
		/// sent. </returns>
		public bool SendIsComposing
		{
			get
			{
				return linphone_im_notif_policy_get_send_is_composing(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_send_is_composing(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_clear(IntPtr thiz);

		/// <summary>
		/// Clear an IM notif policy (deactivate all receiving and sending of
		/// notifications). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void Clear()
		{
			linphone_im_notif_policy_clear(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_enable_all(IntPtr thiz);

		/// <summary>
		/// Enable all receiving and sending of notifications. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void EnableAll()
		{
			linphone_im_notif_policy_enable_all(nativePtr);
			
			
			
		}
	}
	/// <summary>
	/// Object representing an informational message sent or received by the core. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class InfoMessage : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_info_message_get_content(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_info_message_set_content(IntPtr thiz, IntPtr content);

		/// <summary>
		/// Returns the info message's content as a <see cref="Linphone.Content" />
		/// structure. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Content" /> object.   </returns>
		public Linphone.Content Content
		{
			get
			{
				IntPtr ptr = linphone_info_message_get_content(nativePtr);
				Linphone.Content obj = fromNativePtr<Linphone.Content>(ptr, true);
				return obj;
			}
			set
			{
				linphone_info_message_set_content(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_info_message_add_header(IntPtr thiz, string name, string val);

		/// <summary>
		/// Add a header to an info message to be sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the header'name   </param>
		/// <param name="val">the header's value   </param>
		/// 
		public void AddHeader(string name, string val)
		{
			linphone_info_message_add_header(nativePtr, name, val);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_info_message_get_header(IntPtr thiz, string name);

		/// <summary>
		/// Obtain a header value from a received info message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the header'name   </param>
		/// 
		/// 
		/// <returns>the corresponding header's value, or null if not exists.   </returns>
		public string GetHeader(string name)
		{
			IntPtr stringPtr = linphone_info_message_get_header(nativePtr, name);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
	}
	/// <summary>
	/// Singleton class giving access to logging features. 
	/// <para>
	/// It supports custom domain, writing into a file as well as several verbosity
	/// levels. The LinphoneLoggingServiceCbs listener allows you to be notified each
	/// time a log is printed.
	/// 
	/// As the <see cref="Linphone.LoggingService" /> is a singleton, use <see
	/// cref="Linphone.LoggingService.Get()" /> to get it. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class LoggingService : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_logging_service_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_logging_service_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_logging_service_remove_callbacks(IntPtr thiz, IntPtr cbs);

		~LoggingService() 
		{
			if (listener != null)
			{
				linphone_logging_service_remove_callbacks(nativePtr, listener.nativePtr);
			}
		}

		private LoggingServiceListener listener;

		public LoggingServiceListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_logging_service_cbs(linphone_factory_get());
					listener = fromNativePtr<LoggingServiceListener>(nativeListener, false);
					linphone_logging_service_add_callbacks(nativePtr, nativeListener);
					listener.register();
				}
				return listener;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_logging_service_get();

		/// <summary>
		/// Gets the singleton logging service object. 
		/// <para>
		/// The singleton is automatically instantiated if it hasn't been done yet.
		/// 
		/// </para>
		/// </summary>
		/// <returns>A pointer on the <see cref="Linphone.LoggingService" /> singleton.  
		/// </returns>
		static public Linphone.LoggingService Instance
		{
			get
			{
				IntPtr ptr = linphone_logging_service_get();
				Linphone.LoggingService obj = fromNativePtr<Linphone.LoggingService>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_logging_service_get_current_callbacks(IntPtr thiz);

		/// <summary>
		/// Returns the current callbacks being called while iterating on callbacks. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A pointer to the current LinphoneLoggingServiceCbs object   </returns>
		public Linphone.LoggingServiceListener CurrentCallbacks
		{
			get
			{
				IntPtr ptr = linphone_logging_service_get_current_callbacks(nativePtr);
				Linphone.LoggingServiceListener obj = fromNativePtr<Linphone.LoggingServiceListener>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_logging_service_get_domain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_set_domain(IntPtr thiz, string domain);

		/// <summary>
		/// Get the domain where application logs are written (for example with <see
		/// cref="Linphone.LoggingService.Message()" />). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The domain where application logs are written.   </returns>
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_logging_service_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_logging_service_set_domain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_set_log_level(IntPtr thiz, int level);

		/// <summary>
		/// Set the verbosity of the log. 
		/// <para>
		/// For instance, a level of LinphoneLogLevelMessage will let pass fatal, error,
		/// warning and message-typed messages whereas trace and debug messages will be
		/// dumped out. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="level">the LinphoneLogLevel to set </param>
		/// 
		public Linphone.LogLevel LogLevel
		{
			set
			{
				linphone_logging_service_set_log_level(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_logging_service_get_log_level_mask(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_set_log_level_mask(IntPtr thiz, uint mask);

		/// <summary>
		/// Gets the log level mask. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the log level mask </returns>
		public uint LogLevelMask
		{
			get
			{
				return linphone_logging_service_get_log_level_mask(nativePtr);
			}
			set
			{
				linphone_logging_service_set_log_level_mask(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_debug(IntPtr thiz, string message);

		/// <summary>
		/// Write a LinphoneLogLevelDebug message to the logs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The log message.   </param>
		/// 
		public void Debug(string message)
		{
			linphone_logging_service_debug(nativePtr, message);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_error(IntPtr thiz, string message);

		/// <summary>
		/// Write a LinphoneLogLevelError message to the logs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The log message.   </param>
		/// 
		public void Error(string message)
		{
			linphone_logging_service_error(nativePtr, message);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_fatal(IntPtr thiz, string message);

		/// <summary>
		/// Write a LinphoneLogLevelFatal message to the logs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The log message.   </param>
		/// 
		public void Fatal(string message)
		{
			linphone_logging_service_fatal(nativePtr, message);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_message(IntPtr thiz, string message);

		/// <summary>
		/// Write a LinphoneLogLevelMessage message to the logs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The log message.   </param>
		/// 
		public void Message(string message)
		{
			linphone_logging_service_message(nativePtr, message);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_set_log_file(IntPtr thiz, string dir, string filename, long maxSize);

		/// <summary>
		/// Enables logging in a file. 
		/// <para>
		/// That function enables an internal log handler that writes log messages in
		/// log-rotated files.
		/// 
		/// </para>
		/// </summary>
		/// <param name="dir">Directory where to create the distinct parts of the log.  
		/// </param>
		/// <param name="filename">Name of the log file.   </param>
		/// <param name="maxSize">The maximal size of each part of the log. The log
		/// rotating is triggered each time the currently opened log part reach that limit.
		/// </param>
		/// 
		public void SetLogFile(string dir, string filename, long maxSize)
		{
			linphone_logging_service_set_log_file(nativePtr, dir, filename, maxSize);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_trace(IntPtr thiz, string message);

		/// <summary>
		/// Write a LinphoneLogLevelTrace message to the logs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The log message.   </param>
		/// 
		public void Trace(string message)
		{
			linphone_logging_service_trace(nativePtr, message);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_warning(IntPtr thiz, string message);

		/// <summary>
		/// Write a LinphoneLogLevelWarning message to the logs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The log message.   </param>
		/// 
		public void Warning(string message)
		{
			linphone_logging_service_warning(nativePtr, message);
			
			
			
		}
	}
	/// <summary>
	/// A <see cref="Linphone.MagicSearch" /> is used to do specifics searchs. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class MagicSearch : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_magic_search_get_delimiter(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_set_delimiter(IntPtr thiz, string delimiter);

		/// <summary>
		/// Get the delimiter used for the search. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the delimiter used to find matched filter word   </returns>
		public string Delimiter
		{
			get
			{
				IntPtr stringPtr = linphone_magic_search_get_delimiter(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_magic_search_set_delimiter(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_magic_search_get_limited_search(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_set_limited_search(IntPtr thiz, char limited);

		/// <summary>
		/// Return whether or not the search is limited. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the search is limited, false otherwise </returns>
		public bool LimitedSearch
		{
			get
			{
				return linphone_magic_search_get_limited_search(nativePtr) != 0;
			}
			set
			{
				linphone_magic_search_set_limited_search(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_magic_search_get_max_weight(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_set_max_weight(IntPtr thiz, uint weight);

		/// <summary>
		/// Get the maximum value used to calculate the weight in search. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the maximum value used to calculate the weight in search </returns>
		public uint MaxWeight
		{
			get
			{
				return linphone_magic_search_get_max_weight(nativePtr);
			}
			set
			{
				linphone_magic_search_set_max_weight(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_magic_search_get_min_weight(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_set_min_weight(IntPtr thiz, uint weight);

		/// <summary>
		/// Get the minimum value used to calculate the weight in search. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the minimum value used to calculate the weight in search </returns>
		public uint MinWeight
		{
			get
			{
				return linphone_magic_search_get_min_weight(nativePtr);
			}
			set
			{
				linphone_magic_search_set_min_weight(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_magic_search_get_search_limit(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_set_search_limit(IntPtr thiz, uint limit);

		/// <summary>
		/// Get the number of maximum search result the search will return. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the number of the maximum <see cref="Linphone.SearchResult" /> which
		/// will be returned </returns>
		public uint SearchLimit
		{
			get
			{
				return linphone_magic_search_get_search_limit(nativePtr);
			}
			set
			{
				linphone_magic_search_set_search_limit(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_magic_search_get_use_delimiter(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_set_use_delimiter(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether the delimiter is being used for the search. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>if the delimiter search is used </returns>
		public bool UseDelimiter
		{
			get
			{
				return linphone_magic_search_get_use_delimiter(nativePtr) != 0;
			}
			set
			{
				linphone_magic_search_set_use_delimiter(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_magic_search_get_contact_list_from_filter(IntPtr thiz, string filter, string domain);

		/// <summary>
		/// Create a sorted list of SearchResult from SipUri, Contact name, Contact
		/// displayname, Contact phone number, which match with a filter word The last item
		/// list will be an address formed with "filter" if a proxy config exist During the
		/// first search, a cache is created and used for the next search Use <see
		/// cref="Linphone.MagicSearch.ResetSearchCache()" /> to begin a new search. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filter">word we search   </param>
		/// <param name="domain">domain which we want to search only  
		/// </param>
		/// 
		/// 
		/// <returns>sorted list of A list of <see cref="Linphone.SearchResult" /> objects.
		/// LinphoneSearchResult      </returns>
		public IEnumerable<Linphone.SearchResult> GetContactListFromFilter(string filter, string domain)
		{
			IEnumerable<Linphone.SearchResult> returnVal = MarshalBctbxList<Linphone.SearchResult>(linphone_magic_search_get_contact_list_from_filter(nativePtr, filter, domain), false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_reset_search_cache(IntPtr thiz);

		/// <summary>
		/// Reset the cache to begin a new search. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void ResetSearchCache()
		{
			linphone_magic_search_reset_search_cache(nativePtr);
			
			
			
		}
	}
	/// <summary>
	/// Policy to use to pass through NATs/firewalls. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class NatPolicy : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_nat_policy_get_core(IntPtr thiz);

		/// <summary>
		/// Returns the <see cref="Linphone.Core" /> object managing this nat policy, if
		/// any. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Core" /> object associated.   </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_nat_policy_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_ice_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_ice(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether ICE is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether ICE is enabled. </returns>
		public bool IceEnabled
		{
			get
			{
				return linphone_nat_policy_ice_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_ice(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_stun_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_stun(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether STUN is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether STUN is enabled. </returns>
		public bool StunEnabled
		{
			get
			{
				return linphone_nat_policy_stun_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_stun(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_nat_policy_get_stun_server(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_set_stun_server(IntPtr thiz, string stunServer);

		/// <summary>
		/// Get the STUN/TURN server to use with this NAT policy. 
		/// <para>
		/// Used when STUN or TURN are enabled. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The STUN server used by this NAT policy.   </returns>
		public string StunServer
		{
			get
			{
				IntPtr stringPtr = linphone_nat_policy_get_stun_server(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_nat_policy_set_stun_server(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_nat_policy_get_stun_server_username(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_set_stun_server_username(IntPtr thiz, string username);

		/// <summary>
		/// Get the username used to authenticate with the STUN/TURN server. 
		/// <para>
		/// The authentication will search for a <see cref="Linphone.AuthInfo" /> with this
		/// username. If it is not set the username of the currently used <see
		/// cref="Linphone.ProxyConfig" /> is used to search for a LinphoneAuthInfo. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The username used to authenticate with the STUN/TURN server.  
		/// </returns>
		public string StunServerUsername
		{
			get
			{
				IntPtr stringPtr = linphone_nat_policy_get_stun_server_username(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_nat_policy_set_stun_server_username(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_tcp_turn_transport_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_tcp_turn_transport(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether TCP TURN transport is enabled. 
		/// <para>
		/// Used when TURN is enabled. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether TCP TURN transport is enabled. </returns>
		public bool TcpTurnTransportEnabled
		{
			get
			{
				return linphone_nat_policy_tcp_turn_transport_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_tcp_turn_transport(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_tls_turn_transport_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_tls_turn_transport(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether TLS TURN transport is enabled. 
		/// <para>
		/// Used when TURN is enabled. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether TLS TURN transport is enabled. </returns>
		public bool TlsTurnTransportEnabled
		{
			get
			{
				return linphone_nat_policy_tls_turn_transport_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_tls_turn_transport(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_turn_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_turn(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether TURN is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether TURN is enabled. </returns>
		public bool TurnEnabled
		{
			get
			{
				return linphone_nat_policy_turn_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_turn(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_udp_turn_transport_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_udp_turn_transport(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether UDP TURN transport is enabled. 
		/// <para>
		/// Used when TURN is enabled. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether UDP TURN transport is enabled. </returns>
		public bool UdpTurnTransportEnabled
		{
			get
			{
				return linphone_nat_policy_udp_turn_transport_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_udp_turn_transport(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_upnp_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_upnp(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether uPnP is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Boolean value telling whether uPnP is enabled. </returns>
		public bool UpnpEnabled
		{
			get
			{
				return linphone_nat_policy_upnp_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_upnp(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_clear(IntPtr thiz);

		/// <summary>
		/// Clear a NAT policy (deactivate all protocols and unset the STUN server). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void Clear()
		{
			linphone_nat_policy_clear(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_resolve_stun_server(IntPtr thiz);

		/// <summary>
		/// Start a STUN server DNS resolution. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void ResolveStunServer()
		{
			linphone_nat_policy_resolve_stun_server(nativePtr);
			
			
			
		}
	}
	/// <summary>
	/// Identifies a member of a <see cref="Linphone.Conference" /> or <see
	/// cref="Linphone.ChatRoom" />. 
	/// <para>
	/// A participant is identified by it's SIP address. It can have many <see
	/// cref="Linphone.ParticipantDevice" />. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Participant : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_get_address(IntPtr thiz);

		/// <summary>
		/// Get the address of a conference participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The <see cref="Linphone.Address" /> of the participant   </returns>
		public Linphone.Address Address
		{
			get
			{
				IntPtr ptr = linphone_participant_get_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_participant_get_creation_time(IntPtr thiz);

		/// <summary>
		/// Get the timestamp of the creation of the participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>time of creation of the participant as returned by time(nullptr). For
		/// UNIX based systems it is the number of seconds since 00:00hours of the 1st of
		/// January 1970 </returns>
		public long CreationTime
		{
			get
			{
				return linphone_participant_get_creation_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_get_devices(IntPtr thiz);

		/// <summary>
		/// Gets the list of devices from a chat room's participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.ParticipantDevice" /> objects.
		/// LinphoneParticipantDevice    </returns>
		public IEnumerable<Linphone.ParticipantDevice> Devices
		{
			get
			{
				return MarshalBctbxList<Linphone.ParticipantDevice>(linphone_participant_get_devices(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_participant_is_admin(IntPtr thiz);

		/// <summary>
		/// Tells whether a conference participant is an administrator of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether the participant is an administrator
		/// </returns>
		public bool IsAdmin
		{
			get
			{
				return linphone_participant_is_admin(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_participant_is_focus(IntPtr thiz);

		/// <summary>
		/// Tells whether a conference participant is the focus of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether the participant is a focus of a
		/// conference </returns>
		public bool IsFocus
		{
			get
			{
				return linphone_participant_is_focus(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomSecurityLevel linphone_participant_get_security_level(IntPtr thiz);

		/// <summary>
		/// Get the security level of a participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneChatRoomSecurityLevel of the participant </returns>
		public Linphone.ChatRoomSecurityLevel SecurityLevel
		{
			get
			{
				return linphone_participant_get_security_level(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_find_device(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Find a device in the list of devices from a chat room's participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">A <see cref="Linphone.Address" /> object   </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.ParticipantDevice" /> or null if not found.  
		/// </returns>
		public Linphone.ParticipantDevice FindDevice(Linphone.Address address)
		{
			IntPtr ptr = linphone_participant_find_device(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			Linphone.ParticipantDevice returnVal = fromNativePtr<Linphone.ParticipantDevice>(ptr, true);
			
			return returnVal;
		}
	}
	/// <summary>
	/// This object represents a unique device for a member of a <see
	/// cref="Linphone.Conference" /> or <see cref="Linphone.ChatRoom" />. 
	/// <para>
	/// Devices are identified by the gruu parameter inside the <see
	/// cref="Linphone.Address" /> which can be obtained by <see
	/// cref="Linphone.ParticipantDevice.GetAddress()" />. It is specially usefull to
	/// know the security level of each device inside an end-to-end encrypted <see
	/// cref="Linphone.ChatRoom" />.
	/// 
	/// You can get a list of all <see cref="Linphone.ParticipantDevice" /> using <see
	/// cref="Linphone.Participant.GetDevices()" />. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ParticipantDevice : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_get_address(IntPtr thiz);

		/// <summary>
		/// Get the address of a participant's device. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The <see cref="Linphone.Address" /> of the participant's device  
		/// </returns>
		public Linphone.Address Address
		{
			get
			{
				IntPtr ptr = linphone_participant_device_get_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_participant_device_is_in_conference(IntPtr thiz);

		/// <summary>
		/// Return whether the participant device is in a conference or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a boolean to state whether the device is in a conference </returns>
		public bool IsInConference
		{
			get
			{
				return linphone_participant_device_is_in_conference(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_get_name(IntPtr thiz);

		/// <summary>
		/// Return the name of the device or null. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the name of the device or null.   </returns>
		public string Name
		{
			get
			{
				IntPtr stringPtr = linphone_participant_device_get_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomSecurityLevel linphone_participant_device_get_security_level(IntPtr thiz);

		/// <summary>
		/// Get the security level of a participant's device. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneChatRoomSecurityLevel of the device </returns>
		public Linphone.ChatRoomSecurityLevel SecurityLevel
		{
			get
			{
				return linphone_participant_device_get_security_level(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_participant_device_get_time_of_joining(IntPtr thiz);

		/// <summary>
		/// Get the timestamp the device joined a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>time of joining a conference as returned by time(nullptr). For UNIX
		/// based systems it is the number of seconds since 00:00hours of the 1st of
		/// January 1970 </returns>
		public long TimeOfJoining
		{
			get
			{
				return linphone_participant_device_get_time_of_joining(nativePtr);
			}
		}
	}
	/// <summary>
	/// This object is only used on server side for <see cref="Linphone.ChatRoom" />
	/// with LinphoneChatRoomBackendFlexisipChat backend. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ParticipantDeviceIdentity : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_identity_get_address(IntPtr thiz);

		/// <summary>
		/// Get the address of the participant device. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the address.   </returns>
		public Linphone.Address Address
		{
			get
			{
				IntPtr ptr = linphone_participant_device_identity_get_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_identity_get_capability_descriptor(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_participant_device_identity_set_capability_descriptor(IntPtr thiz, string capabilityDescriptor);

		/// <summary>
		/// Get the capability descriptor (currently +org.linphone.specs value) for this
		/// participant device identity. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the capability descriptor string. </returns>
		public string CapabilityDescriptor
		{
			get
			{
				IntPtr stringPtr = linphone_participant_device_identity_get_capability_descriptor(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_participant_device_identity_set_capability_descriptor(nativePtr, value);
				
			}
		}
	}
	/// <summary>
	/// This object represents the delivery/display state of a given chat message for a
	/// given participant. 
	/// <para>
	/// It also contains a timestamp at which this participant state has changed.
	/// 
	/// Use <see cref="Linphone.ChatMessage.GetParticipantsByImdnState()" /> to get all
	/// <see cref="Linphone.ParticipantImdnState" /> for a given state. From there use
	/// <see cref="Linphone.ParticipantImdnState.GetParticipant()" /> to get the <see
	/// cref="Linphone.Participant" /> object if you need it. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ParticipantImdnState : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_imdn_state_get_participant(IntPtr thiz);

		/// <summary>
		/// Get the participant concerned by a LinphoneParticipantImdnState. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The <see cref="Linphone.Participant" /> concerned by the
		/// LinphoneParticipantImdnState   </returns>
		public Linphone.Participant Participant
		{
			get
			{
				IntPtr ptr = linphone_participant_imdn_state_get_participant(nativePtr);
				Linphone.Participant obj = fromNativePtr<Linphone.Participant>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatMessageState linphone_participant_imdn_state_get_state(IntPtr thiz);

		/// <summary>
		/// Get the chat message state the participant is in. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneChatMessageState the participant is in </returns>
		public Linphone.ChatMessageState State
		{
			get
			{
				return linphone_participant_imdn_state_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_participant_imdn_state_get_state_change_time(IntPtr thiz);

		/// <summary>
		/// Get the timestamp at which a participant has reached the state described by a
		/// LinphoneParticipantImdnState. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The timestamp at which the participant has reached the state described
		/// in the LinphoneParticipantImdnState </returns>
		public long StateChangeTime
		{
			get
			{
				return linphone_participant_imdn_state_get_state_change_time(nativePtr);
			}
		}
	}
	/// <summary>
	/// Object representing an RTP payload type. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PayloadType : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_payload_type_get_channels(IntPtr thiz);

		/// <summary>
		/// Get the number of channels. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The number of channels. </returns>
		public int Channels
		{
			get
			{
				return linphone_payload_type_get_channels(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_payload_type_get_clock_rate(IntPtr thiz);

		/// <summary>
		/// Get the clock rate of a payload type. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The clock rate in Hz. </returns>
		public int ClockRate
		{
			get
			{
				return linphone_payload_type_get_clock_rate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_payload_type_get_description(IntPtr thiz);

		/// <summary>
		/// Return a string describing a payload type. 
		/// <para>
		/// The format of the string is <mime_type>/<clock_rate>/<channels>. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The description of the payload type. Must be release after use.  
		/// </returns>
		public string Description
		{
			get
			{
				IntPtr stringPtr = linphone_payload_type_get_description(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_payload_type_get_encoder_description(IntPtr thiz);

		/// <summary>
		/// Get a description of the encoder used to provide a payload type. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The description of the encoder. Can be null if the payload type is not
		/// supported by Mediastreamer2.   </returns>
		public string EncoderDescription
		{
			get
			{
				IntPtr stringPtr = linphone_payload_type_get_encoder_description(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_payload_type_is_usable(IntPtr thiz);

		/// <summary>
		/// Check whether the payload is usable according the bandwidth targets set in the
		/// core. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the payload type is usable. </returns>
		public bool IsUsable
		{
			get
			{
				return linphone_payload_type_is_usable(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_payload_type_is_vbr(IntPtr thiz);

		/// <summary>
		/// Tells whether the specified payload type represents a variable bitrate codec. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if the payload type represents a VBR codec, false instead.
		/// </returns>
		public bool IsVbr
		{
			get
			{
				return linphone_payload_type_is_vbr(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_payload_type_get_mime_type(IntPtr thiz);

		/// <summary>
		/// Get the mime type. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The mime type.   </returns>
		public string MimeType
		{
			get
			{
				IntPtr stringPtr = linphone_payload_type_get_mime_type(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_payload_type_get_normal_bitrate(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_payload_type_set_normal_bitrate(IntPtr thiz, int bitrate);

		/// <summary>
		/// Get the normal bitrate in bits/s. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The normal bitrate in bits/s or -1 if an error has occured. </returns>
		public int NormalBitrate
		{
			get
			{
				return linphone_payload_type_get_normal_bitrate(nativePtr);
			}
			set
			{
				linphone_payload_type_set_normal_bitrate(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_payload_type_get_number(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_payload_type_set_number(IntPtr thiz, int number);

		/// <summary>
		/// Returns the payload type number assigned for this codec. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The number of the payload type. </returns>
		public int Number
		{
			get
			{
				return linphone_payload_type_get_number(nativePtr);
			}
			set
			{
				linphone_payload_type_set_number(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_payload_type_get_recv_fmtp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_payload_type_set_recv_fmtp(IntPtr thiz, string recvFmtp);

		/// <summary>
		/// Get the format parameters for incoming streams. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The format parameters as string.   </returns>
		public string RecvFmtp
		{
			get
			{
				IntPtr stringPtr = linphone_payload_type_get_recv_fmtp(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_payload_type_set_recv_fmtp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_payload_type_get_send_fmtp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_payload_type_set_send_fmtp(IntPtr thiz, string sendFmtp);

		/// <summary>
		/// Get the format parameters for outgoing streams. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The format parameters as string.   </returns>
		public string SendFmtp
		{
			get
			{
				IntPtr stringPtr = linphone_payload_type_get_send_fmtp(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_payload_type_set_send_fmtp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_payload_type_get_type(IntPtr thiz);

		/// <summary>
		/// Get the type of a payload type. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The type of the payload e.g. PAYLOAD_AUDIO_CONTINUOUS or
		/// PAYLOAD_VIDEO. </returns>
		public int Type
		{
			get
			{
				return linphone_payload_type_get_type(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_payload_type_enable(IntPtr thiz, char enabled);

		/// <summary>
		/// Enable/disable a payload type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="enabled">Set true for enabling and false for disabling. </param>
		/// 
		/// 
		/// <returns>0 for success, -1 for failure. </returns>
		public int Enable(bool enabled)
		{
			int returnVal = linphone_payload_type_enable(nativePtr, enabled ? (char)1 : (char)0);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_payload_type_enabled(IntPtr thiz);

		/// <summary>
		/// Check whether a palyoad type is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if enabled, false if disabled. </returns>
		public bool Enabled()
		{
			bool returnVal = linphone_payload_type_enabled(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
	}
	/// <summary>
	/// Player interface. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Player : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_player_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_player_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_player_remove_callbacks(IntPtr thiz, IntPtr cbs);

		~Player() 
		{
			if (listener != null)
			{
				linphone_player_remove_callbacks(nativePtr, listener.nativePtr);
			}
		}

		private PlayerListener listener;

		public PlayerListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_player_cbs(linphone_factory_get());
					listener = fromNativePtr<PlayerListener>(nativeListener, false);
					linphone_player_add_callbacks(nativePtr, nativeListener);
					listener.register();
				}
				return listener;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_player_get_core(IntPtr thiz);

		/// <summary>
		/// Returns the <see cref="Linphone.Core" /> object managing this player's call, if
		/// any. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the <see cref="Linphone.Core" /> object associated   </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_player_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_player_get_current_callbacks(IntPtr thiz);

		/// <summary>
		/// Returns the current LinphonePlayerCbsCbs object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current LinphonePlayerCbs object   </returns>
		public Linphone.PlayerListener CurrentCallbacks
		{
			get
			{
				IntPtr ptr = linphone_player_get_current_callbacks(nativePtr);
				Linphone.PlayerListener obj = fromNativePtr<Linphone.PlayerListener>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_player_get_current_position(IntPtr thiz);

		/// <summary>
		/// Get the current position in the opened file. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current position in the opened file </returns>
		public int CurrentPosition
		{
			get
			{
				return linphone_player_get_current_position(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_player_get_duration(IntPtr thiz);

		/// <summary>
		/// Get the duration of the opened file. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The duration of the opened file </returns>
		public int Duration
		{
			get
			{
				return linphone_player_get_duration(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_player_get_is_video_available(IntPtr thiz);

		/// <summary>
		/// Returns whether the file has video and if it can be displayed. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if file has video and it can be displayed, false otherwise
		/// </returns>
		public bool IsVideoAvailable
		{
			get
			{
				return linphone_player_get_is_video_available(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.PlayerState linphone_player_get_state(IntPtr thiz);

		/// <summary>
		/// Get the current state of a player. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current LinphonePlayerState of the player. </returns>
		public Linphone.PlayerState State
		{
			get
			{
				return linphone_player_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_player_set_window_id(IntPtr thiz, IntPtr windowId);

		/// <summary>
		/// Sets a window id to be used to display video if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="windowId">The window id pointer to use.   </param>
		/// 
		public IntPtr WindowId
		{
			set
			{
				linphone_player_set_window_id(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_player_close(IntPtr thiz);

		/// <summary>
		/// Close the opened file. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void Close()
		{
			linphone_player_close(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_player_open(IntPtr thiz, string filename);

		/// <summary>
		/// Open a file for playing. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filename">The path to the file to open   </param>
		/// 
		public void Open(string filename)
		{
			int exception_result = linphone_player_open(nativePtr, filename);
			if (exception_result != 0) throw new LinphoneException("Open returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_player_pause(IntPtr thiz);

		/// <summary>
		/// Pause the playing of a file. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 on success, a negative value otherwise </returns>
		public void Pause()
		{
			int exception_result = linphone_player_pause(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Pause returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_player_seek(IntPtr thiz, int timeMs);

		/// <summary>
		/// Seek in an opened file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="timeMs">The time we want to go to in the file (in milliseconds).
		/// </param>
		/// 
		/// 
		/// <returns>0 on success, a negative value otherwise. </returns>
		public void Seek(int timeMs)
		{
			int exception_result = linphone_player_seek(nativePtr, timeMs);
			if (exception_result != 0) throw new LinphoneException("Seek returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_player_start(IntPtr thiz);

		/// <summary>
		/// Start playing a file that has been opened with <see
		/// cref="Linphone.Player.Open()" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 on success, a negative value otherwise </returns>
		public void Start()
		{
			int exception_result = linphone_player_start(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Start returned value" + exception_result);
			
			
		}
	}
	/// <summary>
	/// Presence activity type holding information about a presence activity. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PresenceActivity : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_activity_get_description(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_activity_set_description(IntPtr thiz, string description);

		/// <summary>
		/// Gets the description of a presence activity. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A pointer to the description string of the presence activity, or null
		/// if no description is specified.   </returns>
		public string Description
		{
			get
			{
				IntPtr stringPtr = linphone_presence_activity_get_description(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_activity_set_description(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Description setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.PresenceActivityType linphone_presence_activity_get_type(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_activity_set_type(IntPtr thiz, int acttype);

		/// <summary>
		/// Gets the activity type of a presence activity. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphonePresenceActivityType of the activity. </returns>
		public Linphone.PresenceActivityType Type
		{
			get
			{
				return linphone_presence_activity_get_type(nativePtr);
			}
			set
			{
				int exception_result = linphone_presence_activity_set_type(nativePtr, (int)value);
				if (exception_result != 0) throw new LinphoneException("Type setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_activity_to_string(IntPtr thiz);

		/// <summary>
		/// Gets the string representation of a presence activity. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A pointer a dynamically allocated string representing the given
		/// activity.  </returns>
		/// 
		/// The returned string is to be freed by calling ms_free(). 
		public override string ToString()
		{
			IntPtr stringPtr = linphone_presence_activity_to_string(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
	}
	/// <summary>
	/// Presence model type holding information about the presence of a person. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PresenceModel : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_new_with_activity(int activity, string description);

		/// <summary>
		/// Creates a presence model specifying an activity. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="activity">The LinphonePresenceActivityType to set for the created
		/// presence model. </param>
		/// <param name="description">An additional description of the activity (mainly
		/// useful for the 'other' activity). Set it to null to not add a description.  
		/// </param>
		/// 
		/// 
		/// <returns>The created <see cref="Linphone.PresenceModel" />, or null if an error
		/// occured.   </returns>
		/// 
		/// <remarks>See : linphone_presence_model_new </remarks>
		/// 
		/// <remarks>See : linphone_presence_model_new_with_activity_and_note</remarks>
		/// 
		/// The created presence model has the activity specified in the parameters. 
		public static Linphone.PresenceModel NewWithActivity(Linphone.PresenceActivityType activity, string description)
		{
			IntPtr ptr = linphone_presence_model_new_with_activity((int)activity, description);
			Linphone.PresenceModel returnVal = fromNativePtr<Linphone.PresenceModel>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_new_with_activity_and_note(int activity, string description, string note, string lang);

		/// <summary>
		/// Creates a presence model specifying an activity and adding a note. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="activity">The LinphonePresenceActivityType to set for the created
		/// presence model. </param>
		/// <param name="description">An additional description of the activity (mainly
		/// useful for the 'other' activity). Set it to null to not add a description.  
		/// </param>
		/// <param name="note">An additional note giving additional information about the
		/// contact presence.   </param>
		/// <param name="lang">The language the note is written in. It can be set to null
		/// in order to not specify the language of the note.   </param>
		/// 
		/// 
		/// <returns>The created <see cref="Linphone.PresenceModel" />, or null if an error
		/// occured.   </returns>
		/// 
		/// <remarks>See : linphone_presence_model_new_with_activity </remarks>
		/// 
		/// <remarks>See : linphone_presence_model_new_with_activity_and_note</remarks>
		/// 
		/// The created presence model has the activity and the note specified in the
		/// parameters. 
		public static Linphone.PresenceModel NewWithActivityAndNote(Linphone.PresenceActivityType activity, string description, string note, string lang)
		{
			IntPtr ptr = linphone_presence_model_new_with_activity_and_note((int)activity, description, note, lang);
			Linphone.PresenceModel returnVal = fromNativePtr<Linphone.PresenceModel>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_activity(IntPtr thiz);

		/// <summary>
		/// Gets the first activity of a presence model (there is usually only one). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A <see cref="Linphone.PresenceActivity" /> object if successful, null
		/// otherwise.     </returns>
		public Linphone.PresenceActivity Activity
		{
			get
			{
				IntPtr ptr = linphone_presence_model_get_activity(nativePtr);
				Linphone.PresenceActivity obj = fromNativePtr<Linphone.PresenceActivity>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.PresenceBasicStatus linphone_presence_model_get_basic_status(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_set_basic_status(IntPtr thiz, int basicStatus);

		/// <summary>
		/// Gets the basic status of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphonePresenceBasicStatus of the <see
		/// cref="Linphone.PresenceModel" /> object given as parameter. </returns>
		public Linphone.PresenceBasicStatus BasicStatus
		{
			get
			{
				return linphone_presence_model_get_basic_status(nativePtr);
			}
			set
			{
				int exception_result = linphone_presence_model_set_basic_status(nativePtr, (int)value);
				if (exception_result != 0) throw new LinphoneException("BasicStatus setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_get_capabilities(IntPtr thiz);

		/// <summary>
		/// Gets the capabilities of a <see cref="Linphone.PresenceModel" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the capabilities. </returns>
		public int Capabilities
		{
			get
			{
				return linphone_presence_model_get_capabilities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConsolidatedPresence linphone_presence_model_get_consolidated_presence(IntPtr thiz);

		/// <summary>
		/// Get the consolidated presence from a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneConsolidatedPresence corresponding to the presence model
		/// </returns>
		public Linphone.ConsolidatedPresence ConsolidatedPresence
		{
			get
			{
				return linphone_presence_model_get_consolidated_presence(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_contact(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_set_contact(IntPtr thiz, string contact);

		/// <summary>
		/// Gets the contact of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A pointer to a dynamically allocated string containing the contact, or
		/// null if no contact is found.  </returns>
		/// 
		/// The returned string is to be freed by calling ms_free(). 
		public string Contact
		{
			get
			{
				IntPtr stringPtr = linphone_presence_model_get_contact(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_model_set_contact(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Contact setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_presence_model_is_online(IntPtr thiz);

		/// <summary>
		/// Tells whether a presence model is considered online. 
		/// <para>
		/// It is any of theses cases:
		/// 
		/// </para>
		/// </summary>
		public bool IsOnline
		{
			get
			{
				return linphone_presence_model_is_online(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_model_get_nb_activities(IntPtr thiz);

		/// <summary>
		/// Gets the number of activities included in the presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The number of activities included in the <see
		/// cref="Linphone.PresenceModel" /> object. </returns>
		public uint NbActivities
		{
			get
			{
				return linphone_presence_model_get_nb_activities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_model_get_nb_persons(IntPtr thiz);

		/// <summary>
		/// Gets the number of persons included in the presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The number of persons included in the <see
		/// cref="Linphone.PresenceModel" /> object. </returns>
		public uint NbPersons
		{
			get
			{
				return linphone_presence_model_get_nb_persons(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_model_get_nb_services(IntPtr thiz);

		/// <summary>
		/// Gets the number of services included in the presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The number of services included in the <see
		/// cref="Linphone.PresenceModel" /> object. </returns>
		public uint NbServices
		{
			get
			{
				return linphone_presence_model_get_nb_services(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_presentity(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_set_presentity(IntPtr thiz, IntPtr presentity);

		/// <summary>
		/// Gets the presentity of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A pointer to a const <see cref="Linphone.Address" />, or null if no
		/// contact is found.   </returns>
		public Linphone.Address Presentity
		{
			get
			{
				IntPtr ptr = linphone_presence_model_get_presentity(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				int exception_result = linphone_presence_model_set_presentity(nativePtr, value.nativePtr);
				if (exception_result != 0) throw new LinphoneException("Presentity setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_presence_model_get_timestamp(IntPtr thiz);

		/// <summary>
		/// Gets the timestamp of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The timestamp of the <see cref="Linphone.PresenceModel" /> object or
		/// -1 on error. </returns>
		public long Timestamp
		{
			get
			{
				return linphone_presence_model_get_timestamp(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_add_activity(IntPtr thiz, IntPtr activity);

		/// <summary>
		/// Adds an activity to a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="activity">The <see cref="Linphone.PresenceActivity" /> object to
		/// add to the model.   </param>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void AddActivity(Linphone.PresenceActivity activity)
		{
			int exception_result = linphone_presence_model_add_activity(nativePtr, activity != null ? activity.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddActivity returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_add_note(IntPtr thiz, string noteContent, string lang);

		/// <summary>
		/// Adds a note to a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="noteContent">The note to be added to the presence model.   </param>
		/// <param name="lang">The language of the note to be added. Can be null if no
		/// language is to be specified for the note.   </param>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error.</returns>
		/// 
		/// Only one note for each language can be set, so e.g. setting a note for the 'fr'
		/// language if there is only one will replace the existing one. 
		public void AddNote(string noteContent, string lang)
		{
			int exception_result = linphone_presence_model_add_note(nativePtr, noteContent, lang);
			if (exception_result != 0) throw new LinphoneException("AddNote returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_add_person(IntPtr thiz, IntPtr person);

		/// <summary>
		/// Adds a person to a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="person">The <see cref="Linphone.PresencePerson" /> object to add
		/// to the model.   </param>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void AddPerson(Linphone.PresencePerson person)
		{
			int exception_result = linphone_presence_model_add_person(nativePtr, person != null ? person.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddPerson returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_add_service(IntPtr thiz, IntPtr service);

		/// <summary>
		/// Adds a service to a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="service">The <see cref="Linphone.PresenceService" /> object to add
		/// to the model.   </param>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void AddService(Linphone.PresenceService service)
		{
			int exception_result = linphone_presence_model_add_service(nativePtr, service != null ? service.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddService returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_clear_activities(IntPtr thiz);

		/// <summary>
		/// Clears the activities of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void ClearActivities()
		{
			int exception_result = linphone_presence_model_clear_activities(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearActivities returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_clear_notes(IntPtr thiz);

		/// <summary>
		/// Clears all the notes of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void ClearNotes()
		{
			int exception_result = linphone_presence_model_clear_notes(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearNotes returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_clear_persons(IntPtr thiz);

		/// <summary>
		/// Clears the persons of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void ClearPersons()
		{
			int exception_result = linphone_presence_model_clear_persons(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearPersons returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_clear_services(IntPtr thiz);

		/// <summary>
		/// Clears the services of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void ClearServices()
		{
			int exception_result = linphone_presence_model_clear_services(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearServices returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_presence_model_get_capability_version(IntPtr thiz, int capability);

		/// <summary>
		/// Returns the version of the capability of a <see cref="Linphone.PresenceModel"
		/// />. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">The LinphoneFriendCapability to test. </param>
		/// 
		/// 
		/// <returns>the version of the capability of a <see cref="Linphone.PresenceModel"
		/// /> or -1.0 if the model has not the capability. </returns>
		public float GetCapabilityVersion(Linphone.FriendCapability capability)
		{
			float returnVal = linphone_presence_model_get_capability_version(nativePtr, (int)capability);
			
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_note(IntPtr thiz, string lang);

		/// <summary>
		/// Gets the first note of a presence model (there is usually only one). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="lang">The language of the note to get. Can be null to get a note
		/// that has no language specified or to get the first note whatever language it is
		/// written into.   </param>
		/// 
		/// 
		/// <returns>A pointer to a <see cref="Linphone.PresenceNote" /> object if
		/// successful, null otherwise.   </returns>
		public Linphone.PresenceNote GetNote(string lang)
		{
			IntPtr ptr = linphone_presence_model_get_note(nativePtr, lang);
			Linphone.PresenceNote returnVal = fromNativePtr<Linphone.PresenceNote>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_nth_activity(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth activity of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the activity to get (the first activity having
		/// the index 0). </param>
		/// 
		/// 
		/// <returns>A pointer to a <see cref="Linphone.PresenceActivity" /> object if
		/// successful, null otherwise.     </returns>
		public Linphone.PresenceActivity GetNthActivity(uint index)
		{
			IntPtr ptr = linphone_presence_model_get_nth_activity(nativePtr, index);
			Linphone.PresenceActivity returnVal = fromNativePtr<Linphone.PresenceActivity>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_nth_person(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth person of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the person to get (the first person having the
		/// index 0). </param>
		/// 
		/// 
		/// <returns>A pointer to a <see cref="Linphone.PresencePerson" /> object if
		/// successful, null otherwise.   </returns>
		public Linphone.PresencePerson GetNthPerson(uint index)
		{
			IntPtr ptr = linphone_presence_model_get_nth_person(nativePtr, index);
			Linphone.PresencePerson returnVal = fromNativePtr<Linphone.PresencePerson>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_nth_service(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth service of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the service to get (the first service having
		/// the index 0). </param>
		/// 
		/// 
		/// <returns>A pointer to a <see cref="Linphone.PresenceService" /> object if
		/// successful, null otherwise.   </returns>
		public Linphone.PresenceService GetNthService(uint index)
		{
			IntPtr ptr = linphone_presence_model_get_nth_service(nativePtr, index);
			Linphone.PresenceService returnVal = fromNativePtr<Linphone.PresenceService>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_presence_model_has_capability(IntPtr thiz, int capability);

		/// <summary>
		/// Returns whether or not the <see cref="Linphone.PresenceModel" /> object has a
		/// given capability. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">The capability to test. </param>
		/// 
		/// 
		/// <returns>whether or not the <see cref="Linphone.PresenceModel" /> object has a
		/// given capability. </returns>
		public bool HasCapability(Linphone.FriendCapability capability)
		{
			bool returnVal = linphone_presence_model_has_capability(nativePtr, (int)capability) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_presence_model_has_capability_with_version(IntPtr thiz, int capability, float version);

		/// <summary>
		/// Returns whether or not the <see cref="Linphone.PresenceModel" /> object has a
		/// given capability with a certain version. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">The LinphoneFriendCapability to test. </param>
		/// <param name="version">The wanted version to test. </param>
		/// 
		/// 
		/// <returns>whether or not the <see cref="Linphone.PresenceModel" /> object has a
		/// given capability with a certain version. </returns>
		public bool HasCapabilityWithVersion(Linphone.FriendCapability capability, float version)
		{
			bool returnVal = linphone_presence_model_has_capability_with_version(nativePtr, (int)capability, version) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_presence_model_has_capability_with_version_or_more(IntPtr thiz, int capability, float version);

		/// <summary>
		/// Returns whether or not the <see cref="Linphone.PresenceModel" /> object has a
		/// given capability with a certain version or more. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">The LinphoneFriendCapability to test. </param>
		/// <param name="version">The wanted version to test. </param>
		/// 
		/// 
		/// <returns>whether or not the <see cref="Linphone.PresenceModel" /> object has a
		/// given capability with a certain version or more. </returns>
		public bool HasCapabilityWithVersionOrMore(Linphone.FriendCapability capability, float version)
		{
			bool returnVal = linphone_presence_model_has_capability_with_version_or_more(nativePtr, (int)capability, version) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_set_activity(IntPtr thiz, int activity, string description);

		/// <summary>
		/// Sets the activity of a presence model (limits to only one activity). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="activity">The LinphonePresenceActivityType to set for the model.
		/// </param>
		/// <param name="description">An additional description of the activity to set for
		/// the model. Can be null if no additional description is to be added.   </param>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error.</returns>
		/// 
		/// WARNING: This function will modify the basic status of the model according to
		/// the activity being set. If you don't want the basic status to be modified
		/// automatically, you can use the combination of <see
		/// cref="Linphone.PresenceModel.SetBasicStatus()" />, <see
		/// cref="Linphone.PresenceModel.ClearActivities()" /> and <see
		/// cref="Linphone.PresenceModel.AddActivity()" />. 
		public void SetActivity(Linphone.PresenceActivityType activity, string description)
		{
			int exception_result = linphone_presence_model_set_activity(nativePtr, (int)activity, description);
			if (exception_result != 0) throw new LinphoneException("SetActivity returned value" + exception_result);
			
			
		}
	}
	/// <summary>
	/// Presence note type holding information about a presence note. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PresenceNote : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_note_get_content(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_note_set_content(IntPtr thiz, string content);

		/// <summary>
		/// Gets the content of a presence note. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A pointer to the content of the presence note.   </returns>
		public string Content
		{
			get
			{
				IntPtr stringPtr = linphone_presence_note_get_content(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_note_set_content(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Content setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_note_get_lang(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_note_set_lang(IntPtr thiz, string lang);

		/// <summary>
		/// Gets the language of a presence note. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A pointer to the language string of the presence note, or null if no
		/// language is specified.   </returns>
		public string Lang
		{
			get
			{
				IntPtr stringPtr = linphone_presence_note_get_lang(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_note_set_lang(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Lang setter returned value " + exception_result);
			}
		}
	}
	/// <summary>
	/// Presence person holding information about a presence person. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PresencePerson : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_person_get_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_set_id(IntPtr thiz, string id);

		/// <summary>
		/// Gets the id of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A pointer to a dynamically allocated string containing the id, or null
		/// in case of error.  </returns>
		/// 
		/// The returned string is to be freed by calling ms_free(). 
		public string Id
		{
			get
			{
				IntPtr stringPtr = linphone_presence_person_get_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_person_set_id(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Id setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_person_get_nb_activities(IntPtr thiz);

		/// <summary>
		/// Gets the number of activities included in the presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The number of activities included in the <see
		/// cref="Linphone.PresencePerson" /> object. </returns>
		public uint NbActivities
		{
			get
			{
				return linphone_presence_person_get_nb_activities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_person_get_nb_activities_notes(IntPtr thiz);

		/// <summary>
		/// Gets the number of activities notes included in the presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The number of activities notes included in the <see
		/// cref="Linphone.PresencePerson" /> object. </returns>
		public uint NbActivitiesNotes
		{
			get
			{
				return linphone_presence_person_get_nb_activities_notes(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_person_get_nb_notes(IntPtr thiz);

		/// <summary>
		/// Gets the number of notes included in the presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The number of notes included in the <see
		/// cref="Linphone.PresencePerson" /> object. </returns>
		public uint NbNotes
		{
			get
			{
				return linphone_presence_person_get_nb_notes(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_add_activities_note(IntPtr thiz, IntPtr note);

		/// <summary>
		/// Adds an activities note to a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="note">The <see cref="Linphone.PresenceNote" /> object to add to
		/// the person.   </param>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void AddActivitiesNote(Linphone.PresenceNote note)
		{
			int exception_result = linphone_presence_person_add_activities_note(nativePtr, note != null ? note.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddActivitiesNote returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_add_activity(IntPtr thiz, IntPtr activity);

		/// <summary>
		/// Adds an activity to a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="activity">The <see cref="Linphone.PresenceActivity" /> object to
		/// add to the person.   </param>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void AddActivity(Linphone.PresenceActivity activity)
		{
			int exception_result = linphone_presence_person_add_activity(nativePtr, activity != null ? activity.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddActivity returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_add_note(IntPtr thiz, IntPtr note);

		/// <summary>
		/// Adds a note to a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="note">The <see cref="Linphone.PresenceNote" /> object to add to
		/// the person.   </param>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void AddNote(Linphone.PresenceNote note)
		{
			int exception_result = linphone_presence_person_add_note(nativePtr, note != null ? note.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddNote returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_clear_activities(IntPtr thiz);

		/// <summary>
		/// Clears the activities of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void ClearActivities()
		{
			int exception_result = linphone_presence_person_clear_activities(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearActivities returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_clear_activities_notes(IntPtr thiz);

		/// <summary>
		/// Clears the activities notes of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void ClearActivitiesNotes()
		{
			int exception_result = linphone_presence_person_clear_activities_notes(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearActivitiesNotes returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_clear_notes(IntPtr thiz);

		/// <summary>
		/// Clears the notes of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void ClearNotes()
		{
			int exception_result = linphone_presence_person_clear_notes(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearNotes returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_person_get_nth_activities_note(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth activities note of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the activities note to get (the first note
		/// having the index 0). </param>
		/// 
		/// 
		/// <returns>A pointer to a <see cref="Linphone.PresenceNote" /> object if
		/// successful, null otherwise.   </returns>
		public Linphone.PresenceNote GetNthActivitiesNote(uint index)
		{
			IntPtr ptr = linphone_presence_person_get_nth_activities_note(nativePtr, index);
			Linphone.PresenceNote returnVal = fromNativePtr<Linphone.PresenceNote>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_person_get_nth_activity(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth activity of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the activity to get (the first activity having
		/// the index 0). </param>
		/// 
		/// 
		/// <returns>A pointer to a <see cref="Linphone.PresenceActivity" /> object if
		/// successful, null otherwise.   </returns>
		public Linphone.PresenceActivity GetNthActivity(uint index)
		{
			IntPtr ptr = linphone_presence_person_get_nth_activity(nativePtr, index);
			Linphone.PresenceActivity returnVal = fromNativePtr<Linphone.PresenceActivity>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_person_get_nth_note(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth note of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the note to get (the first note having the
		/// index 0). </param>
		/// 
		/// 
		/// <returns>A pointer to a <see cref="Linphone.PresenceNote" /> object if
		/// successful, null otherwise.   </returns>
		public Linphone.PresenceNote GetNthNote(uint index)
		{
			IntPtr ptr = linphone_presence_person_get_nth_note(nativePtr, index);
			Linphone.PresenceNote returnVal = fromNativePtr<Linphone.PresenceNote>(ptr, true);
			
			return returnVal;
		}
	}
	/// <summary>
	/// Presence service type holding information about a presence service. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PresenceService : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.PresenceBasicStatus linphone_presence_service_get_basic_status(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_service_set_basic_status(IntPtr thiz, int basicStatus);

		/// <summary>
		/// Gets the basic status of a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphonePresenceBasicStatus of the <see
		/// cref="Linphone.PresenceService" /> object given as parameter. </returns>
		public Linphone.PresenceBasicStatus BasicStatus
		{
			get
			{
				return linphone_presence_service_get_basic_status(nativePtr);
			}
			set
			{
				int exception_result = linphone_presence_service_set_basic_status(nativePtr, (int)value);
				if (exception_result != 0) throw new LinphoneException("BasicStatus setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_service_get_contact(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_service_set_contact(IntPtr thiz, string contact);

		/// <summary>
		/// Gets the contact of a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A pointer to a dynamically allocated string containing the contact, or
		/// null if no contact is found.  </returns>
		/// 
		/// The returned string is to be freed by calling ms_free(). 
		public string Contact
		{
			get
			{
				IntPtr stringPtr = linphone_presence_service_get_contact(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_service_set_contact(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Contact setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_service_get_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_service_set_id(IntPtr thiz, string id);

		/// <summary>
		/// Gets the id of a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A pointer to a dynamically allocated string containing the id, or null
		/// in case of error.  </returns>
		/// 
		/// The returned string is to be freed by calling ms_free(). 
		public string Id
		{
			get
			{
				IntPtr stringPtr = linphone_presence_service_get_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_service_set_id(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Id setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_service_get_nb_notes(IntPtr thiz);

		/// <summary>
		/// Gets the number of notes included in the presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The number of notes included in the <see
		/// cref="Linphone.PresenceService" /> object. </returns>
		public uint NbNotes
		{
			get
			{
				return linphone_presence_service_get_nb_notes(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_service_get_service_descriptions(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_service_set_service_descriptions(IntPtr thiz, IntPtr descriptions);

		/// <summary>
		/// Gets the service descriptions of a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A A list of char * objects. char *  containing the services
		/// descriptions.  </returns>
		/// 
		/// The returned string is to be freed. 
		public IEnumerable<string> ServiceDescriptions
		{
			get
			{
				return MarshalStringArray(linphone_presence_service_get_service_descriptions(nativePtr));
			}
			set
			{
				int exception_result = linphone_presence_service_set_service_descriptions(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				if (exception_result != 0) throw new LinphoneException("ServiceDescriptions setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_service_add_note(IntPtr thiz, IntPtr note);

		/// <summary>
		/// Adds a note to a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="note">The <see cref="Linphone.PresenceNote" /> object to add to
		/// the service.   </param>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void AddNote(Linphone.PresenceNote note)
		{
			int exception_result = linphone_presence_service_add_note(nativePtr, note != null ? note.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddNote returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_service_clear_notes(IntPtr thiz);

		/// <summary>
		/// Clears the notes of a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, a value < 0 in case of error. </returns>
		public void ClearNotes()
		{
			int exception_result = linphone_presence_service_clear_notes(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearNotes returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_service_get_nth_note(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth note of a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the note to get (the first note having the
		/// index 0). </param>
		/// 
		/// 
		/// <returns>A pointer to a <see cref="Linphone.PresenceNote" /> object if
		/// successful, null otherwise.   </returns>
		public Linphone.PresenceNote GetNthNote(uint index)
		{
			IntPtr ptr = linphone_presence_service_get_nth_note(nativePtr, index);
			Linphone.PresenceNote returnVal = fromNativePtr<Linphone.PresenceNote>(ptr, true);
			
			return returnVal;
		}
	}
	/// <summary>
	/// Represents an account configuration to be used by <see cref="Linphone.Core" />. 
	/// <para>
	/// In addition to the <see cref="Linphone.AuthInfo" /> that stores the
	/// credentials, you need to configure a <see cref="Linphone.ProxyConfig" /> as
	/// well to be able to connect to a proxy server.
	/// 
	/// A minimal proxy config consists of an identity address
	/// (sip:username@domain.tld) and the proxy server address, </para>
	/// </summary>
	/// <remarks>See : <see cref="Linphone.ProxyConfig.SetServerAddr()" />.</remarks>
	/// 
	/// If any, it will be stored inside the default configuration file, so it will
	/// survive the destruction of the <see cref="Linphone.Core" /> and be available at
	/// the next start.
	/// 
	/// The account set with <see cref="Linphone.Core.SetDefaultProxyConfig()" /> will
	/// be used as default for outgoing calls & chat messages unless specified
	/// otherwise. 
	[StructLayout(LayoutKind.Sequential)]
	public class ProxyConfig : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_avpf_enabled(IntPtr thiz);

		/// <summary>
		/// Indicates whether AVPF/SAVPF is being used for calls using this proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>True if AVPF/SAVPF is enabled, false otherwise. </returns>
		public bool AvpfEnabled
		{
			get
			{
				return linphone_proxy_config_avpf_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AVPFMode linphone_proxy_config_get_avpf_mode(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_avpf_mode(IntPtr thiz, int mode);

		/// <summary>
		/// Get enablement status of RTCP feedback (also known as AVPF profile). 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the enablement mode, which can be LinphoneAVPFDefault (use
		/// LinphoneCore's mode), LinphoneAVPFEnabled (avpf is enabled), or
		/// LinphoneAVPFDisabled (disabled). </returns>
		public Linphone.AVPFMode AvpfMode
		{
			get
			{
				return linphone_proxy_config_get_avpf_mode(nativePtr);
			}
			set
			{
				linphone_proxy_config_set_avpf_mode(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_proxy_config_get_avpf_rr_interval(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_avpf_rr_interval(IntPtr thiz, uint interval);

		/// <summary>
		/// Get the interval between regular RTCP reports when using AVPF/SAVPF. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The interval in seconds. </returns>
		public uint AvpfRrInterval
		{
			get
			{
				return linphone_proxy_config_get_avpf_rr_interval(nativePtr);
			}
			set
			{
				linphone_proxy_config_set_avpf_rr_interval(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_conference_factory_uri(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_conference_factory_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Get the conference factory uri. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The uri of the conference factory.   </returns>
		public string ConferenceFactoryUri
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_conference_factory_uri(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_conference_factory_uri(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_contact(IntPtr thiz);

		/// <summary>
		/// Return the contact address of the proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.Address" /> correspong to the contact address of
		/// the proxy config.   </returns>
		public Linphone.Address Contact
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_contact(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_contact_parameters(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_contact_parameters(IntPtr thiz, string contactParams);

		/// <summary>
		/// Returns the contact parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>previously set contact parameters.   </returns>
		public string ContactParameters
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_contact_parameters(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_contact_parameters(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_contact_uri_parameters(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_contact_uri_parameters(IntPtr thiz, string contactUriParams);

		/// <summary>
		/// Returns the contact URI parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>previously set contact URI parameters.   </returns>
		public string ContactUriParameters
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_contact_uri_parameters(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_contact_uri_parameters(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_core(IntPtr thiz);

		/// <summary>
		/// Get the <see cref="Linphone.Core" /> object to which is associated the <see
		/// cref="Linphone.ProxyConfig" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The <see cref="Linphone.Core" /> object to which is associated the
		/// <see cref="Linphone.ProxyConfig" />.   </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_dependency(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_dependency(IntPtr thiz, IntPtr dependsOn);

		/// <summary>
		/// Get the dependency of a <see cref="Linphone.ProxyConfig" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The proxy config this one is dependent upon, or null if not marked
		/// dependent.   </returns>
		public Linphone.ProxyConfig Dependency
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_dependency(nativePtr);
				Linphone.ProxyConfig obj = fromNativePtr<Linphone.ProxyConfig>(ptr, true);
				return obj;
			}
			set
			{
				linphone_proxy_config_set_dependency(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_get_dial_escape_plus(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_dial_escape_plus(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether or not the + should be replaced by 00. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>whether liblinphone should replace "+" by "00" in dialed numbers
		/// (passed to <see cref="Linphone.Core.Invite()" />). </returns>
		public bool DialEscapePlus
		{
			get
			{
				return linphone_proxy_config_get_dial_escape_plus(nativePtr) != 0;
			}
			set
			{
				linphone_proxy_config_set_dial_escape_plus(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_dial_prefix(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_dial_prefix(IntPtr thiz, string prefix);

		/// <summary>
		/// Gets the prefix set for this proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>dialing prefix.   </returns>
		public string DialPrefix
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_dial_prefix(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_dial_prefix(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_domain(IntPtr thiz);

		/// <summary>
		/// Get the domain name of the given proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The domain name of the proxy config.   </returns>
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.Reason linphone_proxy_config_get_error(IntPtr thiz);

		/// <summary>
		/// Get the reason why registration failed when the proxy config state is
		/// LinphoneRegistrationFailed. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneReason why registration failed for this proxy config.
		/// </returns>
		public Linphone.Reason Error
		{
			get
			{
				return linphone_proxy_config_get_error(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_error_info(IntPtr thiz);

		/// <summary>
		/// Get detailed information why registration failed when the proxy config state is
		/// LinphoneRegistrationFailed. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The <see cref="Linphone.ErrorInfo" /> explaining why registration
		/// failed for this proxy config.   </returns>
		public Linphone.ErrorInfo ErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_get_expires(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_expires(IntPtr thiz, int expires);

		/// <summary>
		/// Gets the proxy config expires. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the duration of registration. </returns>
		public int Expires
		{
			get
			{
				return linphone_proxy_config_get_expires(nativePtr);
			}
			set
			{
				linphone_proxy_config_set_expires(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_identity_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_set_identity_address(IntPtr thiz, IntPtr identity);

		/// <summary>
		/// Gets the identity addres of the proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the SIP identity that belongs to this proxy configuration.   </returns>
		public Linphone.Address IdentityAddress
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_identity_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				int exception_result = linphone_proxy_config_set_identity_address(nativePtr, value.nativePtr);
				if (exception_result != 0) throw new LinphoneException("IdentityAddress setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_idkey(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_idkey(IntPtr thiz, string idkey);

		/// <summary>
		/// Get the idkey property of a <see cref="Linphone.ProxyConfig" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The idkey string, or null.   </returns>
		public string Idkey
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_idkey(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_idkey(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_is_push_notification_allowed(IntPtr thiz);

		/// <summary>
		/// Indicates whether to add to the contact parameters the push notification
		/// information. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if push notification informations should be added, false
		/// otherwise. </returns>
		public bool IsPushNotificationAllowed
		{
			get
			{
				return linphone_proxy_config_is_push_notification_allowed(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_nat_policy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_nat_policy(IntPtr thiz, IntPtr policy);

		/// <summary>
		/// Get The policy that is used to pass through NATs/firewalls when using this
		/// proxy config. 
		/// <para>
		/// If it is set to null, the default NAT policy from the core will be used
		/// instead. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns><see cref="Linphone.NatPolicy" /> object in use.   </returns>
		/// 
		/// <remarks>See : <see cref="Linphone.Core.GetNatPolicy()" /> </remarks>
		public Linphone.NatPolicy NatPolicy
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_nat_policy(nativePtr);
				Linphone.NatPolicy obj = fromNativePtr<Linphone.NatPolicy>(ptr, true);
				return obj;
			}
			set
			{
				linphone_proxy_config_set_nat_policy(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_proxy_config_get_privacy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_privacy(IntPtr thiz, uint privacy);

		/// <summary>
		/// Get default privacy policy for all calls routed through this proxy. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>Privacy mode as LinphonePrivacyMask </returns>
		public uint Privacy
		{
			get
			{
				return linphone_proxy_config_get_privacy(nativePtr);
			}
			set
			{
				linphone_proxy_config_set_privacy(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_publish_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_enable_publish(IntPtr thiz, char enable);

		/// <summary>
		/// Gets if the PUBLISH is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if PUBLISH request is enabled for this proxy. </returns>
		public bool PublishEnabled
		{
			get
			{
				return linphone_proxy_config_publish_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_proxy_config_enable_publish(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_get_publish_expires(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_publish_expires(IntPtr thiz, int expires);

		/// <summary>
		/// get the publish expiration time in second. 
		/// <para>
		/// Default value is the registration expiration value. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>expires in second </returns>
		public int PublishExpires
		{
			get
			{
				return linphone_proxy_config_get_publish_expires(nativePtr);
			}
			set
			{
				linphone_proxy_config_set_publish_expires(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_push_notification_allowed(IntPtr thiz, char allow);

		/// <summary>
		/// Indicates whether to add to the contact parameters the push notification
		/// information. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="allow">true to allow push notification information, false
		/// otherwise. </param>
		/// 
		public bool PushNotificationAllowed
		{
			set
			{
				linphone_proxy_config_set_push_notification_allowed(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_quality_reporting_collector(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_quality_reporting_collector(IntPtr thiz, string collector);

		/// <summary>
		/// Get the route of the collector end-point when using quality reporting. 
		/// <para>
		/// This SIP address should be used on server-side to process packets directly
		/// before discarding packets. Collector address should be a non existing account
		/// and will not receive any messages. If null, reports will be send to the proxy
		/// domain. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The SIP address of the collector end-point.   </returns>
		public string QualityReportingCollector
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_quality_reporting_collector(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_quality_reporting_collector(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_quality_reporting_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_enable_quality_reporting(IntPtr thiz, char enable);

		/// <summary>
		/// Indicates whether quality statistics during call should be stored and sent to a
		/// collector according to RFC 6035. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>True if quality repotring is enabled, false otherwise. </returns>
		public bool QualityReportingEnabled
		{
			get
			{
				return linphone_proxy_config_quality_reporting_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_proxy_config_enable_quality_reporting(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_get_quality_reporting_interval(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_quality_reporting_interval(IntPtr thiz, int interval);

		/// <summary>
		/// Get the interval between interval reports when using quality reporting. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The interval in seconds, 0 means interval reports are disabled.
		/// </returns>
		public int QualityReportingInterval
		{
			get
			{
				return linphone_proxy_config_get_quality_reporting_interval(nativePtr);
			}
			set
			{
				linphone_proxy_config_set_quality_reporting_interval(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_realm(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_realm(IntPtr thiz, string realm);

		/// <summary>
		/// Get the realm of the given proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The realm of the proxy config.   </returns>
		public string Realm
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_realm(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_realm(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_ref_key(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_ref_key(IntPtr thiz, string refkey);

		/// <summary>
		/// Get the persistent reference key associated to the proxy config. 
		/// <para>
		/// The reference key can be for example an id to an external database. It is
		/// stored in the config file, thus can survive to process exits/restarts.
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The reference key string that has been associated to the proxy config,
		/// or null if none has been associated.   </returns>
		public string RefKey
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_ref_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_ref_key(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_register_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_enable_register(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether the proxy config is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if registration to the proxy is enabled. </returns>
		public bool RegisterEnabled
		{
			get
			{
				return linphone_proxy_config_register_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_proxy_config_enable_register(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_set_route(IntPtr thiz, string route);

		/// <summary>
		/// Sets a SIP route. 
		/// <para>
		/// When a route is set, all outgoing calls will go to the route's destination if
		/// this proxy is the default one (see <see
		/// cref="Linphone.Core.SetDefaultProxyConfig()" /> ). 
		/// 
		/// </para>
		/// </summary>
		/// <param name="route">the SIP route to set   </param>
		/// 
		/// 
		/// <returns>-1 if route is invalid, 0 otherwise. </returns>
		/// 
		/// deprecated : 08/07/2020 use <see cref="Linphone.ProxyConfig.SetRoutes()" />
		/// instead 
		public string Route
		{
			set
			{
				int exception_result = linphone_proxy_config_set_route(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Route setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_routes(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_set_routes(IntPtr thiz, IntPtr routes);

		/// <summary>
		/// Gets the list of the routes set for this proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of const char * objects. const char *  the list of routes.  
		/// </returns>
		public IEnumerable<string> Routes
		{
			get
			{
				return MarshalStringArray(linphone_proxy_config_get_routes(nativePtr));
			}
			set
			{
				int exception_result = linphone_proxy_config_set_routes(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				if (exception_result != 0) throw new LinphoneException("Routes setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_server_addr(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_set_server_addr(IntPtr thiz, string serverAddress);

		/// <summary>
		/// Gets the proxy config proxy address. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the proxy's SIP address.   </returns>
		public string ServerAddr
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_server_addr(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_proxy_config_set_server_addr(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("ServerAddr setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.RegistrationState linphone_proxy_config_get_state(IntPtr thiz);

		/// <summary>
		/// Get the registration state of the given proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneRegistrationState of the proxy config. </returns>
		public Linphone.RegistrationState State
		{
			get
			{
				return linphone_proxy_config_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_transport(IntPtr thiz);

		/// <summary>
		/// Get the transport from either service route, route or addr. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The transport as a string (I.E udp, tcp, tls, dtls)   </returns>
		public string Transport
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_transport(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_get_unread_chat_message_count(IntPtr thiz);

		/// <summary>
		/// Return the unread chat message count for a given proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The unread chat message count. </returns>
		public int UnreadChatMessageCount
		{
			get
			{
				return linphone_proxy_config_get_unread_chat_message_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_done(IntPtr thiz);

		/// <summary>
		/// Commits modification made to the proxy configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>0 if successful, -1 otherwise </returns>
		public void Done()
		{
			int exception_result = linphone_proxy_config_done(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Done returned value" + exception_result);
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_edit(IntPtr thiz);

		/// <summary>
		/// Starts editing a proxy configuration. 
		/// <para>
		/// Because proxy configuration must be consistent, applications MUST call <see
		/// cref="Linphone.ProxyConfig.Edit()" /> before doing any attempts to modify proxy
		/// configuration (such as identity, proxy address and so on). Once the
		/// modifications are done, then the application must call <see
		/// cref="Linphone.ProxyConfig.Done()" /> to commit the changes. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void Edit()
		{
			linphone_proxy_config_edit(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_find_auth_info(IntPtr thiz);

		/// <summary>
		/// Find authentication info matching proxy config, if any, similarly to
		/// linphone_core_find_auth_info. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.AuthInfo" /> matching proxy config criteria if
		/// possible, null if nothing can be found.   </returns>
		public Linphone.AuthInfo FindAuthInfo()
		{
			IntPtr ptr = linphone_proxy_config_find_auth_info(nativePtr);
			Linphone.AuthInfo returnVal = fromNativePtr<Linphone.AuthInfo>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_custom_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Obtain the value of a header sent by the server in last answer to REGISTER. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">the header name for which to fetch corresponding value
		///   </param>
		/// 
		/// 
		/// <returns>the value of the queried header.   </returns>
		public string GetCustomHeader(string headerName)
		{
			IntPtr stringPtr = linphone_proxy_config_get_custom_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_is_phone_number(IntPtr thiz, string username);

		/// <summary>
		/// Detect if the given input is a phone number or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="username">string to parse.   </param>
		/// 
		/// 
		/// <returns>true if input is a phone number, false otherwise. </returns>
		public bool IsPhoneNumber(string username)
		{
			bool returnVal = linphone_proxy_config_is_phone_number(nativePtr, username) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_normalize_phone_number(IntPtr thiz, string username);

		/// <summary>
		/// Normalize a human readable phone number into a basic string. 
		/// <para>
		/// 888-444-222 becomes 888444222 or +33888444222 depending on the <see
		/// cref="Linphone.ProxyConfig" /> object. This function will always generate a
		/// normalized username if input is a phone number. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="username">the string to parse   </param>
		/// 
		/// 
		/// <returns>null if input is an invalid phone number, normalized phone number from
		/// username input otherwise.   </returns>
		public string NormalizePhoneNumber(string username)
		{
			IntPtr stringPtr = linphone_proxy_config_normalize_phone_number(nativePtr, username);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_normalize_sip_uri(IntPtr thiz, string username);

		/// <summary>
		/// Normalize a human readable sip uri into a fully qualified LinphoneAddress. 
		/// <para>
		/// A sip address should look like DisplayName <sip:username@domain:port> .
		/// Basically this function performs the following tasks
		/// 
		/// 
		/// The result is a syntactically correct SIP address. 
		/// 
		/// </para>
		/// </summary>
		/// <param name="username">the string to parse   </param>
		/// 
		/// 
		/// <returns>null if invalid input, normalized sip address otherwise.   </returns>
		public Linphone.Address NormalizeSipUri(string username)
		{
			IntPtr ptr = linphone_proxy_config_normalize_sip_uri(nativePtr, username);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, true);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_pause_register(IntPtr thiz);

		/// <summary>
		/// Prevent a proxy config from refreshing its registration. 
		/// <para>
		/// This is useful to let registrations to expire naturally (or) when the
		/// application wants to keep control on when refreshes are sent. However,
		/// linphone_core_set_network_reachable(lc,true) will always request the proxy
		/// configs to refresh their registrations. The refreshing operations can be
		/// resumed with <see cref="Linphone.ProxyConfig.RefreshRegister()" />. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void PauseRegister()
		{
			linphone_proxy_config_pause_register(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_refresh_register(IntPtr thiz);

		/// <summary>
		/// Refresh a proxy registration. 
		/// <para>
		/// This is useful if for example you resuming from suspend, thus IP address may
		/// have changed. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void RefreshRegister()
		{
			linphone_proxy_config_refresh_register(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_custom_header(IntPtr thiz, string headerName, string headerValue);

		/// <summary>
		/// Set the value of a custom header sent to the server in REGISTERs request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">the header name   </param>
		/// <param name="headerValue">the header's value   </param>
		/// 
		public void SetCustomHeader(string headerName, string headerValue)
		{
			linphone_proxy_config_set_custom_header(nativePtr, headerName, headerValue);
			
			
			
		}
	}
	/// <summary>
	/// Object holding chat message data received by a push notification on iOS
	/// platform only. 
	/// <para>
	/// This object is a subset of <see cref="Linphone.ChatMessage" />, so only a few
	/// methods of it's parent are available, like
	/// linphone_push_notification_message_get_text_content and
	/// linphone_push_notification_message_get_subject, just enough to be able to build
	/// a notification to show the user. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PushNotificationMessage : LinphoneObject
	{


	}
	/// <summary>
	/// Structure describing a range of integers. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Range : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_range_get_max(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_range_set_max(IntPtr thiz, int max);

		/// <summary>
		/// Gets the higher value of the range. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The higher value </returns>
		public int Max
		{
			get
			{
				return linphone_range_get_max(nativePtr);
			}
			set
			{
				linphone_range_set_max(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_range_get_min(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_range_set_min(IntPtr thiz, int min);

		/// <summary>
		/// Gets the lower value of the range. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The lower value </returns>
		public int Min
		{
			get
			{
				return linphone_range_get_min(nativePtr);
			}
			set
			{
				linphone_range_set_min(nativePtr, value);
				
			}
		}
	}
	/// <summary>
	/// The LinphoneSearchResult object represents a result of a search. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class SearchResult : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_search_result_get_address(IntPtr thiz);

		/// <summary>
		/// Gets the address of the search result if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The associed <see cref="Linphone.Address" /> or null.   </returns>
		public Linphone.Address Address
		{
			get
			{
				IntPtr ptr = linphone_search_result_get_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_search_result_get_capabilities(IntPtr thiz);

		/// <summary>
		/// Returns the capabilities mask of the search result. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the capabilities mask associated to the search result </returns>
		public int Capabilities
		{
			get
			{
				return linphone_search_result_get_capabilities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_search_result_get_friend(IntPtr thiz);

		/// <summary>
		/// Gets the friend of the search result if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The associated <see cref="Linphone.Friend" /> or null.   </returns>
		public Linphone.Friend Friend
		{
			get
			{
				IntPtr ptr = linphone_search_result_get_friend(nativePtr);
				Linphone.Friend obj = fromNativePtr<Linphone.Friend>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_search_result_get_phone_number(IntPtr thiz);

		/// <summary>
		/// Gets the phone number of the search result if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The associed phone number or null.   </returns>
		public string PhoneNumber
		{
			get
			{
				IntPtr stringPtr = linphone_search_result_get_phone_number(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_search_result_get_weight(IntPtr thiz);

		/// <summary>
		/// Gets the weight of the search result. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the result weight </returns>
		public uint Weight
		{
			get
			{
				return linphone_search_result_get_weight(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_search_result_has_capability(IntPtr thiz, int capability);

		/// <summary>
		/// Returns whether or not the search result has the given capability. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">the LinphoneFriendCapability to check </param>
		/// 
		/// 
		/// <returns>true if it has the capability, false otherwise. </returns>
		public bool HasCapability(Linphone.FriendCapability capability)
		{
			bool returnVal = linphone_search_result_has_capability(nativePtr, (int)capability) == (char)0 ? false : true;
			
			return returnVal;
		}
	}
	/// <summary>
	/// SIP transports & ports configuration object. 
	/// <para>
	/// Indicates which transport among UDP, TCP, TLS and DTLS should be enabled and if
	/// so on which port to listen. You can use special values like
	/// LC_SIP_TRANSPORT_DISABLED (0), LC_SIP_TRANSPORT_RANDOM (-1) and
	/// LC_SIP_TRANSPORT_DONTBIND (-2).
	/// 
	/// Once configuration is complete, use <see cref="Linphone.Core.SetTransports()"
	/// /> to apply it. This will be saved in configuration file so you don't have to
	/// do it each time the <see cref="Linphone.Core" /> starts. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Transports : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_transports_get_dtls_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_transports_set_dtls_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the DTLS port in the <see cref="Linphone.Transports" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the DTLS port </returns>
		public int DtlsPort
		{
			get
			{
				return linphone_transports_get_dtls_port(nativePtr);
			}
			set
			{
				linphone_transports_set_dtls_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_transports_get_tcp_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_transports_set_tcp_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the TCP port in the <see cref="Linphone.Transports" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the TCP port </returns>
		public int TcpPort
		{
			get
			{
				return linphone_transports_get_tcp_port(nativePtr);
			}
			set
			{
				linphone_transports_set_tcp_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_transports_get_tls_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_transports_set_tls_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the TLS port in the <see cref="Linphone.Transports" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the TLS port </returns>
		public int TlsPort
		{
			get
			{
				return linphone_transports_get_tls_port(nativePtr);
			}
			set
			{
				linphone_transports_set_tls_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_transports_get_udp_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_transports_set_udp_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the UDP port in the <see cref="Linphone.Transports" /> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the UDP port </returns>
		public int UdpPort
		{
			get
			{
				return linphone_transports_get_udp_port(nativePtr);
			}
			set
			{
				linphone_transports_set_udp_port(nativePtr, value);
				
			}
		}
	}
	/// <summary>
	/// Linphone tunnel object. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Tunnel : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_tunnel_get_activated(IntPtr thiz);

		/// <summary>
		/// Returns whether the tunnel is activated. 
		/// <para>
		/// If mode is set to auto, this gives indication whether the automatic detection
		/// determined that tunnel was necessary or not. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if tunnel is in use, false otherwise. </returns>
		public bool Activated
		{
			get
			{
				return linphone_tunnel_get_activated(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_tunnel_get_domain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_set_domain(IntPtr thiz, string domain);

		/// <summary>
		/// Get the domain. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The domain.   </returns>
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_tunnel_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_tunnel_set_domain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_tunnel_dual_mode_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_enable_dual_mode(IntPtr thiz, char dualModeEnabled);

		/// <summary>
		/// Get the dual tunnel client mode. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if dual tunnel client mode is enabled, false otherwise </returns>
		public bool DualModeEnabled
		{
			get
			{
				return linphone_tunnel_dual_mode_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_tunnel_enable_dual_mode(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.TunnelMode linphone_tunnel_get_mode(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_set_mode(IntPtr thiz, int mode);

		/// <summary>
		/// Get the tunnel mode. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current LinphoneTunnelMode </returns>
		public Linphone.TunnelMode Mode
		{
			get
			{
				return linphone_tunnel_get_mode(nativePtr);
			}
			set
			{
				linphone_tunnel_set_mode(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_tunnel_get_servers(IntPtr thiz);

		/// <summary>
		/// Get added servers. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.TunnelConfig" /> objects.
		/// LinphoneTunnelConfig    </returns>
		public IEnumerable<Linphone.TunnelConfig> Servers
		{
			get
			{
				return MarshalBctbxList<Linphone.TunnelConfig>(linphone_tunnel_get_servers(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_tunnel_sip_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_enable_sip(IntPtr thiz, char enable);

		/// <summary>
		/// Check whether tunnel is set to transport SIP packets. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether SIP packets shall pass through the
		/// tunnel </returns>
		public bool SipEnabled
		{
			get
			{
				return linphone_tunnel_sip_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_tunnel_enable_sip(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_tunnel_get_username(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_set_username(IntPtr thiz, string username);

		/// <summary>
		/// Get the username. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The username.   </returns>
		public string Username
		{
			get
			{
				IntPtr stringPtr = linphone_tunnel_get_username(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_tunnel_set_username(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_add_server(IntPtr thiz, IntPtr tunnelConfig);

		/// <summary>
		/// Add a tunnel server configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="tunnelConfig"><see cref="Linphone.TunnelConfig" /> object  
		/// </param>
		/// 
		public void AddServer(Linphone.TunnelConfig tunnelConfig)
		{
			linphone_tunnel_add_server(nativePtr, tunnelConfig != null ? tunnelConfig.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_clean_servers(IntPtr thiz);

		/// <summary>
		/// Remove all tunnel server addresses previously entered with <see
		/// cref="Linphone.Tunnel.AddServer()" /> 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void CleanServers()
		{
			linphone_tunnel_clean_servers(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_tunnel_connected(IntPtr thiz);

		/// <summary>
		/// Check whether the tunnel is connected. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling if the tunnel is connected </returns>
		public bool Connected()
		{
			bool returnVal = linphone_tunnel_connected(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_reconnect(IntPtr thiz);

		/// <summary>
		/// Force reconnection to the tunnel server. 
		/// <para>
		/// This method is useful when the device switches from wifi to Edge/3G or vice
		/// versa. In most cases the tunnel client socket won't be notified promptly that
		/// its connection is now zombie, so it is recommended to call this method that
		/// will cause the lost connection to be closed and new connection to be issued. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void Reconnect()
		{
			linphone_tunnel_reconnect(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_remove_server(IntPtr thiz, IntPtr tunnelConfig);

		/// <summary>
		/// Remove a tunnel server configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="tunnelConfig"><see cref="Linphone.TunnelConfig" /> object  
		/// </param>
		/// 
		public void RemoveServer(Linphone.TunnelConfig tunnelConfig)
		{
			linphone_tunnel_remove_server(nativePtr, tunnelConfig != null ? tunnelConfig.nativePtr : IntPtr.Zero);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_set_http_proxy(IntPtr thiz, string host, int port, string username, string passwd);

		/// <summary>
		/// Set an optional http proxy to go through when connecting to tunnel server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="host">http proxy host   </param>
		/// <param name="port">http proxy port </param>
		/// <param name="username">Optional http proxy username if the proxy request
		/// authentication. Currently only basic authentication is supported. Use null if
		/// not needed.   </param>
		/// <param name="passwd">Optional http proxy password. Use null if not needed.  
		/// </param>
		/// 
		public void SetHttpProxy(string host, int port, string username, string passwd)
		{
			linphone_tunnel_set_http_proxy(nativePtr, host, port, username, passwd);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_set_http_proxy_auth_info(IntPtr thiz, string username, string passwd);

		/// <summary>
		/// Set authentication info for the http proxy. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="username">User name   </param>
		/// <param name="passwd">Password   </param>
		/// 
		public void SetHttpProxyAuthInfo(string username, string passwd)
		{
			linphone_tunnel_set_http_proxy_auth_info(nativePtr, username, passwd);
			
			
			
		}
	}
	/// <summary>
	/// Tunnel settings. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class TunnelConfig : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_tunnel_config_get_delay(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_config_set_delay(IntPtr thiz, int delay);

		/// <summary>
		/// Get the UDP packet round trip delay in ms for a tunnel configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The UDP packet round trip delay in ms. </returns>
		public int Delay
		{
			get
			{
				return linphone_tunnel_config_get_delay(nativePtr);
			}
			set
			{
				linphone_tunnel_config_set_delay(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_tunnel_config_get_host(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_config_set_host(IntPtr thiz, string host);

		/// <summary>
		/// Get the IP address or hostname of the tunnel server. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The tunnel server IP address or hostname.   </returns>
		public string Host
		{
			get
			{
				IntPtr stringPtr = linphone_tunnel_config_get_host(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_tunnel_config_set_host(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_tunnel_config_get_host2(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_config_set_host2(IntPtr thiz, string host);

		/// <summary>
		/// Get the IP address or hostname of the second tunnel server when using dual
		/// tunnel client. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The tunnel server IP address or hostname.   </returns>
		public string Host2
		{
			get
			{
				IntPtr stringPtr = linphone_tunnel_config_get_host2(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_tunnel_config_set_host2(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_tunnel_config_get_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_config_set_port(IntPtr thiz, int port);

		/// <summary>
		/// Get the TLS port of the tunnel server. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The TLS port of the tunnel server </returns>
		public int Port
		{
			get
			{
				return linphone_tunnel_config_get_port(nativePtr);
			}
			set
			{
				linphone_tunnel_config_set_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_tunnel_config_get_port2(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_config_set_port2(IntPtr thiz, int port);

		/// <summary>
		/// Get the TLS port of the second tunnel server when using dual tunnel client. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The TLS port of the tunnel server </returns>
		public int Port2
		{
			get
			{
				return linphone_tunnel_config_get_port2(nativePtr);
			}
			set
			{
				linphone_tunnel_config_set_port2(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_tunnel_config_get_remote_udp_mirror_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_config_set_remote_udp_mirror_port(IntPtr thiz, int remoteUdpMirrorPort);

		/// <summary>
		/// Get the remote port on the tunnel server side used to test UDP reachability. 
		/// <para>
		/// This is used when the mode is set auto, to detect whether the tunnel has to be
		/// enabled or not. 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The remote port on the tunnel server side used to test UDP
		/// reachability </returns>
		public int RemoteUdpMirrorPort
		{
			get
			{
				return linphone_tunnel_config_get_remote_udp_mirror_port(nativePtr);
			}
			set
			{
				linphone_tunnel_config_set_remote_udp_mirror_port(nativePtr, value);
				
			}
		}
	}
	/// <summary>
	/// Object storing contact information using vCard 4.0 format. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Vcard : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_etag(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_etag(IntPtr thiz, string etag);

		/// <summary>
		/// Gets the eTag of the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the eTag of the vCard in the CardDAV server, otherwise null.  
		/// </returns>
		public string Etag
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_etag(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_etag(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_family_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_family_name(IntPtr thiz, string name);

		/// <summary>
		/// Returns the family name in the N attribute of the vCard, or null if it isn't
		/// set yet. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the family name of the vCard, or null   </returns>
		public string FamilyName
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_family_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_family_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_full_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_full_name(IntPtr thiz, string name);

		/// <summary>
		/// Returns the FN attribute of the vCard, or null if it isn't set yet. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the display name of the vCard, or null.   </returns>
		public string FullName
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_full_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_full_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_given_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_given_name(IntPtr thiz, string name);

		/// <summary>
		/// Returns the given name in the N attribute of the vCard, or null if it isn't set
		/// yet. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the given name of the vCard, or null   </returns>
		public string GivenName
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_given_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_given_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_organization(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_organization(IntPtr thiz, string organization);

		/// <summary>
		/// Gets the Organization of the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the Organization of the vCard or null.   </returns>
		public string Organization
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_organization(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_organization(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_phone_numbers(IntPtr thiz);

		/// <summary>
		/// Returns the list of phone numbers (as string) in the vCard (all the TEL
		/// attributes) or null. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of const char * objects. const char *    </returns>
		public IEnumerable<string> PhoneNumbers
		{
			get
			{
				return MarshalStringArray(linphone_vcard_get_phone_numbers(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_sip_addresses(IntPtr thiz);

		/// <summary>
		/// Returns the list of SIP addresses (as LinphoneAddress) in the vCard (all the
		/// IMPP attributes that has an URI value starting by "sip:") or null. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of <see cref="Linphone.Address" /> objects. LinphoneAddress   
		/// </returns>
		public IEnumerable<Linphone.Address> SipAddresses
		{
			get
			{
				return MarshalBctbxList<Linphone.Address>(linphone_vcard_get_sip_addresses(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_vcard_get_skip_validation(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_skip_validation(IntPtr thiz, char skip);

		/// <summary>
		/// Returns the skipFieldValidation property of the vcard. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the skipFieldValidation property of the vcard </returns>
		public bool SkipValidation
		{
			get
			{
				return linphone_vcard_get_skip_validation(nativePtr) != 0;
			}
			set
			{
				linphone_vcard_set_skip_validation(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_uid(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_uid(IntPtr thiz, string uid);

		/// <summary>
		/// Gets the UID of the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the UID of the vCard, otherwise null.   </returns>
		public string Uid
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_uid(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_uid(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_url(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_url(IntPtr thiz, string url);

		/// <summary>
		/// Gets the URL of the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>the URL of the vCard in the CardDAV server, otherwise null.  
		/// </returns>
		public string Url
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_url(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_url(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_add_phone_number(IntPtr thiz, string phone);

		/// <summary>
		/// Adds a phone number in the vCard, using the TEL property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phone">the phone number to add   </param>
		/// 
		public void AddPhoneNumber(string phone)
		{
			linphone_vcard_add_phone_number(nativePtr, phone);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_add_sip_address(IntPtr thiz, string sipAddress);

		/// <summary>
		/// Adds a SIP address in the vCard, using the IMPP property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="sipAddress">the SIP address to add   </param>
		/// 
		public void AddSipAddress(string sipAddress)
		{
			linphone_vcard_add_sip_address(nativePtr, sipAddress);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_as_vcard4_string(IntPtr thiz);

		/// <summary>
		/// Returns the vCard4 representation of the LinphoneVcard. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a const char * that represents the vCard.   </returns>
		public string AsVcard4String()
		{
			IntPtr stringPtr = linphone_vcard_as_vcard4_string(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_clone(IntPtr thiz);

		/// <summary>
		/// Clone a <see cref="Linphone.Vcard" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>a new <see cref="Linphone.Vcard" /> object   </returns>
		public Linphone.Vcard Clone()
		{
			IntPtr ptr = linphone_vcard_clone(nativePtr);
			Linphone.Vcard returnVal = fromNativePtr<Linphone.Vcard>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_edit_main_sip_address(IntPtr thiz, string sipAddress);

		/// <summary>
		/// Edits the preferred SIP address in the vCard (or the first one), using the IMPP
		/// property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="sipAddress">the new SIP address   </param>
		/// 
		public void EditMainSipAddress(string sipAddress)
		{
			linphone_vcard_edit_main_sip_address(nativePtr, sipAddress);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_vcard_generate_unique_id(IntPtr thiz);

		/// <summary>
		/// Generates a random unique id for the vCard. 
		/// <para>
		/// If is required to be able to synchronize the vCard with a CardDAV server 
		/// 
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>true if operation is successful, otherwise false (for example if it
		/// already has an unique ID) </returns>
		public bool GenerateUniqueId()
		{
			bool returnVal = linphone_vcard_generate_unique_id(nativePtr) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_remove_organization(IntPtr thiz);

		/// <summary>
		/// Removes the Organization field of the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		public void RemoveOrganization()
		{
			linphone_vcard_remove_organization(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_remove_phone_number(IntPtr thiz, string phone);

		/// <summary>
		/// Removes a phone number in the vCard (if it exists), using the TEL property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phone">the phone number to remove   </param>
		/// 
		public void RemovePhoneNumber(string phone)
		{
			linphone_vcard_remove_phone_number(nativePtr, phone);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_remove_sip_address(IntPtr thiz, string sipAddress);

		/// <summary>
		/// Removes a SIP address in the vCard (if it exists), using the IMPP property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="sipAddress">the SIP address to remove   </param>
		/// 
		public void RemoveSipAddress(string sipAddress)
		{
			linphone_vcard_remove_sip_address(nativePtr, sipAddress);
			
			
			
		}
	}
	/// <summary>
	/// Object describing policy regarding video streams establishments. 
	/// <para>
	/// Use <see cref="Linphone.VideoActivationPolicy.SetAutomaticallyAccept()" /> and
	/// <see cref="Linphone.VideoActivationPolicy.SetAutomaticallyInitiate()" /> to
	/// tell the Core to automatically accept or initiate video during calls.
	/// 
	/// Even if disabled, you'll still be able to add it later while the call is
	/// running. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class VideoActivationPolicy : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_video_activation_policy_get_automatically_accept(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_activation_policy_set_automatically_accept(IntPtr thiz, char enable);

		/// <summary>
		/// Gets the value for the automatically accept video policy. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>whether or not to automatically accept video requests is enabled
		/// </returns>
		public bool AutomaticallyAccept
		{
			get
			{
				return linphone_video_activation_policy_get_automatically_accept(nativePtr) != 0;
			}
			set
			{
				linphone_video_activation_policy_set_automatically_accept(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_video_activation_policy_get_automatically_initiate(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_activation_policy_set_automatically_initiate(IntPtr thiz, char enable);

		/// <summary>
		/// Gets the value for the automatically initiate video policy. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>whether or not to automatically initiate video calls is enabled
		/// </returns>
		public bool AutomaticallyInitiate
		{
			get
			{
				return linphone_video_activation_policy_get_automatically_initiate(nativePtr) != 0;
			}
			set
			{
				linphone_video_activation_policy_set_automatically_initiate(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
	}
	/// <summary>
	/// This object represents a video definition, eg. 
	/// <para>
	/// it's width, it's height and possibly it's name.
	/// 
	/// It is mostly used to configure the default video size sent by your camera
	/// during a video call with <see
	/// cref="Linphone.Core.SetPreferredVideoDefinition()" /> method. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class VideoDefinition : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_video_definition_get_height(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_definition_set_height(IntPtr thiz, uint height);

		/// <summary>
		/// Get the height of the video definition. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The height of the video definition </returns>
		public uint Height
		{
			get
			{
				return linphone_video_definition_get_height(nativePtr);
			}
			set
			{
				linphone_video_definition_set_height(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_video_definition_is_undefined(IntPtr thiz);

		/// <summary>
		/// Tells whether a <see cref="Linphone.VideoDefinition" /> is undefined. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A boolean value telling whether the <see
		/// cref="Linphone.VideoDefinition" /> is undefined. </returns>
		public bool IsUndefined
		{
			get
			{
				return linphone_video_definition_is_undefined(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_video_definition_get_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_definition_set_name(IntPtr thiz, string name);

		/// <summary>
		/// Get the name of the video definition. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The name of the video definition   </returns>
		public string Name
		{
			get
			{
				IntPtr stringPtr = linphone_video_definition_get_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_video_definition_set_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_video_definition_get_width(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_definition_set_width(IntPtr thiz, uint width);

		/// <summary>
		/// Get the width of the video definition. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The width of the video definition </returns>
		public uint Width
		{
			get
			{
				return linphone_video_definition_get_width(nativePtr);
			}
			set
			{
				linphone_video_definition_set_width(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_video_definition_clone(IntPtr thiz);

		/// <summary>
		/// Clone a video definition. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The new clone of the video definition   </returns>
		public Linphone.VideoDefinition Clone()
		{
			IntPtr ptr = linphone_video_definition_clone(nativePtr);
			Linphone.VideoDefinition returnVal = fromNativePtr<Linphone.VideoDefinition>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_video_definition_equals(IntPtr thiz, IntPtr videoDefinition2);

		/// <summary>
		/// Tells whether two <see cref="Linphone.VideoDefinition" /> objects are equal
		/// (the widths and the heights are the same but can be switched). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="videoDefinition2"><see cref="Linphone.VideoDefinition" /> object  
		/// </param>
		/// 
		/// 
		/// <returns>A boolean value telling whether the two <see
		/// cref="Linphone.VideoDefinition" /> objects are equal. </returns>
		public bool Equals(Linphone.VideoDefinition videoDefinition2)
		{
			bool returnVal = linphone_video_definition_equals(nativePtr, videoDefinition2 != null ? videoDefinition2.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_definition_set_definition(IntPtr thiz, uint width, uint height);

		/// <summary>
		/// Set the width and the height of the video definition. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="width">The width of the video definition </param>
		/// <param name="height">The height of the video definition </param>
		/// 
		public void SetDefinition(uint width, uint height)
		{
			linphone_video_definition_set_definition(nativePtr, width, height);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_video_definition_strict_equals(IntPtr thiz, IntPtr videoDefinition2);

		/// <summary>
		/// Tells whether two <see cref="Linphone.VideoDefinition" /> objects are strictly
		/// equal (the widths are the same and the heights are the same). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="videoDefinition2"><see cref="Linphone.VideoDefinition" /> object  
		/// </param>
		/// 
		/// 
		/// <returns>A boolean value telling whether the two <see
		/// cref="Linphone.VideoDefinition" /> objects are strictly equal. </returns>
		public bool StrictEquals(Linphone.VideoDefinition videoDefinition2)
		{
			bool returnVal = linphone_video_definition_strict_equals(nativePtr, videoDefinition2 != null ? videoDefinition2.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			return returnVal;
		}
	}
	/// <summary>
	/// The <see cref="Linphone.XmlRpcRequest" /> object representing a XML-RPC request
	/// to be sent. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class XmlRpcRequest : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_xml_rpc_request_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_remove_callbacks(IntPtr thiz, IntPtr cbs);

		~XmlRpcRequest() 
		{
			if (listener != null)
			{
				linphone_xml_rpc_request_remove_callbacks(nativePtr, listener.nativePtr);
			}
		}

		private XmlRpcRequestListener listener;

		public XmlRpcRequestListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_xml_rpc_request_cbs(linphone_factory_get());
					listener = fromNativePtr<XmlRpcRequestListener>(nativeListener, false);
					linphone_xml_rpc_request_add_callbacks(nativePtr, nativeListener);
					listener.register();
				}
				return listener;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_get_content(IntPtr thiz);

		/// <summary>
		/// Get the content of the XML-RPC request. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The string representation of the content of the XML-RPC request.  
		/// </returns>
		public string Content
		{
			get
			{
				IntPtr stringPtr = linphone_xml_rpc_request_get_content(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_get_current_callbacks(IntPtr thiz);

		/// <summary>
		/// Get the current LinphoneXmlRpcRequestCbs object associated with a
		/// LinphoneXmlRpcRequest. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The current LinphoneXmlRpcRequestCbs object associated with the
		/// LinphoneXmlRpcRequest.   </returns>
		public Linphone.XmlRpcRequestListener CurrentCallbacks
		{
			get
			{
				IntPtr ptr = linphone_xml_rpc_request_get_current_callbacks(nativePtr);
				Linphone.XmlRpcRequestListener obj = fromNativePtr<Linphone.XmlRpcRequestListener>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_xml_rpc_request_get_int_response(IntPtr thiz);

		/// <summary>
		/// Get the response to an XML-RPC request sent with <see
		/// cref="Linphone.XmlRpcSession.SendRequest()" /> and returning an integer
		/// response. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The integer response to the XML-RPC request. </returns>
		public int IntResponse
		{
			get
			{
				return linphone_xml_rpc_request_get_int_response(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_get_list_response(IntPtr thiz);

		/// <summary>
		/// Get the response to an XML-RPC request sent with <see
		/// cref="Linphone.XmlRpcSession.SendRequest()" /> and returning a string response. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>A list of const char * objects. const char *  A list of all string
		/// responses in the XML-RPC request.   </returns>
		public IEnumerable<string> ListResponse
		{
			get
			{
				return MarshalStringArray(linphone_xml_rpc_request_get_list_response(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_get_raw_response(IntPtr thiz);

		/// <summary>
		/// Get the raw response to an XML-RPC request sent with <see
		/// cref="Linphone.XmlRpcSession.SendRequest()" /> and returning http body as
		/// string. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The string response to the XML-RPC request.   </returns>
		public string RawResponse
		{
			get
			{
				IntPtr stringPtr = linphone_xml_rpc_request_get_raw_response(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.XmlRpcStatus linphone_xml_rpc_request_get_status(IntPtr thiz);

		/// <summary>
		/// Get the status of the XML-RPC request. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The LinphoneXmlRpcStatus of the XML-RPC request. </returns>
		public Linphone.XmlRpcStatus Status
		{
			get
			{
				return linphone_xml_rpc_request_get_status(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_get_string_response(IntPtr thiz);

		/// <summary>
		/// Get the response to an XML-RPC request sent with <see
		/// cref="Linphone.XmlRpcSession.SendRequest()" /> and returning a string response. 
		/// <para>
		/// </para>
		/// </summary>
		/// 
		/// 
		/// <returns>The string response to the XML-RPC request.   </returns>
		public string StringResponse
		{
			get
			{
				IntPtr stringPtr = linphone_xml_rpc_request_get_string_response(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_xml_rpc_request_add_int_arg(IntPtr thiz, int val);

		/// <summary>
		/// Add an integer argument to an XML-RPC request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="val">The integer value of the added argument. </param>
		/// 
		public void AddIntArg(int val)
		{
			linphone_xml_rpc_request_add_int_arg(nativePtr, val);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_xml_rpc_request_add_string_arg(IntPtr thiz, string val);

		/// <summary>
		/// Add a string argument to an XML-RPC request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="val">The string value of the added argument.   </param>
		/// 
		public void AddStringArg(string val)
		{
			linphone_xml_rpc_request_add_string_arg(nativePtr, val);
			
			
			
		}
	}
	/// <summary>
	/// The <see cref="Linphone.XmlRpcSession" /> object used to send XML-RPC requests
	/// and handle their responses. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class XmlRpcSession : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_session_create_request(IntPtr thiz, int returnType, string method);

		/// <summary>
		/// Creates a <see cref="Linphone.XmlRpcRequest" /> from a <see
		/// cref="Linphone.XmlRpcSession" />. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="returnType">the return type of the request as a
		/// LinphoneXmlRpcArgType </param>
		/// <param name="method">the function name to call   </param>
		/// 
		/// 
		/// <returns>a <see cref="Linphone.XmlRpcRequest" /> object   </returns>
		public Linphone.XmlRpcRequest CreateRequest(Linphone.XmlRpcArgType returnType, string method)
		{
			IntPtr ptr = linphone_xml_rpc_session_create_request(nativePtr, (int)returnType, method);
			Linphone.XmlRpcRequest returnVal = fromNativePtr<Linphone.XmlRpcRequest>(ptr, false);
			
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_xml_rpc_session_release(IntPtr thiz);

		/// <summary>
		/// Stop and unref an XML rpc session. 
		/// <para>
		/// Pending requests will be aborted. 
		/// 
		/// </para>
		/// </summary>
		/// 
		public void Release()
		{
			linphone_xml_rpc_session_release(nativePtr);
			
			
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_xml_rpc_session_send_request(IntPtr thiz, IntPtr request);

		/// <summary>
		/// Send an XML-RPC request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="request">The <see cref="Linphone.XmlRpcRequest" /> to be sent.  
		/// </param>
		/// 
		public void SendRequest(Linphone.XmlRpcRequest request)
		{
			linphone_xml_rpc_session_send_request(nativePtr, request != null ? request.nativePtr : IntPtr.Zero);
			
			
			
		}
	}
#endregion
}
